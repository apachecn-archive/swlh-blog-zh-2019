<html>
<head>
<title>Javascript: end to end unit tests?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Javascript:端到端单元测试？</h1>
<blockquote>原文：<a href="https://medium.com/swlh/javascript-end-to-end-unit-tests-96df855d0ec8?source=collection_archive---------32-----------------------#2019-06-09">https://medium.com/swlh/javascript-end-to-end-unit-tests-96df855d0ec8?source=collection_archive---------32-----------------------#2019-06-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/fdd04fb61d78377d28680b7f9040e8f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1060/1*UCmx0Ua_WA8V6IrTupM7pA.gif"/></div><figcaption class="im in et er es io ip bd b be z dx">Image by <a class="ae iq" href="https://commons.wikimedia.org/wiki/User:%D0%94%D0%BC%D0%B8%D1%82%D1%80%D0%B8%D0%B9_%D0%A1%D1%83%D1%82%D1%8F%D0%B3%D0%B8%D0%BD" rel="noopener ugc nofollow" target="_blank">Dmitry Sutyagin</a>, available under <a class="ae iq" href="https://en.wikipedia.org/wiki/en:GNU_Free_Documentation_License" rel="noopener ugc nofollow" target="_blank"><strong class="bd ir">GNU Free Documentation License</strong></a></figcaption></figure><p id="5386" class="pw-post-body-paragraph is it hi iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hb bi translated"><strong class="iu jq"> TL:DR </strong>本文将提供一个javascript架构，允许您:</p><ul class=""><li id="ca9c" class="jr js hi iu b iv iw iz ja jd jt jh ju jl jv jp jw jx jy jz bi translated">在您工作的同时，以单元测试的速度连续测试您的代码</li><li id="61a6" class="jr js hi iu b iv ka iz kb jd kc jh kd jl ke jp jw jx jy jz bi translated">将副作用从应用程序的其余部分中分离出来</li><li id="1b1e" class="jr js hi iu b iv ka iz kb jd kc jh kd jl ke jp jw jx jy jz bi translated">避免ES6类的所有怪异之处</li></ul><h1 id="cae9" class="kf kg hi bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated"><strong class="ak">问题</strong></h1><p id="fcaf" class="pw-post-body-paragraph is it hi iu b iv ld ix iy iz le jb jc jd lf jf jg jh lg jj jk jl lh jn jo jp hb bi translated">我希望能够在我工作的时候连续不断地测试我的代码。我希望单元测试的速度和组件测试的覆盖率一样。</p><p id="3ea6" class="pw-post-body-paragraph is it hi iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hb bi translated"><strong class="iu jq">一个解决方案</strong></p><p id="d968" class="pw-post-body-paragraph is it hi iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hb bi translated">为了研究这个问题和可能的解决方案，让我们看一个玩具应用程序，它包含以下文件:</p><pre class="li lj lk ll fd lm ln lo lp aw lq bi"><span id="c771" class="lr kg hi ln b fi ls lt l lu lv">src/<br/>   index.js<br/>   Account.js<br/>   AccountFilter.js<br/> <br/>   clients/<br/>     AccountClient.js</span><span id="ff1b" class="lr kg hi ln b fi lw lt l lu lv">test/<br/>   index.spec.js<br/>   Account.spec.js<br/>   AccountFilter.spec.js<br/> <br/>   clients/<br/>     AccountClient.spec.js<br/>.babelrc<br/>package.json</span></pre><p id="85e4" class="pw-post-body-paragraph is it hi iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hb bi translated">和应用流程:</p><figure class="li lj lk ll fd ij er es paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="er es lx"><img src="../Images/94eccd790af8911634760bbd03210161.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AvwfvbgvDNSgvHIt1yeXTg.png"/></div></div></figure><p id="e501" class="pw-post-body-paragraph is it hi iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hb bi translated">让我们从<em class="mc"> index.js </em>到<em class="mc"> AccountClient.js </em>来展示允许我们进行端到端测试的结构:</p><h1 id="36d9" class="kf kg hi bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">索引. js</h1><figure class="li lj lk ll fd ij"><div class="bz dy l di"><div class="md me l"/></div></figure><p id="3e92" class="pw-post-body-paragraph is it hi iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hb bi translated"><strong class="iu jq">规则1:具有异步方法的实体必须在程序入口初始化。</strong></p><p id="dff2" class="pw-post-body-paragraph is it hi iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hb bi translated">为了启用端到端单元测试，我们需要实例化任何在<em class="mc"> index.js </em>中有异步方法的实体。我们从一个在互联网上进行呼叫的实体开始，然后回溯到<em class="mc"> index.js </em>。每个实体将依次被传递它所使用的任何依赖项，这些依赖项也有异步方法(第8-9行)。所以:</p><ul class=""><li id="2421" class="jr js hi iu b iv iw iz ja jd jt jh ju jl jv jp jw jx jy jz bi translated">帐户客户端获取(axios)</li><li id="a420" class="jr js hi iu b iv ka iz kb jd kc jh kd jl ke jp jw jx jy jz bi translated">帐户获取(帐户客户端)</li><li id="a1eb" class="jr js hi iu b iv ka iz kb jd kc jh kd jl ke jp jw jx jy jz bi translated">index.js调用帐户</li></ul><p id="9009" class="pw-post-body-paragraph is it hi iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hb bi translated">现在我们已经在应用程序的入口点初始化了http客户端，它可以很容易地在我们的<em class="mc"> index.spec.js </em>测试套件中进行存根化。</p><h1 id="3599" class="kf kg hi bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">帐户. js</h1><figure class="li lj lk ll fd ij"><div class="bz dy l di"><div class="md me l"/></div></figure><p id="bc82" class="pw-post-body-paragraph is it hi iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hb bi translated">规则2:使用工厂函数来表示实体。</p><p id="4c44" class="pw-post-body-paragraph is it hi iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hb bi translated">上网要注意的第一件事。3是我们使用工厂函数而不是ES6类。这是因为它们服务于完全相同的目的，但是比ES6类更加通用，正如我们将进一步看到的例子。</p><p id="6c9d" class="pw-post-body-paragraph is it hi iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hb bi translated">工厂函数的关键点在于，它的参数等同于类构造函数的参数，并且它的return语句传递回作为类实例的对象。<em class="mc"> Object.freeze </em>不是强制的，它的目的是密封对象，防止进一步的改变。</p><p id="2a38" class="pw-post-body-paragraph is it hi iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hb bi translated">Nb。如果你想更深入地研究工厂功能的主题，那么在这篇文章的底部有一个链接，链接到Eric Elliott的一篇很棒的文章。</p><p id="d528" class="pw-post-body-paragraph is it hi iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hb bi translated">您可能还会注意到，虽然第3行中的参数传递给了<em class="mc">帐户</em>帐户<em class="mc">帐户客户端</em>，但是第4行中的参数也对其进行了初始化。这是因为AccountClient是一个curried函数，我们接下来会看到它。</p><h1 id="d360" class="kf kg hi bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">帐户客户端. js</h1><figure class="li lj lk ll fd ij"><div class="bz dy l di"><div class="md me l"/></div></figure><p id="cb09" class="pw-post-body-paragraph is it hi iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hb bi translated"><strong class="iu jq">规则3:除了在应用程序的入口处传递的异步依赖之外，接受其他参数的实体必须被处理。</strong></p><p id="fea5" class="pw-post-body-paragraph is it hi iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hb bi translated">如前所述,<em class="mc"> AccountClient </em>在第14行导出时被处理。这意味着该函数可以一次调用一个参数(如果currying不是一个熟悉的术语，请查看本文底部的链接)。</p><p id="000b" class="pw-post-body-paragraph is it hi iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hb bi translated">首先，它的http客户端在<em class="mc"> index.js </em>中被部分应用:</p><pre class="li lj lk ll fd lm ln lo lp aw lq bi"><span id="f054" class="lr kg hi ln b fi ls lt l lu lv">const accountClient = AccountClient(axios)</span></pre><p id="f6fb" class="pw-post-body-paragraph is it hi iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hb bi translated">然后用<em class="mc"> Account.js </em>中的<em class="mc"> accountId </em>完全申请:</p><pre class="li lj lk ll fd lm ln lo lp aw lq bi"><span id="04a3" class="lr kg hi ln b fi ls lt l lu lv">const account = AccountClient('account_001')</span></pre><p id="a72c" class="pw-post-body-paragraph is it hi iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hb bi translated">只有当它完全应用了它的两个参数时，它才会在其return语句中返回对象。</p><p id="5877" class="pw-post-body-paragraph is it hi iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hb bi translated">就这样，我们构建了我们的代码，使得具有异步函数的实体的依赖链[Account，AccountClient，axios]都在<em class="mc"> index.js. </em>中初始化</p><p id="7079" class="pw-post-body-paragraph is it hi iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hb bi translated">现在我们有了一个可以进行端到端单元测试的结构，让我们使用测试驱动开发来编写一个完整的例子。</p><h1 id="0604" class="kf kg hi bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">编写示例代码</h1><pre class="li lj lk ll fd lm ln lo lp aw lq bi"><span id="5a38" class="lr kg hi ln b fi ls lt l lu lv">mkdir -p funjs/{src,test}</span><span id="92bc" class="lr kg hi ln b fi lw lt l lu lv">cd funjs</span><span id="7892" class="lr kg hi ln b fi lw lt l lu lv">npm init -y<br/>npm i ramda axios source-map-support</span><span id="8ad3" class="lr kg hi ln b fi lw lt l lu lv">npm install --save-dev chai mocha sinon proxyquire <a class="ae iq" href="http://twitter.com/babel/cli" rel="noopener ugc nofollow" target="_blank">@babel/cli</a> <a class="ae iq" href="http://twitter.com/babel/core" rel="noopener ugc nofollow" target="_blank">@babel/core</a> <a class="ae iq" href="http://twitter.com/babel/node" rel="noopener ugc nofollow" target="_blank">@babel/node</a> <a class="ae iq" href="http://twitter.com/babel/register" rel="noopener ugc nofollow" target="_blank">@babel/register</a> <a class="ae iq" href="http://twitter.com/babel/preset-env" rel="noopener ugc nofollow" target="_blank">@babel/preset-env</a> --save-dev</span></pre><p id="e78f" class="pw-post-body-paragraph is it hi iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hb bi translated">创建一个babel配置文件<code class="du mf mg mh ln b">touch .babelrc</code>并复制这个文本</p><pre class="li lj lk ll fd lm ln lo lp aw lq bi"><span id="f084" class="lr kg hi ln b fi ls lt l lu lv">{<br/>  "presets": [<br/>    [<br/>      "@babel/preset-env", {<br/>        "targets": {<br/>          "node": "current"<br/>        }<br/>      }<br/>    ]<br/>  ]<br/>}</span></pre><p id="57fa" class="pw-post-body-paragraph is it hi iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hb bi translated">替换package.json中的以下行:</p><pre class="li lj lk ll fd lm ln lo lp aw lq bi"><span id="bb7e" class="lr kg hi ln b fi ls lt l lu lv">"scripts": {<br/>  "test": "echo \"Error: no test specified\" &amp;&amp; exit 1"<br/>}</span></pre><p id="77a7" class="pw-post-body-paragraph is it hi iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hb bi translated">使用:</p><pre class="li lj lk ll fd lm ln lo lp aw lq bi"><span id="ecaf" class="lr kg hi ln b fi ls lt l lu lv">"scripts": {<br/>  "test:watch": "./node_modules/.bin/mocha --watch --recurse --require @babel/register"<br/>}</span></pre><p id="e246" class="pw-post-body-paragraph is it hi iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hb bi translated">让我们创建第一个测试文件<code class="du mf mg mh ln b">touch test/index.spec.js</code>来保存我们的端到端测试:</p><figure class="li lj lk ll fd ij"><div class="bz dy l di"><div class="md me l"/></div></figure><p id="a974" class="pw-post-body-paragraph is it hi iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hb bi translated">现在，我们可以在<em class="mc"> watch </em>标志打开的情况下执行测试框架，以便对我们从这里开始编写的任何代码进行连续测试:</p><pre class="li lj lk ll fd lm ln lo lp aw lq bi"><span id="6c36" class="lr kg hi ln b fi ls lt l lu lv">npm run test:watch</span></pre><p id="3d24" class="pw-post-body-paragraph is it hi iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hb bi translated">您现在应该看到您的第一个测试失败了，并显示消息:<br/> &gt;错误:找不到模块../src/index '</p><p id="46c7" class="pw-post-body-paragraph is it hi iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hb bi translated">因此，让我们暂时取消测试运行程序，创建我们的入口文件<code class="du mf mg mh ln b">touch src/index.js</code>，并复制以下代码:</p><figure class="li lj lk ll fd ij"><div class="bz dy l di"><div class="md me l"/></div></figure><p id="f808" class="pw-post-body-paragraph is it hi iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hb bi translated">如果您尝试再次运行测试运行程序，您将得到一个堆栈跟踪，抱怨找不到<em class="mc"> Account.js </em>或<em class="mc"> AccountClient.js </em>。</p><p id="2b1a" class="pw-post-body-paragraph is it hi iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hb bi translated">这是我们从端到端测试开始所付出的代价。应用程序的入口点知道应用程序远边缘的依赖关系(ln . 8–9 ),但是如果您还没有为这些依赖关系编写代码，那么您将会看到堆栈跟踪，指出文件或方法不存在。</p><p id="28ed" class="pw-post-body-paragraph is it hi iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hb bi translated">这不利于我们实践TDD的能力。我们希望为每个组件创建测试，同时端到端测试仍然在一个良好的测试报告中报告失败，而不是因为缺少文件或方法而被一个堆栈跟踪搞砸。</p><p id="a5a4" class="pw-post-body-paragraph is it hi iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hb bi translated">因此，为了保持恒定的覆盖率，我认为为每个依赖项创建带有空方法的框架文件和函数是可以接受的，这样我们就可以看到测试失败的正确测试报告，而不是堆栈跟踪。这是真的TDD吗？的确，我们在编写特定的单元测试之前编写代码，但是我们被端到端的测试所覆盖，所以我认为我们是部分合理的。如果这冒犯了任何人的TDD敏感性，那么我理解，我也喜欢正统的编程:)但是在这种情况下，我更想要端到端的测试。</p><p id="7904" class="pw-post-body-paragraph is it hi iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hb bi translated">因此，让我们为<em class="mc"> Account.js </em>和<em class="mc"> AccountClient.js </em> : <code class="du mf mg mh ln b">touch Account.js clients/AccountClient.js</code>创建两个具有框架工厂函数的新文件，以便我们可以看到正确的测试报告:</p><pre class="li lj lk ll fd lm ln lo lp aw lq bi"><span id="47bc" class="lr kg hi ln b fi ls lt l lu lv">function Account(AccountClient) {<br/>    async function getActiveAccounts() {}</span><span id="069d" class="lr kg hi ln b fi lw lt l lu lv">    return Object.freeze({<br/>        getActiveAccounts<br/>    })<br/>}</span><span id="7ad8" class="lr kg hi ln b fi lw lt l lu lv">export default Account</span></pre><p id="6849" class="pw-post-body-paragraph is it hi iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hb bi translated">和</p><pre class="li lj lk ll fd lm ln lo lp aw lq bi"><span id="96f0" class="lr kg hi ln b fi ls lt l lu lv">import * as R from 'ramda'</span><span id="e446" class="lr kg hi ln b fi lw lt l lu lv">export function AccountClient(httpClient, accountId) {<br/>    async function get() {}</span><span id="52a1" class="lr kg hi ln b fi lw lt l lu lv">    return Object.freeze({<br/>        get<br/>    })<br/>}</span><span id="21e2" class="lr kg hi ln b fi lw lt l lu lv">export default R.curry(AccountClient)</span></pre><p id="86b7" class="pw-post-body-paragraph is it hi iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hb bi translated"><strong class="iu jq">目前进展:</strong> 1个端到端测试失败:</p><figure class="li lj lk ll fd ij er es paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="er es mi"><img src="../Images/645585cf24769843801d6987724bb790.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DxLahykB3hzNX51xxeEY8g.png"/></div></div></figure><h1 id="9ae8" class="kf kg hi bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">照常对TDD的确认</h1><p id="db32" class="pw-post-body-paragraph is it hi iu b iv ld ix iy iz le jb jc jd lf jf jg jh lg jj jk jl lh jn jo jp hb bi translated">在“test”目录下创建一个新文件:<code class="du mf mg mh ln b">touch Account.spec.js</code>，并复制下面的代码。</p><figure class="li lj lk ll fd ij"><div class="bz dy l di"><div class="md me l"/></div></figure><p id="ca9d" class="pw-post-body-paragraph is it hi iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hb bi translated">并实现我们的帐户过滤器:</p><figure class="li lj lk ll fd ij"><div class="bz dy l di"><div class="md me l"/></div></figure><p id="200f" class="pw-post-body-paragraph is it hi iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hb bi translated"><em class="mc"> Nb。为了简洁起见，我省略了AccountFilter的测试。它在应用程序中的主要目的是显示纯实体和不纯实体声明方式的差异。</em></p><p id="5ea3" class="pw-post-body-paragraph is it hi iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hb bi translated">然后是我们的帐户域实体:</p><figure class="li lj lk ll fd ij"><div class="bz dy l di"><div class="md me l"/></div></figure><p id="ef55" class="pw-post-body-paragraph is it hi iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hb bi translated"><strong class="iu jq">迄今为止的进展:</strong> 1/2的测试通过:</p><figure class="li lj lk ll fd ij er es paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="er es mj"><img src="../Images/756899516e61ccae4d619c684c6f0695.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jmVIDJJ2tPgsdVDLoxyOKQ.png"/></div></div></figure><p id="fbb7" class="pw-post-body-paragraph is it hi iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hb bi translated">接下来让我们为<em class="mc"> AccountClient.js </em>设置一个单元测试:</p><figure class="li lj lk ll fd ij"><div class="bz dy l di"><div class="md me l"/></div></figure><p id="8875" class="pw-post-body-paragraph is it hi iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hb bi translated">和帐户客户端服务:</p><figure class="li lj lk ll fd ij"><div class="bz dy l di"><div class="md me l"/></div></figure><p id="297b" class="pw-post-body-paragraph is it hi iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hb bi translated"><strong class="iu jq">迄今为止的进展:</strong> 3/3的测试通过:</p><figure class="li lj lk ll fd ij er es paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="er es mk"><img src="../Images/20d93ec6b4358dc03a2dcaa087501f0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*56HqaKubze0yCTtfjGvWqA.png"/></div></div></figure><h1 id="5f08" class="kf kg hi bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated"><strong class="ak">总之</strong></h1><p id="8d2a" class="pw-post-body-paragraph is it hi iu b iv ld ix iy iz le jb jc jd lf jf jg jh lg jj jk jl lh jn jo jp hb bi translated">通过将ES6类替换为工厂函数，修改它们的参数，并在程序的入口点部分应用依赖关系，我们可以以单元测试速度运行端到端测试。</p><p id="a509" class="pw-post-body-paragraph is it hi iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hb bi translated">另外，我们还通过传入引起副作用的代码而不是在实体中实例化它来实现解耦，这使我们更喜欢单一责任原则，因为实体不需要创建对象也不需要执行其业务功能。</p><p id="bb0f" class="pw-post-body-paragraph is it hi iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hb bi translated">我们唯一牺牲的是ES6类，它不能在这种模式下工作，因为我们不能像处理工厂函数的参数那样处理ES6类构造函数。</p><p id="1649" class="pw-post-body-paragraph is it hi iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hb bi translated">虽然ES6类看起来很熟悉，但它们只是工厂函数的受限版本，开发人员为了使用它们必须学习很多奇怪的东西。考虑以下关键字的价值:</p><ul class=""><li id="82f5" class="jr js hi iu b iv iw iz ja jd jt jh ju jl jv jp jw jx jy jz bi translated"><strong class="iu jq">这个</strong>:它的意思在不同的范围内变化</li><li id="9fe5" class="jr js hi iu b iv ka iz kb jd kc jh kd jl ke jp jw jx jy jz bi translated">静态:对象可以有不改变状态的方法，我们不需要静态关键字</li><li id="09fe" class="jr js hi iu b iv ka iz kb jd kc jh kd jl ke jp jw jx jy jz bi translated"><strong class="iu jq">扩展</strong>:鼓励脆弱的继承架构</li><li id="e622" class="jr js hi iu b iv ka iz kb jd kc jh kd jl ke jp jw jx jy jz bi translated"><strong class="iu jq"> bind </strong>:一个解决“this”问题的方法</li><li id="39eb" class="jr js hi iu b iv ka iz kb jd kc jh kd jl ke jp jw jx jy jz bi translated"><strong class="iu jq">类中的箭头vs普通函数</strong>:另一种解决“this”问题的方法</li></ul><h1 id="fb79" class="kf kg hi bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">潜在问题</h1><p id="e885" class="pw-post-body-paragraph is it hi iu b iv ld ix iy iz le jb jc jd lf jf jg jh lg jj jk jl lh jn jo jp hb bi translated">拥有端到端的单元测试能力可能会鼓励人们只在index.js进行测试，或者在这个级别聚集太多的测试。</p><p id="a55d" class="pw-post-body-paragraph is it hi iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hb bi translated">我认为支持为每个存在的http端点创建端到端测试的约定是明智的。这些将是<a class="ae iq" href="https://en.wikipedia.org/wiki/Happy_path" rel="noopener ugc nofollow" target="_blank">快乐之路</a>测试。一个普通的微服务不会调用许多不同的端点，所以这应该会限制端到端测试的数量。</p><p id="138a" class="pw-post-body-paragraph is it hi iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hb bi translated">没有proxyquire，我们能完成吗？</p><p id="609d" class="pw-post-body-paragraph is it hi iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hb bi translated">是的，我们可以引入一个使用<em class="mc"> proxyquire </em>的架构，但这会涉及更多的代码，这使得将这种模式改造成现有的代码有点麻烦。<em class="mc"> proxyquire </em>的确增加了一点魔力，它用存根代替了我们的依赖关系，但它的使用仅限于<em class="mc"> index.js </em>。</p><p id="f1e1" class="pw-post-body-paragraph is it hi iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hb bi translated"><em class="mc">我们应该这样做吗，这会破坏单元测试的最佳实践吗？</em></p><p id="5292" class="pw-post-body-paragraph is it hi iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hb bi translated">我不确定，我想人们会有不同的意见，但它确实在你编码的同时，以单元测试的速度给出了明智的解耦和更好的代码覆盖率，所以我认为它引入的任何妥协都是值得的。只要您仍然坚持正常的TDD并对index.js下的每个文件进行单元测试，那么您应该是安全的。</p><h1 id="cf8a" class="kf kg hi bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">参考</h1><p id="1416" class="pw-post-body-paragraph is it hi iu b iv ld ix iy iz le jb jc jd lf jf jg jh lg jj jk jl lh jn jo jp hb bi translated">Currying，局部应用和功能组成:</p><div class="ml mm ez fb mn mo"><a rel="noopener follow" target="_blank" href="/javascript-scene/curry-and-function-composition-2c208d774983"><div class="mp ab dw"><div class="mq ab mr cl cj ms"><h2 class="hj b fi z dy mt ea eb mu ed ef hh bi translated">咖喱与功能组合</h2><div class="mv l"><h3 class="bd b fi z dy mt ea eb mu ed ef dx translated">注意:这是学习函数式编程和组合软件的“组合软件”系列的一部分…</h3></div><div class="mw l"><p class="bd b fp z dy mt ea eb mu ed ef dx translated">medium.com</p></div></div><div class="mx l"><div class="my l mz na nb mx nc ik mo"/></div></div></a></div><p id="275f" class="pw-post-body-paragraph is it hi iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hb bi translated">工厂功能:</p><div class="ml mm ez fb mn mo"><a rel="noopener follow" target="_blank" href="/javascript-scene/javascript-factory-functions-with-es6-4d224591a8b1"><div class="mp ab dw"><div class="mq ab mr cl cj ms"><h2 class="hj b fi z dy mt ea eb mu ed ef hh bi translated">ES6+的JavaScript工厂功能</h2><div class="mv l"><h3 class="bd b fi z dy mt ea eb mu ed ef dx translated">注:这是“作曲软件”系列的一部分(现在是一本书！)关于学习函数式编程和…</h3></div><div class="mw l"><p class="bd b fp z dy mt ea eb mu ed ef dx translated">medium.com</p></div></div><div class="mx l"><div class="my l mz na nb mx nc ik mo"/></div></div></a></div><p id="1367" class="pw-post-body-paragraph is it hi iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hb bi translated">应用程序的完整代码可以在这里找到:<a class="ae iq" href="https://github.com/jamesw201/partially-applied-factory-functions" rel="noopener ugc nofollow" target="_blank">https://github . com/jamesw 201/partially-applied-factory-functions</a></p><p id="3ef5" class="pw-post-body-paragraph is it hi iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp hb bi translated"><strong class="iu jq"> <em class="mc">詹姆士·威尔森</em> </strong> <em class="mc">是埃森哲云平台的程序员。</em></p></div></div>    
</body>
</html>