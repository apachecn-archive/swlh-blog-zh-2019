<html>
<head>
<title/>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1/>
<blockquote>原文：<a href="https://medium.com/swlh/a-dinamic-time-allocation-a1603e094341?source=collection_archive---------98-----------------------#2019-06-26">https://medium.com/swlh/a-dinamic-time-allocation-a1603e094341?source=collection_archive---------98-----------------------#2019-06-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/46b84b2926111e44dc26accbba797d39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8zrhSIH-qhp04auCukGeAQ.png"/></div></div></figure><p id="f3f5" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated"><strong class="hu iq">分配问题</strong>是一个众所周知的数学问题，有一些经过测试的实现。在这里，我将展示构建<strong class="hu iq">学校时间表</strong>的第一步，这并不容易。</p><p id="7ca6" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated">考虑到我们必须考虑的问题，每个<strong class="hu iq">时间表</strong>或时间表都是以不同的方式构建的。这就是为什么我们可以找到许多有用的实现。在这里，我可以向你展示一个关于什么是<strong class="hu iq">时间表</strong> ( <strong class="hu iq"> TT </strong>)的已知定义:</p><figure class="is it iu iv fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es ir"><img src="../Images/717d83e9410da288f43f4cdb16e3c066.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bjvSnWE1FAKbAxATnA2gzA.jpeg"/></div></div><figcaption class="iw ix et er es iy iz bd b be z dx">Header of the definition of the timetable problem by Even, Itai and Shamir in 1974 (On the complexity of Timetable and Multi-commodity Flow Problems)</figcaption></figure><h2 id="4d12" class="ja jb ht bd jc jd je jf jg jh ji jj jk id jl jm jn ih jo jp jq il jr js jt ju bi translated">创建时间表的步骤</h2><ol class=""><li id="7274" class="jv jw ht hu b hv jx hz jy id jz ih ka il kb ip kc kd ke kf bi translated">设定每门课程一周的课时数。</li><li id="c8ae" class="jv jw ht hu b hv kg hz kh id ki ih kj il kk ip kc kd ke kf bi translated">将一周的时间分配到课程的专门模块中。</li><li id="5b01" class="jv jw ht hu b hv kg hz kh id ki ih kj il kk ip kc kd ke kf bi translated">将每节课的课时设定为一周的课时。</li><li id="3125" class="jv jw ht hu b hv kg hz kh id ki ih kj il kk ip kc kd ke kf bi translated"><strong class="hu iq"> <em class="kl">分配</em> </strong>各班的供应时数和模块的需求时数。</li><li id="e3d0" class="jv jw ht hu b hv kg hz kh id ki ih kj il kk ip kc kd ke kf bi translated">设定每个老师一周的课时。</li><li id="5f1e" class="jv jw ht hu b hv kg hz kh id ki ih kj il kk ip kc kd ke kf bi translated"><strong class="hu iq"> <em class="kl">分配</em> </strong>每个教师的供给时数和模块的需求时数。</li><li id="a772" class="jv jw ht hu b hv kg hz kh id ki ih kj il kk ip kc kd ke kf bi translated">考虑到同一个模块或老师更喜欢在连续的几个小时内被分配，建立一个时间表。</li></ol><p id="25e3" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated">在这篇文章中，我将展示如何分配时间。</p><h1 id="1cf4" class="km jb ht bd jc kn ko kp jg kq kr ks jk kt ku kv jn kw kx ky jq kz la lb jt lc bi translated">履行</h1><p id="9398" class="pw-post-body-paragraph hr hs ht hu b hv jx hx hy hz jy ib ic id ld if ig ih le ij ik il lf in io ip hb bi translated">想要实现的是一个<strong class="hu iq">轻</strong> <a class="ae lg" href="https://en.wikipedia.org/wiki/Assignment_problem" rel="noopener ugc nofollow" target="_blank">分配问题的<em class="kl">快速解决方案</em>，</a>如果我们有一个供应清单和一个需求清单，考虑到有些分配在时间上不太可能得到很好的考虑，我们如何相互分配呢…</p><pre class="is it iu iv fd lh li lj lk aw ll bi"><span id="54a3" class="ja jb ht li b fi lm ln l lo lp">&gt;&gt;&gt; Allocation([2,4,6,7,8], [8, 3, 8, 8])<br/>Allocation: Rows Demands, Columns Supplies:<br/>   0  1  2  3  4<br/>0  2  4  2  0  0<br/>1  0  0  3  0  0<br/>2  0  0  1  7  0<br/>3  0  0  0  0  8</span></pre><p id="0733" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated">在上面的例子中:我们在构造函数中输入我们在列中提供多少小时和在行中需要多少小时<em class="kl"/>。</p><p id="bb78" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated">因此，我们希望用Python实现类分配，并增加一两个特性，考虑到这些数字就像小时(教师的工作小时数:供给，模块的小时数:需求)。</p><h2 id="6615" class="ja jb ht bd jc jd je jf jg jh ji jj jk id jl jm jn ih jo jp jq il jr js jt ju bi translated">构造器</h2><pre class="is it iu iv fd lh li lj lk aw ll bi"><span id="23f3" class="ja jb ht li b fi lm ln l lo lp">from pandas import DataFrame<br/>class Allocation:<br/>    def __init__(self, supplies, demands, *unlikely):<br/>        if not sum(supplies) == sum(demands):<br/>            raise Exception #supplies and demands must sum the same<br/>        self.T = Allocation.northWestMethod(supplies, demands)<br/>        self.anulled = [] #We set those pairs better to be zero<br/>        self.tryToNull(*unlikely)<br/>    def __repr__(self):<br/>        return "Allocation: Rows Demands, Columns Supplies:\n"\<br/>               +repr(self.T)<br/>    @staticmethod<br/>    def northWestMethod(supplies, demands):<br/>        'For each suply a demands are supplied '<br/>        S = supplies[:]<br/>        D = demands[:]<br/>        R = []<br/>        for x in range(len(demands)):<br/>            T = []<br/>            for y in range(len(supplies)):<br/>                T.append(min(S[y], D[x]))<br/>                D[x] -= T[-1]<br/>                S[y] -= T[-1]<br/>            R.append(T)<br/>        return DataFrame(R)</span></pre><p id="5662" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated">在上面的代码中:</p><ul class=""><li id="a667" class="jv jw ht hu b hv hw hz ia id lq ih lr il ls ip lt kd ke kf bi translated"><em class="kl"> tryToNull </em>是一个将在后面解释的方法，如果可能的话，它将尝试使坐标无效。</li><li id="b632" class="jv jw ht hu b hv kg hz kh id ki ih kj il kk ip lt kd ke kf bi translated">这个类不承认成本，所以最好的方法是找到最简单的解决方案:<em class="kl"> northwestmethod </em>找到最简单的分配。</li></ul><h2 id="2f7d" class="ja jb ht bd jc jd je jf jg jh ji jj jk id jl jm jn ih jo jp jq il jr js jt ju bi translated">tryToNull方法</h2><p id="07f2" class="pw-post-body-paragraph hr hs ht hu b hv jx hx hy hz jy ib ic id ld if ig ih le ij ik il lf in io ip hb bi translated">我们将使用这种方法来设置哪些线对太贵或者对我们的解决方案不感兴趣。考虑到<em class="kl">数据帧</em>如何工作，坐标为(<em class="kl">列</em>，<em class="kl">行</em> ) = ( <em class="kl">供应</em>，<em class="kl">需求</em>)</p><pre class="is it iu iv fd lh li lj lk aw ll bi"><span id="77a0" class="ja jb ht li b fi lm ln l lo lp">    def _annull(self, xO, xD, yO, yD):<br/>        d = min(self.T[xO][xD], self.T[yO][yD])<br/>        self.T[xO][xD] -= d<br/>        self.T[xO][yD] += d<br/>        self.T[yO][xD] += d<br/>        self.T[yO][yD] -= d<br/>    def annull(self, x, y, tolerate = True):<br/>        if not (x, y) in self.anulled:<br/>            if self.T[x][y] == 0:<br/>                self.anulled.append((x, y))<br/>                return<br/>            for i in self.T.columns:<br/>                if i == x:<br/>                    continue<br/>                for j in self.T.index:<br/>                    if j == y:<br/>                        continue<br/>                    if not (i, y) in self.anulled and \<br/>                         not (x, j) in self.anulled:<br/>                        self._annull(x, y, i, j)<br/>            if tolerate:<br/>                self.anulled.append((x, y))<br/>    def tryToNull(self, *unlikely):<br/>        '(supply1, demand1), (supply2, demand2), ... '<br/>        for x, y in unlikely:<br/>            self.annull(x, y, tolerate = True)</span></pre><ul class=""><li id="3c48" class="jv jw ht hu b hv hw hz ia id lq ih lr il ls ip lt kd ke kf bi translated"><em class="kl"> tryToNull </em>调用每一对的<em class="kl">annulus</em>方法设置，如果值不为空，在我们的对象中我们将注明“<em class="kl">我们做了它</em>”，添加到<em class="kl">未调用的</em>列表中。</li><li id="c7c8" class="jv jw ht hu b hv kg hz kh id ki ih kj il kk ip lt kd ke kf bi translated"><em class="kl">annulus</em>方法将评估一些其他的对来改变它们(如果它们不在<em class="kl">未被宣布的</em>列表中)以将该对转换为零。</li><li id="0c46" class="jv jw ht hu b hv kg hz kh id ki ih kj il kk ip lt kd ke kf bi translated">使操作成为可能的方法是<em class="kl">_取消</em>。</li><li id="7fb8" class="jv jw ht hu b hv kg hz kh id ki ih kj il kk ip lt kd ke kf bi translated">如果在<em class="kl">中取消</em>方法<em class="kl">容忍</em>为<em class="kl">假</em>，则该对将不会在<em class="kl">取消</em>列表中，因此在严格模式下它将指向不一致。</li></ul><p id="2967" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated">一个使用示例:</p><pre class="is it iu iv fd lh li lj lk aw ll bi"><span id="555c" class="ja jb ht li b fi lm ln l lo lp">&gt;&gt;&gt; Allocation([2,4,6,7,8], [8, 3, 8, 8], (2, 2), (2, 0))<br/>Allocation: Rows Demands, Columns Supplies:<br/>   0  1  2  3  4<br/>0  1  4  0  0  3<br/>1  0  0  3  0  0<br/>2  1  0  0  7  0<br/>3  0  0  3  0  5</span></pre><p id="a1e0" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated">正如您在上面看到的:在取消(第2列，第2行)和稍后(第2列，第0行)之后，它们以零结束，并且需求必须仍然是总和[8，3，8，8]和供应[2，4，6，7，8]。</p><h2 id="7cce" class="ja jb ht bd jc jd je jf jg jh ji jj jk id jl jm jn ih jo jp jq il jr js jt ju bi translated">我们更喜欢一个模块里只有一个老师</h2><p id="a2d8" class="pw-post-body-paragraph hr hs ht hu b hv jx hx hy hz jy ib ic id ld if ig ih le ij ik il lf in io ip hb bi translated">如果可能的话，这是一件有趣的事情。因此，下一个方法将声明消除多个提供者的坐标。</p><p id="4114" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated">在Pandas中，考虑到我们可以在服务器不独占时达到:</p><pre class="is it iu iv fd lh li lj lk aw ll bi"><span id="999d" class="ja jb ht li b fi lm ln l lo lp">def notUniqueServer(self):<br/>    return [(i, j) for i in self.T.columns[(self.T &gt; 0).sum() &gt; 1] \<br/>                for j in self.T[self.T[i] &gt; 0].index]</span></pre><p id="b101" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated">通过类比，我们可以用这种方法找到这些配对</p><pre class="is it iu iv fd lh li lj lk aw ll bi"><span id="6594" class="ja jb ht li b fi lm ln l lo lp">def notUniqueProvider(self):<br/>        T = self.T.transpose()<br/>        return [(j, i) for i in T.columns[(T &gt; 0).sum() &gt; 1] \<br/>                for j in T[T[i] &gt; 0].index]</span></pre><p id="8f92" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated">你可以这样测试它:</p><pre class="is it iu iv fd lh li lj lk aw ll bi"><span id="ca2f" class="ja jb ht li b fi lm ln l lo lp">&gt;&gt;&gt; A = Allocation([2,4,6,7,8], [8, 3, 8, 8], (2, 2), (2, 0))<br/>&gt;&gt;&gt; A<br/>Allocation: Rows Demands, Columns Supplies:<br/>   0  1  2  3  4<br/>0  1  4  0  0  3<br/>1  0  0  3  0  0<br/>2  1  0  0  7  0<br/>3  0  0  3  0  5<br/>&gt;&gt;&gt; A.notUniqueProvider()<br/>[(0, 0), (1, 0), (4, 0), (0, 2), (3, 2), (2, 3), (4, 3)]</span></pre><p id="ce67" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated">要使用它，我建议将此方法添加到类<em class="kl">allocate</em>ion:</p><pre class="is it iu iv fd lh li lj lk aw ll bi"><span id="dbed" class="ja jb ht li b fi lm ln l lo lp">def debug(self):<br/>        self.tryToNull(*self.notUniqueProvider())</span></pre><h2 id="b6ae" class="ja jb ht bd jc jd je jf jg jh ji jj jk id jl jm jn ih jo jp jq il jr js jt ju bi translated">我们倾向于考虑多种情况</h2><p id="c0e6" class="pw-post-body-paragraph hr hs ht hu b hv jx hx hy hz jy ib ic id ld if ig ih le ij ik il lf in io ip hb bi translated">也许有一个固定的解决方案并不那么有趣。换句话说，对于相同的规格，可以找到不同的分配时间的方法。很多时候，一项作业优于另一项作业的所有原因都没有被详细说明。</p><p id="7343" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated">这就是我实现这个函数的原因:</p><pre class="is it iu iv fd lh li lj lk aw ll bi"><span id="0b38" class="ja jb ht li b fi lm ln l lo lp">def case(supplies, demands, permutation = 0 ,<br/>         unlikely = [], oneProvider = False):<br/>    merge(supplies, permutation)<br/>    merge(demands, permutation)<br/>    I = Allocation(supplies, demands)<br/>    if oneProvider:<br/>        I.debug()<br/>    datas = I.T.to_dict()<br/>    merge(datas, -permutation)<br/>    for i in datas.keys():<br/>        merge(datas[i], -permutation)<br/>    I.T = DataFrame(datas)<br/>    I.tryToNull(*unlikely)<br/>    return I</span></pre><p id="0b0c" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated">这个函数使用了我之前介绍过的函数<em class="kl">合并</em>:</p><pre class="is it iu iv fd lh li lj lk aw ll bi"><span id="4c07" class="ja jb ht li b fi lm ln l lo lp">from math import ceil, sqrt<br/>def decodeMerge (N):<br/>    'Generates a pair of positions to be exchanged'<br/>    A=ceil((-1+sqrt(1+8*(N+1)))/2)<br/>    B=N-A*(A-1)//2<br/>    return (A, B)</span><span id="af96" class="ja jb ht li b fi lu ln l lo lp">def merge(L, P = 0):<br/>    'Mix the list L according to swap P'<br/>    N=len(L)<br/>    def swap(pos1, pos2):<br/>        X = L[pos1 % N]<br/>        L[pos1 % N] = L[pos2 % N]<br/>        L[pos2 % N] = X<br/>    toBin = [P for P, X in enumerate(bin(abs(P))[2:]) if X == '1']<br/>    if P&gt;=0:<br/>        toBin.reverse()<br/>    for X in toBin:<br/>        swap(*decodeMerge(X))</span></pre><p id="de37" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated"><em class="kl">合并</em>功能互换<em class="kl"> </em>列表的元素，在这种情况下我们合并<em class="kl">供应</em>和<em class="kl">需求</em>列表，保持结果中的顺序进行比较:</p><pre class="is it iu iv fd lh li lj lk aw ll bi"><span id="4c28" class="ja jb ht li b fi lm ln l lo lp">&gt;&gt;&gt; case([2,4,6,7,8], [8, 3, 8, 8], 0, oneProvider=True)<br/>Allocation: Rows Demands, Columns Supplies:<br/>   0  1  2  3  4<br/>0  0  0  0  7  1<br/>1  0  0  3  0  0<br/>2  2  4  0  0  2<br/>3  0  0  3  0  5<br/>&gt;&gt;&gt; case([2,4,6,7,8], [8, 3, 8, 8], 23420, oneProvider=True)<br/>Allocation: Rows Demands, Columns Supplies:<br/>   0  1  2  3  4<br/>0  0  0  0  5  3<br/>1  0  3  0  0  0<br/>2  0  0  6  2  0<br/>3  2  1  0  0  5</span></pre><p id="0083" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated">如你所见，结果并不完美；但是需求下的供给越多，分配能力就越大。</p><p id="ce6c" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated">你可以在这篇文章中测试其他类型的时间表和<em class="kl">合并</em>功能的使用:</p><div class="hh hi ez fb hj lv"><a rel="noopener follow" target="_blank" href="/@jumadaru/how-convenient-graeco-latin-squares-are-884bcfb9e1fb"><div class="lw ab dw"><div class="lx ab ly cl cj lz"><h2 class="ma b fi z dy mb ea eb mc ed ef md bi translated">希腊拉丁方是多么方便</h2><div class="me l"><h3 class="bd b fi z dy mb ea eb mc ed ef dx translated">从时间表创建到加密机制</h3></div><div class="mf l"><p class="bd b fp z dy mb ea eb mc ed ef dx translated">medium.com</p></div></div><div class="mg l"><div class="mh l mi mj mk mg ml hp lv"/></div></div></a></div></div></div>    
</body>
</html>