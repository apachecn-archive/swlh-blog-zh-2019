<html>
<head>
<title>Writing a simple transpiler in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用JavaScript编写一个简单的transpiler</h1>
<blockquote>原文：<a href="https://medium.com/swlh/writing-a-simple-transpiler-in-javascript-3c34ccb99e74#2019-05-21">https://medium.com/swlh/writing-a-simple-transpiler-in-javascript-3c34ccb99e74#2019-05-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="3ce5" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">JS的Lambda calculus，人人都渴望的transpiler。</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/dd015935303f3857653eac2716775c89.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Tb2BxR6CGMgH0xxlyCLW0A.jpeg"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Not pictured: a metaphor for my transpiler</figcaption></figure><p id="4001" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">我不知道为什么我决定写一个transpiler，但是我知道我期望它比实际要难得多。我也不知道为什么我决定学习lambda微积分，但是<em class="kj">和我预期的一样难。</em></p><p id="d66b" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">这篇文章是关于我如何写了一个非常基本的transpiler来尝试掌握lambda语法。你不需要了解lambda演算或编译——我将一步一步地介绍我是如何编写这个工具的，并根据需要解释lambdas的古怪之处。完整的源代码可以在<a class="ae kk" href="https://github.com/s-leigh/lambda-transpiler" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="e875" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">术语注释:“编译”指的是将某些东西翻译成另一种语言，不管这两种语言的“高级”程度如何。“翻译”指的是将一种语言翻译成与另一种语言大致相同的高级语言。我把我的编译器称为“transpiler ”,但是你可以说lambda语法实际上比JavaScript更高级。我将在本文中使用这两个术语。</p><h2 id="26a8" class="kl km hi bd kn ko kp kq kr ks kt ku kv jw kw kx ky ka kz la lb ke lc ld le lf bi translated">为什么会有人想这么做？</h2><p id="d824" class="pw-post-body-paragraph jn jo hi jp b jq lg ij js jt lh im jv jw li jy jz ka lj kc kd ke lk kg kh ki hb bi translated">我的理由是，这是一种学习不熟悉的语法的结构化方式——它没有自己的解释器或任何可以交互使用的东西，因为lambda演算与其说是一种编程模型，不如说是一种数学系统。其他原因可能包括为您自己的特定用例编写DSL，或者只是出于对您编写的文字如何转化为机器代码的兴趣。</p><h2 id="b185" class="kl km hi bd kn ko kp kq kr ks kt ku kv jw kw kx ky ka kz la lb ke lc ld le lf bi translated">幸运的是lambda语法的简要概述</h2><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/400ef3ea62759b3eeaa8193a1bffcfcf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Gr6pQTFzlG1-hrzfjAGQ7A.jpeg"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">This was taken in Greece, where the letter λ comes from</figcaption></figure><p id="1e04" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">这可能是它自己的整篇文章，但我会保持简短。Lambda syntax是天才数学家阿隆索·丘奇在20世纪30年代发明的，是一种表达可计算函数的方式。从这个意义上说，它有点像它自己的编程语言，除了它只有函数，没有别的。每个函数只能有一个参数。函数看起来像这样:</p><pre class="iy iz ja jb fd ll lm ln lo aw lp bi"><span id="49a4" class="kl km hi lm b fi lq lr l ls lt">λx.λy.y</span></pre><p id="43e4" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">lambda符号λ表示一个函数，点表示您将下一个东西应用于该函数。前面不带λ的字母是参数。JS这么写，λx.λy.y和<code class="du lu lv lw lm b">x =&gt; y =&gt; y</code>一样。因为每个函数只能有一个参数(用有趣的术语来说，函数的arity为1 ),所以你最终会大量使用currying。<code class="du lu lv lw lm b">(x =&gt; y =&gt; y)()(5)</code>给你5，在JavaScript和lambda calculus(反正连数字都没有)看来都是完全没用的函数，但我保证不是。</p><p id="48a5" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">有了这样的限制性规则，lambda语法实际上是编写编译器的最佳选择，因为需要担心的情况很少。</p><h2 id="1512" class="kl km hi bd kn ko kp kq kr ks kt ku kv jw kw kx ky ka kz la lb ke lc ld le lf bi translated">目标</h2><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/699ec30d17dda17dfee138ffe2c5cbed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mFlGt2YrDPhIPO2MYp4aHg.jpeg"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx"><code class="du lu lv lw lm b">T</code>rapped in mathematical abstractions</figcaption></figure><p id="601d" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">我想要一个采用lambda表达式并在JavaScript中返回等价内容的东西，例如从λx.λy.y到<code class="du lu lv lw lm b">x =&gt; y =&gt; y</code>。我到了那里，反正是为了基本的lambda表达式。我学到的东西:</p><ul class=""><li id="8c70" class="lx ly hi jp b jq jr jt ju jw lz ka ma ke mb ki mc md me mf bi translated">编写编译器是测试驱动开发的一个很好的用例。我本质上并不是一个TDD的人——我怀疑这只是一个东西，因为它很容易在会议上发表演讲——但是尽管我很愤世嫉俗，这是它的一个极好的用例。编译器设计应该严格遵守关注点分离，并且应该总是非常清楚每个单元的输出应该被赋予什么输入。遵循TDD原则使得整个体验更加简单。</li><li id="5da5" class="lx ly hi jp b jq mh jt mi jw mj ka mk ke ml ki mc md me mf bi translated">编写编译器是一次很好的学习经历，但你最终会达到收益递减。我本可以继续钻研并包装各种边缘案例、不同的lambda语法风格、更复杂的函数等等。但在某种程度上，这将是一个摆弄正则表达式和打乱逻辑而没有学到任何新东西的例子。我可能会继续搞砸，但我觉得我已经从这次经历中获得了最大的价值。</li></ul><h2 id="900e" class="kl km hi bd kn ko kp kq kr ks kt ku kv jw kw kx ky ka kz la lb ke lc ld le lf bi translated">编译器剖析</h2><p id="36d6" class="pw-post-body-paragraph jn jo hi jp b jq lg ij js jt lh im jv jw li jy jz ka lj kc kd ke lk kg kh ki hb bi translated">它们可以变得非常复杂，但是编译器都有三个基本部分:</p><ul class=""><li id="4989" class="lx ly hi jp b jq jr jt ju jw lz ka ma ke mb ki mc md me mf bi translated"><strong class="jp mg">词法分析器</strong> : <strong class="jp mg"> </strong>将一个表达式分解成块(“词法”或“标记”)。我们将一次传入一个完整的lambda表达式，但是为了对它进行推理，我们需要把它分成不同的词位，它们表示不同的东西。</li><li id="e902" class="lx ly hi jp b jq mh jt mi jw mj ka mk ke ml ki mc md me mf bi translated">解析器:将词位列表转换成逻辑操作树——抽象语法树，或AST。这听起来很复杂，但还不算太糟糕。AST是语言不可知的——它与源语言或目标语言无关。当你看到下面的一个时，这可能更有意义。</li><li id="0b0e" class="lx ly hi jp b jq mh jt mi jw mj ka mk ke ml ki mc md me mf bi translated"><strong class="jp mg">编译器/编译器</strong>:将AST转换成目标语言(JavaScript)。这是一个遵循AST逻辑树并根据每个节点之前和之后发生的事情解决如何将它转换成JS的例子。</li></ul><p id="65d0" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">编译器也可能描述他们的源语言的语法。这通常以一种叫做<a class="ae kk" href="https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_form" rel="noopener ugc nofollow" target="_blank"> EBNF </a>的格式编写，你可以在这里看到我的例子<a class="ae kk" href="https://github.com/s-leigh/lambda-transpiler/blob/master/src/model/grammar.ebnf" rel="noopener ugc nofollow" target="_blank">。我不是以编程的方式使用我的方法，但仍然发现这是一个有用的练习，因为我对如何最好地推理语法没有完全的信心。在编写lexer时，它也有助于确定如何分解给定的表达式。从我的例子中可以看出，lambdas的语法非常简单，但你可以想象对于适当的编程语言来说，它会有多复杂。</a></p><h2 id="ffa4" class="kl km hi bd kn ko kp kq kr ks kt ku kv jw kw kx ky ka kz la lb ke lc ld le lf bi translated">我们走吧</h2><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/6715e4d2ea200c0706468a1ec36fc67b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LjWEyiH_HQUT4BE_ly5BFA.jpeg"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Greece again</figcaption></figure><p id="b3e0" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">我将回顾一下我的第一遍，这是为了支持我能想到的最简单的测试用例:“身份函数”，λx.x，它应该翻译成<code class="du lu lv lw lm b">x =&gt; x</code>(一个只返回给定的任何内容的函数)。在这一点上，我懒得复制和粘贴λ字符，所以我使用了<code class="du lu lv lw lm b">l</code>来代替。</p><h2 id="e929" class="kl km hi bd kn ko kp kq kr ks kt ku kv jw kw kx ky ka kz la lb ke lc ld le lf bi translated">编写lexer</h2><p id="787d" class="pw-post-body-paragraph jn jo hi jp b jq lg ij js jt lh im jv jw li jy jz ka lj kc kd ke lk kg kh ki hb bi translated">这非常简单，因为我已经掌握了lambda语法的基础，而且语法非常简单。完整地看着我的lexer:</p><pre class="iy iz ja jb fd ll lm ln lo aw lp bi"><span id="eea3" class="kl km hi lm b fi lq lr l ls lt">(str) =&gt; str.split(/(?&lt;=\.)/);</span></pre><p id="61d5" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">不幸的是，没有摆脱正则表达式，所以我咬紧牙关，进入了地狱，这是积极和消极的前瞻性和前瞻性。它接受字符串并返回一个数组，该数组在<code class="du lu lv lw lm b">'.'</code>上拆分了字符串(但保留在前面的元素中)，所以我们的identity函数变成了<code class="du lu lv lw lm b">[’lx.’, 'x’]</code>。</p><p id="fa43" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">我反复思考应该如何分解这个表达式。<code class="du lu lv lw lm b">.</code>应该是它自己的词位吗？λ符号<code class="du lu lv lw lm b">l</code>是否应该？最终，它归结为可以解析的最简单的实现，这就是我们在这里看到的。</p><h2 id="e838" class="kl km hi bd kn ko kp kq kr ks kt ku kv jw kw kx ky ka kz la lb ke lc ld le lf bi translated">编写解析器</h2><p id="9971" class="pw-post-body-paragraph jn jo hi jp b jq lg ij js jt lh im jv jw li jy jz ka lj kc kd ke lk kg kh ki hb bi translated">这是最冗长的部分，部分原因是我想在解析器将一个词位识别为多种类型时抛出一个错误(这是不应该发生的)。</p><p id="4266" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">我们有lexer:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mm mn l"/></div></figure><p id="59dd" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">模型是:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mm mn l"/></div></figure><p id="97cc" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">为了分解和简化，步骤如下:</p><ol class=""><li id="b495" class="lx ly hi jp b jq jr jt ju jw lz ka ma ke mb ki mo md me mf bi translated">以第一个词位为例(在我们的例子中，<code class="du lu lv lw lm b">lx.</code>)</li><li id="63c6" class="lx ly hi jp b jq mh jt mi jw mj ka mk ke ml ki mo md me mf bi translated">如果它与lambda的正则表达式匹配，则将lambda解析器添加到我们的函数列表中，以便稍后执行</li><li id="5d27" class="lx ly hi jp b jq mh jt mi jw mj ka mk ke ml ki mo md me mf bi translated">如果它与绑定变量的正则表达式匹配，则将该解析器添加到列表中</li><li id="bca3" class="lx ly hi jp b jq mh jt mi jw mj ka mk ke ml ki mo md me mf bi translated">如果列表是空的或者有不止一个词，那么一定是出了问题，因为每个词位应该只匹配一种情况。抛出一个错误。</li><li id="2114" class="lx ly hi jp b jq mh jt mi jw mj ka mk ke ml ki mo md me mf bi translated">解析词位，返回一个新的实例<code class="du lu lv lw lm b">Lambda</code>或<code class="du lu lv lw lm b">BoundVariable</code>。对于新实例的<code class="du lu lv lw lm b">apply</code>字段，用下一个词位返回对<code class="du lu lv lw lm b">parse</code>的另一个调用的结果(如果这是数组中的最后一个词位，这将是<code class="du lu lv lw lm b">null</code>)。</li></ol><p id="4ac9" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">正如你将从步骤5中看到的，我们使用递归来建立一个操作树。最终结果将是我们的抽象语法树:</p><pre class="iy iz ja jb fd ll lm ln lo aw lp bi"><span id="a6fa" class="kl km hi lm b fi lq lr l ls lt">{<br/>    symbolType: 'lambda',<br/>    variable: 'x',<br/>    apply: {<br/>        symbolType: 'boundVariable',<br/>        variable: 'x',<br/>        apply: null<br/>    }<br/>}</span></pre><p id="b930" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">我们真的很幸运有lambdas，因为树永远只有一个分支——你只能将一个函数应用于一件事，另一个函数。这消除了大量的复杂性。因为identity函数只有两个元素(lambda和绑定变量),所以这棵树只有两层。当下一个<code class="du lu lv lw lm b">apply</code>场是<code class="du lu lv lw lm b">null</code>时，我们知道我们已经到达终点。</p><p id="8540" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">现在我们需要把AST转换成JavaScript。</p><h2 id="fb92" class="kl km hi bd kn ko kp kq kr ks kt ku kv jw kw kx ky ka kz la lb ke lc ld le lf bi translated">编写transpiler</h2><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mp"><img src="../Images/253f280103203e1e441ecc81efebfd75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PPKPrdD0Ju1M2DOWkv0oqw.jpeg"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Trapped in recursion</figcaption></figure><p id="e232" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">transpiler将遍历AST并构建一个JS表达式:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mm mn l"/></div></figure><p id="372f" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">所以它沿着AST向下(再次递归)，如果它看到一个lambda，它输出一个带有关联变量+ <code class="du lu lv lw lm b">=&gt;</code>的字符串，如果它看到一个绑定变量，它添加括号。这些字符串表达式都加在一起，当它接收到一个<code class="du lu lv lw lm b">null</code>的<code class="du lu lv lw lm b">apply</code>节点时，它返回一个内置表达式的<code class="du lu lv lw lm b">eval()</code>。最终的结果是<code class="du lu lv lw lm b">x =&gt; (x)</code>，就是身份函数！</p><h2 id="afc9" class="kl km hi bd kn ko kp kq kr ks kt ku kv jw kw kx ky ka kz la lb ke lc ld le lf bi translated">后续步骤</h2><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/daf894a2a54f567d6bee550be3561a3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1_sTs6PoLAcza9Bplstr2w.jpeg"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">I am become master of compilation</figcaption></figure><p id="c12b" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">正如您从<a class="ae kk" href="https://github.com/s-leigh/lambda-transpiler" rel="noopener ugc nofollow" target="_blank">完整源代码</a>中看到的，随着我添加更多用例，事情变得稍微复杂了一些。我放入了一个包装器/控制器，这样就可以用命令行参数调用该工具并输出一个字符串化的结果，这意味着我还可以添加端到端的测试。transpiler还可以处理应用于函数的未绑定变量，因此<code class="du lu lv lw lm b">lx.x 6</code>将返回6，但这当然意味着在lexer和解析器中添加对未绑定变量和空格的支持。随着我添加更多的测试用例，我最注意到的事情是，由于编译器结构中关注点的分离，失败的往往只是一两个模块——与抽象语法之间的转换解耦了翻译逻辑，这就是为什么您首先要这样做。</p><p id="b6f8" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">我建议任何人都尝试创建一个编译器。正如我满怀希望地展示的那样，至少为琐碎的用例创建一个并不困难。这是学习像我这样的晦涩语法的一个很好的方法，或者只是如果你有兴趣研究语言是如何翻译的。也许我天生对深奥的东西更感兴趣，但我实际上很享受这个过程，所以如果你做过类似的事情，请告诉我！</p></div></div>    
</body>
</html>