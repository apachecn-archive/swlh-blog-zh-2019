<html>
<head>
<title>Comparison of Microservice Frameworks with a Streaming Example</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">微服务框架与流示例的比较</h1>
<blockquote>原文：<a href="https://medium.com/swlh/comparison-of-microservice-frameworks-with-a-streaming-example-6bfe284a66a?source=collection_archive---------9-----------------------#2019-07-08">https://medium.com/swlh/comparison-of-microservice-frameworks-with-a-streaming-example-6bfe284a66a?source=collection_archive---------9-----------------------#2019-07-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/42f1ff8d4c59d89878e94e810e809d6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1120/format:webp/1*WONY-oXpx7JsREI9oJmOVg.png"/></div></figure><p id="f127" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在我的<a class="ae jk" rel="noopener" href="/@aengel/how-to-reactive-stream-with-spring-boot-and-rxjava-26cda0045f4c">上一篇文章</a>中，我展示了一些用RxJava进行反应式编程的有趣应用，以及何时/为什么应该使用它。</p><p id="4f11" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这些服务可以根据负载增加或减少。如果一个服务负载很重，负载平衡器现在可以简单地启动其他服务，重定向负载，从而减轻一个服务的负载，并再次减少响应时间。如果服务负载很小，可以停止它们，从而为其他服务释放性能，或者在使用云服务的情况下节省成本。</p><p id="b471" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">服务很少没有负载峰值，如果其他单元的启动和停止很快，并且这些新启动的实例对请求反应很快，以便保持所有请求的响应时间很低，这将是有利的。</p><p id="3003" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">因此，在本文中，我将考察各种微服务框架，并在启动时间、首次响应时间和负载下的响应时间方面对它们进行比较。此外，我将简要讨论框架入门的简单性。</p><p id="ffa0" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在第一步中，我将处理以下框架/服务器(<em class="jl"> Micronaut </em>、<em class="jl"> Wildfly </em>、<em class="jl"> Dropwizard </em>和<em class="jl"> Spark </em>将适时跟进):</p><ul class=""><li id="0b7d" class="jm jn hi io b ip iq it iu ix jo jb jp jf jq jj jr js jt ju bi translated"><em class="jl"> Spring Boot </em></li><li id="bf0d" class="jm jn hi io b ip jv it jw ix jx jb jy jf jz jj jr js jt ju bi translated"><em class="jl">垂直x轴</em></li><li id="7952" class="jm jn hi io b ip jv it jw ix jx jb jy jf jz jj jr js jt ju bi translated"><em class="jl">海利登</em></li><li id="f2f7" class="jm jn hi io b ip jv it jw ix jx jb jy jf jz jj jr js jt ju bi translated"><em class="jl">夸尔库斯</em></li></ul><p id="35a6" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我从<em class="jl"> Spring Boot </em>开始，因为我已经在我的第一篇文章中使用了它，并在产品中开发了它。</p><p id="1262" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">以下帖子基于之前关于<em class="jl">与Spring Boot </em>反应流的帖子。在这里，我已经创建了一个stream REST端点，并开发了一个小型前端用于演示。以下后端的代码将在同一个<a class="ae jk" href="https://github.com/auryn31/spring-async-rest-example" rel="noopener ugc nofollow" target="_blank"> GitHub-Repo </a>中提供。</p><p id="6950" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">令人兴奋的是，<em class="jl"> Spring Boot </em>已经默认为<code class="du ka kb kc kd b">application/stream+json</code>。但是，这不是<em class="jl">哑剧</em>类型。对我来说，这是不清楚的，因为格式似乎是有意义的。</p><p id="ac13" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">由于<em class="jl"> Quarkus </em>和<em class="jl"> Helidon </em>使用JAX-RS(它使用<em class="jl"> MIME </em>标准)，要么必须定义类型本身，要么必须使用<code class="du ka kb kc kd b">application/octet-stream</code>。</p><p id="1806" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">为了不用改变前端，我同时使用了<code class="du ka kb kc kd b">application/octet-stream</code>和<code class="du ka kb kc kd b">application/stream+json</code>。各个端点可通过标头访问。没有标题的<code class="du ka kb kc kd b">application/json</code>被返回。</p></div><div class="ab cl ke kf gp kg" role="separator"><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj"/></div><div class="hb hc hd he hf"><h1 id="c87f" class="kl km hi bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">进入</h1><p id="16dc" class="pw-post-body-paragraph im in hi io b ip lj ir is it lk iv iw ix ll iz ja jb lm jd je jf ln jh ji jj hb bi translated">在下一节中，我将简要地看一下框架。我自己以前只在产品中使用过<em class="jl"> Spring Boot </em>，所以其他框架对我来说也是新的领域。我将简要解释我在框架中创建相应端点时遇到的困难。</p></div><div class="ab cl ke kf gp kg" role="separator"><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj"/></div><div class="hb hc hd he hf"><h2 id="464c" class="lo km hi bd kn lp lq lr kr ls lt lu kv ix lv lw kz jb lx ly ld jf lz ma lh mb bi translated">Spring Boot</h2><p id="2a21" class="pw-post-body-paragraph im in hi io b ip lj ir is it lk iv iw ix ll iz ja jb lm jd je jf ln jh ji jj hb bi translated">Spring Boot 可能是最著名的框架。Github上的<em class="jl"> &gt; 38.000 </em>明星自己说了算。</p><p id="3a1e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">Spring Boot 的入门非常简单。这里创建了一个<strong class="io mc"> pom.xml </strong>和所有必要的依赖项，您可以立即开始。此外，社区非常大，您可以找到如何处理大多数问题的说明。</p><p id="4897" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">Spring Boot是唯一默认支持T0的框架。它还提供了许多其他功能，并为清晰和简单的开发提供了很多帮助。</p><p id="05b3" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">因为我自己经常使用Spring Boot，所以创建合适的端点对我来说很容易。正如您在下面看到的，创建一个<em class="jl">响应流</em>并不需要太多时间:</p><figure class="md me mf mg fd ij"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="11d7" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">然而，对于流响应，需要一个<em class="jl">流响应体</em>:</p><figure class="md me mf mg fd ij"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="f1d0" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">基本上就是这样。所以就到了下一个框架。</p></div><div class="ab cl ke kf gp kg" role="separator"><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj"/></div><div class="hb hc hd he hf"><h2 id="3056" class="lo km hi bd kn lp lq lr kr ls lt lu kv ix lv lw kz jb lx ly ld jf lz ma lh mb bi translated">垂直x</h2><p id="a750" class="pw-post-body-paragraph im in hi io b ip lj ir is it lk iv iw ix ll iz ja jb lm jd je jf ln jh ji jj hb bi translated">Vert.x有很好的文档。它是由Eclipse Foundation开发的，是直接为JVM上的反应式应用程序设计的。然而，我不能仅仅将我的可观察对象(或可流动对象)传递给响应处理程序。理论上，你可以像文档中描述的那样直接返回一个可流动的对象，但是可流动的对象不会在每个新的事件中直接写入流中。它似乎缓冲了可流动流中的元素，并且仅当事件<em class="jl"> done </em>来自可流动流时才写入流。但是要获得一个连续的流，你必须编写自己的处理程序，这并不复杂。这与Spring Boot的非常相似。</p><figure class="md me mf mg fd ij"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="d811" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">此外，<em class="jl"> Vert.x </em>的文档也很好，拥有超过<em class="jl"> 9700 </em> GitHub Stars的社区也在不断增长。</p><p id="394a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">应用程序由<code class="du ka kb kc kd b">./mvnw clean compile</code>编译，由<code class="du ka kb kc kd b">./mvnw exec:java</code>启动。这些命令也可以很容易地组合起来。(<code class="du ka kb kc kd b">./mvnw clean compile exec:java</code>)</p><p id="4a71" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">总而言之，你会发现自己在<em class="jl"> Vert.x </em>中，并且可以开始快速发展。但是你得习惯在一个主线程上开发，因为你不能阻塞它。在开始的时候，我错误地使用了<em class="jl"> Thread.sleep </em>，因此性能非常有限。但这在网站上也被描述为<em class="jl"> DONT </em>。修复这个问题后，<em class="jl"> Vert.x </em>可以通过性能再次得分。其他框架与它相处融洽，尽管如此，它也被从它们中去掉了，因为它是应用程序的<em class="jl">域</em>部分，所有框架都共享它。</p></div><div class="ab cl ke kf gp kg" role="separator"><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj"/></div><div class="hb hc hd he hf"><h2 id="0b30" class="lo km hi bd kn lp lq lr kr ls lt lu kv ix lv lw kz jb lx ly ld jf lz ma lh mb bi translated">赫利登</h2><p id="56c8" class="pw-post-body-paragraph im in hi io b ip lj ir is it lk iv iw ix ll iz ja jb lm jd je jf ln jh ji jj hb bi translated"><em class="jl"> Helidon </em>像<em class="jl"> Quarkus </em>一样设定为JAX-RS标准。所以我可以使用与Quarkus相同的代码。你只需要注册一件T21球衣就可以出发了。关于<em class="jl"> Helidon </em>的积极的一面是，它不需要终端中任何自己的命令来启动。这里的IDE支持非常简单和令人愉快，因为所有必需的依赖项都来自于pom。所以可以用一个简单的<code class="du ka kb kc kd b">mvn clean install</code>来完成构建，而构建好的<em class="jl">罐子</em>可以用<code class="du ka kb kc kd b">java -jar</code>来完成。不得不说，<code class="du ka kb kc kd b">mvn clean install</code>也足够其他所有框架构建一个可执行的<code class="du ka kb kc kd b">jar</code>。<em class="jl"> Vert.x </em>和<em class="jl"> Quarkus </em>只会带来更多的脚本，需要额外的一个类从IDE启动。这个额外的类不是由<em class="jl">默认</em>提供的。</p><figure class="md me mf mg fd ij"><div class="bz dy l di"><div class="mh mi l"/></div></figure></div><div class="ab cl ke kf gp kg" role="separator"><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj"/></div><div class="hb hc hd he hf"><h2 id="ea96" class="lo km hi bd kn lp lq lr kr ls lt lu kv ix lv lw kz jb lx ly ld jf lz ma lh mb bi translated">夸库斯</h2><p id="ef95" class="pw-post-body-paragraph im in hi io b ip lj ir is it lk iv iw ix ll iz ja jb lm jd je jf ln jh ji jj hb bi translated">Quarkus仍然是一个非常年轻的框架，它已经在社区中获得了很多关注。它目前在GitHub上有将近2000颗星星。它是由红帽公司开发的。它本身可以为GraalVM编译，但也可以为经典JVM编译。但是在这里，它并没有显示出它的优势，因为它消耗的内存很少，启动时间非常快。虽然，我们稍后会看到，它仍然在JVM上不到一秒钟就启动了。它使用各种标准，包括JAX-RS Netty和Eclipse MicroProfiles。</p><p id="4e1b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><em class="jl"> Quarkus </em>在标志上写自己一个非常快速的开始，因此缩放和低内存消耗。此外，制造商还依赖反应式方法来开发高度并发和响应迅速的应用程序。关于这一点，JavaSpektrum (7/2019)中有一篇更详细的文章，其中对<em class="jl">夸尔库斯</em>进行了更精确的检查。其中，它显示JVM上的应用程序消耗了<em class="jl"> 100mb </em> RAM，而在GraalVM上它只需要<em class="jl"> 8mb </em>。</p><p id="eee3" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">夸尔库斯的文档非常详细，易于阅读。不幸的是，到目前为止只有一些教程和解释，因为社区还没有这么大，框架使用的时间还不够长。如果出现问题，你必须搜索很长时间，或者向社区提出你自己的问题。但是仅仅因为<em class="jl">夸尔库斯</em>来自<strong class="io mc">红帽</strong>这个事实，这个社区很快就会到来。</p><p id="319d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这样做的好处是，你可以用现有的<em class="jl"> Java </em>或<em class="jl"> Kotlin </em>知识开发一个快速而精简的应用程序。</p><figure class="md me mf mg fd ij"><div class="bz dy l di"><div class="mh mi l"/></div></figure></div><div class="ab cl ke kf gp kg" role="separator"><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj"/></div><div class="hb hc hd he hf"><h1 id="a0c0" class="kl km hi bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">结果</h1><p id="4d71" class="pw-post-body-paragraph im in hi io b ip lj ir is it lk iv iw ix ll iz ja jb lm jd je jf ln jh ji jj hb bi translated">在下一节中，我将比较和评估不同的框架。</p><h2 id="803b" class="lo km hi bd kn lp lq lr kr ls lt lu kv ix lv lw kz jb lx ly ld jf lz ma lh mb bi translated">发展</h2><p id="15a3" class="pw-post-body-paragraph im in hi io b ip lj ir is it lk iv iw ix ll iz ja jb lm jd je jf ln jh ji jj hb bi translated"><em class="jl"> Spring Boot </em>、<em class="jl">夸尔库斯</em>和<em class="jl">海利登</em>使用几乎相同的<code class="du ka kb kc kd b">ResponseWriter</code>、<em class="jl">垂直x </em>使用一个搬运器。在<em class="jl">赫里登</em>和<em class="jl">夸尔库斯</em>你可以依靠经典的JAX-遥感方法。由于Java的发展，这里有很多文档。然而，对于<em class="jl"> Vert.x </em>,有一个很好的自己的文档。总而言之，在Spring Boot发展对我来说是最容易的。这部分是因为体验，部分是因为目前最大的社区。然而，正如我们将从数字中看到的那样，不能否认其他框架的优势。</p><h2 id="3207" class="lo km hi bd kn lp lq lr kr ls lt lu kv ix lv lw kz jb lx ly ld jf lz ma lh mb bi translated">不同后端的测试</h2><p id="04ca" class="pw-post-body-paragraph im in hi io b ip lj ir is it lk iv iw ix ll iz ja jb lm jd je jf ln jh ji jj hb bi translated">第一步，启动JVM <em class="jl"> (java版本“11 . 0 . 2”)</em>上的所有后端。然后用<code class="du ka kb kc kd b">curl</code>对相应的端点进行寻址。首次响应时间由一个格式文件决定(位于我的GitHub repo中)。</p><figure class="md me mf mg fd ij"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="2e2c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><em class="jl">平均</em>和<em class="jl">中值</em>响应时间由<code class="du ka kb kc kd b">k6</code>决定。这里10个模拟用户对<em class="jl"> 30s </em>的请求被发送到点。结果可以在下表中找到。</p><figure class="md me mf mg fd ij er es paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="er es mj"><img src="../Images/4fe55ffe187c7f2d6c34d8b7355c3203.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YQtLn1MqpxcSeO7y6JG0jw.png"/></div></div></figure><p id="3eb5" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">四个框架的开始时间如下图所示。这里你可以看到<em class="jl"> Spring Boot </em>明显被其他框架打败了。</p><figure class="md me mf mg fd ij er es paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="er es mo"><img src="../Images/573edd9011a2cc50b3fab584c2f7e33f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5Vf4Catvhx0svM4IVcsqZg.jpeg"/></div></div></figure><p id="5dc9" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">慢启动时间的唯一优点是加载了更多的依赖项，并且对查询的第一次响应更快。这点可以从下面看出来。</p><figure class="md me mf mg fd ij er es paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="er es mo"><img src="../Images/c953e765434c91e65b88ff4378dc703b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZVcWez-jI7DduphICUnUjA.jpeg"/></div></div></figure><p id="4a7a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在下面的两张图片中，每秒钟显示一次响应。<em class="jl">小</em>为无延迟数据，<em class="jl">大</em>为延迟<em class="jl"> 100ms </em>的数据。从这里可以看出，不同的框架在延迟方面相对相似，其中<em class="jl"> Spring Boot </em>大约慢了20%。然而，如果响应快且小，则差异更大。这里<em class="jl">垂直x </em>比<em class="jl">夸尔库斯</em>几乎慢了50%。</p><div class="md me mf mg fd ab cb"><figure class="mp ij mq mr ms mt mu paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><img src="../Images/2e23508db22d7a99179bfbc6249d6f1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*PydRmHc1KwSvyhENopvxvw.jpeg"/></div></figure><figure class="mp ij mq mr ms mt mu paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><img src="../Images/062caa1c2272aca96fa83f1f751fe0d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*L-fKzCMduH6coSFUgleGuw.jpeg"/></div></figure></div><h2 id="37fd" class="lo km hi bd kn lp lq lr kr ls lt lu kv ix lv lw kz jb lx ly ld jf lz ma lh mb bi translated">使用wrk进行负载测试</h2><p id="93cf" class="pw-post-body-paragraph im in hi io b ip lj ir is it lk iv iw ix ll iz ja jb lm jd je jf ln jh ji jj hb bi translated">我用<a class="ae jk" href="https://github.com/wg/wrk" rel="noopener ugc nofollow" target="_blank"> wrk </a>重复了测试。该工具在<em class="jl"> http </em>负载测试中非常流行。测试如上所述在流端点上进行。</p><figure class="md me mf mg fd ij"><div class="bz dy l di"><div class="mh mi l"/></div></figure><figure class="md me mf mg fd ij er es paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="er es mv"><img src="../Images/cec8612afb6edfac4b16109b560a5df1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EfWpU8aZ5VZjiYEbcckaLw.png"/></div></div></figure><p id="e629" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">从表中可以看出，快速回答的结果与使用<em class="jl"> k6 </em>的结果相似。只有Quarkus能够在<em class="jl"> wrk </em>处理几乎两倍的请求。有了慢速数据，Quarkus可以再次给出大多数答案，但也给出了大多数<em class="jl"> 5xx </em>答案。这里只使用了<em class="jl"> 2xx </em>的答案。在那里<em class="jl">垂直x </em>可以比其他的更明显。这在下图中也可以很好地看出:</p><figure class="md me mf mg fd ij er es paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="er es mo"><img src="../Images/560f682ea363f79910a9799c316f4851.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L2SF-U15LN_0FB5PexmXSQ.jpeg"/></div></div></figure><p id="e23c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果<em class="jl"> Vert.x </em>作为单个实例启动，它不能快速响应处理这么多请求。但是由于<em class="jl"> Vert.x </em>打算用多个实例启动，我用8个实例再次测试了它。它能够回答几乎和夸库斯一样多的问题。</p><figure class="md me mf mg fd ij er es paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="er es mo"><img src="../Images/6c8058dfe8e7af3c74e7a56d62b1d848.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*upOVxFzpKFr3IReYfTqgRg.jpeg"/></div></div></figure></div><div class="ab cl ke kf gp kg" role="separator"><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj"/></div><div class="hb hc hd he hf"><h1 id="21b8" class="kl km hi bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">结论</h1><p id="93de" class="pw-post-body-paragraph im in hi io b ip lj ir is it lk iv iw ix ll iz ja jb lm jd je jf ln jh ji jj hb bi translated">不同的工具，不同的结果。在负荷下，两种工具的快速答案是相似的，而慢速答案则大相径庭。在第一次回应中，<em class="jl"> Spring Boot </em>遥遥领先，但是它失去了很多出发时间。在开始的时候，没有一个框架能打败<em class="jl"> Vert.x </em>。<em class="jl"> Vert.x </em>也可以在<em class="jl"> wrk </em>上展示它能够做什么。在这里，它可以并行处理比Spring Boot多100倍的答案。尽管只有一例。对于一个简单的答案，Spring 可以击败Vert-x的简单实例，但是如果你启动多个Vert.x 的实例，情况就不同了。</p><p id="fbe8" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">总而言之，<em class="jl"> Vert.x </em>是图中最有说服力的。它比<em class="jl">夸尔库斯</em>更稳定，比<em class="jl">赫利登</em>和<em class="jl"> Spring Boot </em>更快，并且有非常好的文档。使用Quarkus时，我经常进入无效状态，不得不重启它。这可以通过更好的错误处理来避免。如果是关于文档数量、网络帮助和开发者，你可能应该选择<em class="jl"> Spring Boot </em>。如果你想快速启动和停止服务，投资和使用像<em class="jl"> Quarkus </em>或<em class="jl"> Vert.x. </em>这样的新服务是值得的，这在使用微服务架构时尤其令人兴奋。</p><p id="ae1f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">就我个人而言，我会尝试在下一个项目中使用<em class="jl"> Vert.x </em>，并在未来专注于此。尤其是结合<em class="jl"> Kotlin </em>一个很刺激的话题。</p><p id="b6b0" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">完整的代码可以在我的<a class="ae jk" href="https://github.com/auryn31/spring-async-rest-example" rel="noopener ugc nofollow" target="_blank"> GitHub-Repo </a>上找到。</p></div></div>    
</body>
</html>