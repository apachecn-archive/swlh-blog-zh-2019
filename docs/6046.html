<html>
<head>
<title>Quadratic Assignment Problem, Solved?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">二次分配问题，解决了？</h1>
<blockquote>原文：<a href="https://medium.com/swlh/quadratic-assignment-problem-solved-247338a6aa40#2019-06-17">https://medium.com/swlh/quadratic-assignment-problem-solved-247338a6aa40#2019-06-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/9117e7441338811ead83da8171c07605.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C47vIxUMPGOnf6ee_2-S-g.png"/></div></div></figure><div class=""/><div class=""><h2 id="295b" class="pw-subtitle-paragraph iq hs ht bd b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh dx translated">在这里，我提出了一个新的结构，基于我确保我解决布尔可满足性的方式，这是专门为QAP设计的</h2></div><p id="8ffb" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">二次分配问题是一个有多种用途的问题。从决定在哪里安装机器、大型装置…，甚至帮助在百货商店摆放产品以鼓励消费。</p><p id="7f04" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">在研究了矩阵计算并观察了我如何解释布尔可满足性之后，在相应的<a class="ae ke" rel="noopener" href="/swlh/the-boolean-satisfiability-problem-solved-48ceb5550115?source=your_stories_page---------------------------">文章</a> …</p><div class="hh hi ez fb hj kf"><a rel="noopener follow" target="_blank" href="/swlh/the-boolean-satisfiability-problem-solved-48ceb5550115"><div class="kg ab dw"><div class="kh ab ki cl cj kj"><h2 class="hu b fi z dy kk ea eb kl ed ef hs bi translated">布尔可满足性问题，解决了吗？</h2><div class="km l"><h3 class="bd b fi z dy kk ea eb kl ed ef dx translated">在这里，我展示了一些终极技术来制作逻辑运算的强大工具。</h3></div><div class="kn l"><p class="bd b fp z dy kk ea eb kl ed ef dx translated">medium.com</p></div></div><div class="ko l"><div class="kp l kq kr ks ko kt hp kf"/></div></div></a></div><p id="5818" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">我可以向你保证，有一个简单的结构，大大简化了问题。</p><h1 id="8686" class="ku kv ht bd kw kx ky kz la lb lc ld le iz lf ja lg jc lh jd li jf lj jg lk ll bi translated">QAP定义</h1><p id="367e" class="pw-post-body-paragraph ji jj ht jk b jl lm iu jn jo ln ix jq jr lo jt ju jv lp jx jy jz lq kb kc kd hb bi translated">有一套<em class="lr"> n </em>设施和一套<em class="lr"> n </em>地点。对于每对位置，指定一个<em class="lr">距离</em>，对于每对设施，指定一个<em class="lr">重量</em>或<em class="lr">流量</em>(例如，在两个设施之间运输的物资数量)。问题是将所有设施分配到不同的位置，目标是最小化距离乘以相应流量的总和。</p><p id="e6af" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">这个问题最初是由律师[2]定义的，但我们可以从Koopmans和Beckmann的不同方式中找到一个替代定义:即考虑在任何位置安装设施的成本以及设施之间所需的所有移动的成本乘以距离。</p><figure class="lt lu lv lw fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es ls"><img src="../Images/eecec7d559d8e647d02bb53ac0f9beb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rCfCZJxl8VLYvYScCQIHEA.jpeg"/></div></div><figcaption class="lx ly et er es lz ma bd b be z dx">Koopmans-Beckmann model, being π(·) a permutation</figcaption></figure><p id="0d74" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">我们可以想象:在N个地点放置N个设施，这些设施以不同的方式相互交流，例如需要或多或少地靠得更近。</p><figure class="lt lu lv lw fd hk er es paragraph-image"><div class="er es mb"><img src="../Images/13285359b8abaad98594d9a95be7daeb.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*ocM536BMnWChzdeOkz9o4w.jpeg"/></div><figcaption class="lx ly et er es lz ma bd b be z dx">For each site where each industry is installed, there will be a particular cost, which must be added to the costs of the flows multiplied by the distance.</figcaption></figure><h2 id="d859" class="mc kv ht bd kw md me mf la mg mh mi le jr mj mk lg jv ml mm li jz mn mo lk mp bi translated">一些麻烦</h2><p id="31c8" class="pw-post-body-paragraph ji jj ht jk b jl lm iu jn jo ln ix jq jr lo jt ju jv lp jx jy jz lq kb kc kd hb bi translated">1976年，Sahni和Gonzalez [1]从<a class="ae ke" href="https://en.wikipedia.org/wiki/Hamiltonian_circuit" rel="noopener ugc nofollow" target="_blank">哈密顿回路</a>对这个问题进行了转化。因此，这被认为是一个棘手的问题。在这篇文章中，我将向你提出一个快速实现，你可以在文章的最后找到代码。</p><h1 id="c52a" class="ku kv ht bd kw kx ky kz la lb lc ld le iz lf ja lg jc lh jd li jf lj jg lk ll bi translated">我的提议</h1><p id="e70a" class="pw-post-body-paragraph ji jj ht jk b jl lm iu jn jo ln ix jq jr lo jt ju jv lp jx jy jz lq kb kc kd hb bi translated">我们只需要联系三个共享某个维度的矩阵:行业x行业，行业x站点，站点x站点。因此，在三角形表中，我们需要添加三个额外的矩阵来保持一致性，如下图所示:</p><figure class="lt lu lv lw fd hk er es paragraph-image"><div class="er es mq"><img src="../Images/3316a550d7876071043994d4475392b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:806/format:webp/1*hB25UWDdFplJk3zoeN_FbQ.jpeg"/></div><figcaption class="lx ly et er es lz ma bd b be z dx">A: Assingments, D: Distances, F: Flows x Movements</figcaption></figure><p id="8005" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">这使得我们使用6个n阶方阵。我们的三角表只能包含布尔值，因此优化系统应该考虑有序消除较高的成本。</p><p id="d061" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">证明算法真的给了我们最好的解决方案并不容易，所以这里我只展示和解释代码。</p><h1 id="2736" class="ku kv ht bd kw kx ky kz la lb lc ld le iz lf ja lg jc lh jd li jf lj jg lk ll bi translated">实施</h1><p id="bf7f" class="pw-post-body-paragraph ji jj ht jk b jl lm iu jn jo ln ix jq jr lo jt ju jv lp jx jy jz lq kb kc kd hb bi translated">考虑到上图，以及我上一篇文章中的<em class="lr"> sharp </em>方法是如何工作的(求解<strong class="jk mr">布尔可满足性</strong>，你可以很容易地理解构造函数:</p><pre class="lt lu lv lw fd ms mt mu mv aw mw bi"><span id="a38c" class="mc kv ht mt b fi mx my l mz na">import numpy as np<br/>class QAP:<br/>    def __init__(self, assignments, distances,<br/>                 flows, threshold = None):<br/>        self.A = np.matrix(assignments)<br/>        self.D = np.matrix(distances)<br/>        self.F = np.matrix(flows)</span><span id="4b3d" class="mc kv ht mt b fi nb my l mz na">        self.T = [[None, None, None], [None, None], [None]]<br/>        self.L = self.costs()<br/>        self.MAX = (self.L[0][0] + 1) if threshold is None \<br/>                   else threshold<br/>        self.establishThreshold(self.MAX)</span><span id="6a48" class="mc kv ht mt b fi nb my l mz na">    def costs(self):<br/>        L = []<br/>        N = self.A.shape[0]<br/>        for i in range(1, N):<br/>            for j in range(i):<br/>                for k in range(1, N):<br/>                    for l in range(k):<br/>                        L.append((self.D[i, j] * self.F[k,l],<br/>                                  (i, j , k, l)))<br/>        for i in range(N):<br/>            for j in range(N):<br/>                L.append((self.A[i, j], (i, j)))<br/>        L.sort(reverse = True)<br/>        return L<br/>                                 <br/>    def establishThreshold(self, th):<br/>        self.T[0][0] = self.A &lt; th<br/>        self.T[0][2] = self.D &lt; th<br/>        self.T[2][0] = self.F &lt; th<br/>        self.T[0][1] = self.T[0][0] * self.T[2][0].transpose()<br/>        self.T[1][0] = self.T[0][2].transpose()*self.T[0][0]<br/>        self.T[1][1] = self.T[0][2].transpose()*self.T[0][1]<br/>        self.sharp()</span></pre><p id="5ad7" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">虽然在这篇文章中，我没有使用<em class="lr">阈值</em>，但它被排除在外，以防任何想要优化代码并改善其用途的人感兴趣。</p><p id="3a16" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><em class="lr"> costs </em>方法生成被加数列表，该列表将按从高到低的顺序排列，以消除权重最大的坐标。</p><h2 id="269b" class="mc kv ht bd kw md me mf la mg mh mi le jr mj mk lg jv ml mm li jz mn mo lk mp bi translated">夏普方法</h2><p id="ff08" class="pw-post-body-paragraph ji jj ht jk b jl lm iu jn jo ln ix jq jr lo jt ju jv lp jx jy jz lq kb kc kd hb bi translated"><em class="lr"> sharp </em>方法是我们将所有信息结合起来，使其在整个结构中完全连贯的方法。考虑如何引用桌子的坐标:</p><figure class="lt lu lv lw fd hk er es paragraph-image"><div class="er es nc"><img src="../Images/6f0fad2bc7597151b5cb04004ade6b7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*bL_QCfHtUQf2_cw2e65gDQ.jpeg"/></div><figcaption class="lx ly et er es lz ma bd b be z dx">Relationship between clauses of the table and their indices for _sharp method</figcaption></figure><pre class="lt lu lv lw fd ms mt mu mv aw mw bi"><span id="f1a8" class="mc kv ht mt b fi mx my l mz na">def sharp(self):<br/>        for i in range(4):<br/>            self._sharp(list(range(i)) + list(range(i+1, 4)))</span><span id="d22f" class="mc kv ht mt b fi nb my l mz na">def _sharp(self, L3):<br/>        [I, J, K] = L3<br/>        self.T[3-K][I] &amp;= self.T[3-J][I] * self.T[3-K][J]<br/>        self.T[3-J][I] &amp;= self.T[3-K][I] \<br/>                          * self.T[3-K][J].transpose()<br/>        self.T[3-K][J] &amp;= self.T[3-J][I].transpose() \<br/>                          * self.T[3-K][I]</span></pre><h2 id="668d" class="mc kv ht bd kw md me mf la mg mh mi le jr mj mk lg jv ml mm li jz mn mo lk mp bi translated">优化方法</h2><p id="fce3" class="pw-post-body-paragraph ji jj ht jk b jl lm iu jn jo ln ix jq jr lo jt ju jv lp jx jy jz lq kb kc kd hb bi translated">如前所述，为了优化，我们将遍历列表，我们将逐个消除坐标，只要它不是生成某种解决方案的实质性因素。这样，直到我们获得一个独特的解决方案。</p><p id="dbb3" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">为了找出是否没有单一的解决方案，以及是否只有一个解决方案，我们只需进入代表场地设施分配的二元矩阵。</p><pre class="lt lu lv lw fd ms mt mu mv aw mw bi"><span id="cd78" class="mc kv ht mt b fi mx my l mz na">@staticmethod<br/>def notPermutable(aMatrix):<br/>        'Returns if aMatrix contains a permutation'<br/>        return aMatrix.sum(axis = 0).prod() \<br/>               * aMatrix.sum(axis = 1).prod()  == 0<br/>   <br/>@staticmethod<br/>def oneSwap(aMatrix):<br/>        'Returns if aMatrix contains exactly one permutation'<br/>        return aMatrix.sum(axis = 0).prod()==1 \<br/>               and aMatrix.sum(axis = 1).prod()  == 1</span><span id="392e" class="mc kv ht mt b fi nb my l mz na">def noSolution(self):<br/>        return QAP.notPermutable(self.T[0][0])</span><span id="272e" class="mc kv ht mt b fi nb my l mz na">def gotOneSolution(self):<br/>        return QAP.oneSwap(self.T[0][0])</span></pre><p id="836a" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">为了消除解，我们将实现_break方法，该方法将利用消除赋值的和，或者产生乘法的最大因子来消除。</p><pre class="lt lu lv lw fd ms mt mu mv aw mw bi"><span id="4a94" class="mc kv ht mt b fi mx my l mz na">def _break(self, item):<br/>        if len(item) ==  2:<br/>            i, j = item<br/>            self.T[0][0][i, j] = False<br/>        elif len(item) == 4:<br/>            i, j, k, l = item<br/>            if self.T[0][2][i, j] &gt; self.T[2][0][k, l]:<br/>                self.T[0][2][i, j] = False<br/>                self.T[0][2][j, i] = False<br/>            else:<br/>                self.T[2][0][k, l] = False<br/>                self.T[2][0][l, k] = False</span></pre><p id="839f" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">移除多余元素后，尝试应用sharp来查看结构是否保持不变，因此我们继续对其进行优化。</p><pre class="lt lu lv lw fd ms mt mu mv aw mw bi"><span id="dfe4" class="mc kv ht mt b fi mx my l mz na">def _saveTable(self):<br/>        R = []<br/>        for row in self.T:         <br/>            R.append([m.copy() for m in row])<br/>        return R</span><span id="f6aa" class="mc kv ht mt b fi nb my l mz na">def optimize(self):<br/>        saved = []<br/>        for X in self.L:<br/>            saveT = self._saveTable()<br/>            self._break(X[1])<br/>            self.sharp()<br/>            if self.noSolution():<br/>                saved.append(X)<br/>                self.T = saveT<br/>            elif self.gotOneSolution():<br/>                return True<br/>        return False</span></pre><p id="629f" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">实现后，<em class="lr"> optimize </em>方法不能返回<strong class="jk mr"> False </strong>，除非有bug。不要忘记，以各种可能的方式测试、改进和使用这些代码是很有趣的。</p><h2 id="b76e" class="mc kv ht bd kw md me mf la mg mh mi le jr mj mk lg jv ml mm li jz mn mo lk mp bi translated">显示结果</h2><p id="3121" class="pw-post-body-paragraph ji jj ht jk b jl lm iu jn jo ln ix jq jr lo jt ju jv lp jx jy jz lq kb kc kd hb bi translated">最后，为了显示结果，您只需利用<strong class="jk mr"> numpy </strong>库提供的工具来搜索非零坐标。</p><pre class="lt lu lv lw fd ms mt mu mv aw mw bi"><span id="1566" class="mc kv ht mt b fi mx my l mz na">def listing(self):<br/>        'PRE: There is one and only one solution'<br/>        'POST: The assingment is returned'<br/>        A = {}<br/>        X, Y = self.T[0][0].nonzero()<br/>        for i, x in enumerate(X):<br/>            A[x] = Y[i]<br/>        return A</span><span id="b54b" class="mc kv ht mt b fi nb my l mz na">def evaluate(self, S):<br/>        cost = 0<br/>        for i, site in S.items():<br/>            cost += self.A[site, i]<br/>        for i in range(1, len(S)):<br/>            for j in range(i):<br/>                cost += self.F[i, j]*self.D[S[i], S[j]]<br/>        return cost</span></pre><p id="7ae3" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><em class="lr">列出的</em>方法将返回我们的作业，而<em class="lr">评估</em>方法该作业的成本是多少。</p><p id="a82c" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">要测试此代码，您可以键入:</p><pre class="lt lu lv lw fd ms mt mu mv aw mw bi"><span id="fb5d" class="mc kv ht mt b fi mx my l mz na">def test1(A, D, F):<br/>    qap = QAP(A, D, F)<br/>    if qap.optimize():<br/>        result = qap.listing()<br/>        return result, qap.evaluate(result)<br/>    return None, None</span></pre><p id="72bf" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">这样…，</p><pre class="lt lu lv lw fd ms mt mu mv aw mw bi"><span id="16a9" class="mc kv ht mt b fi mx my l mz na">&gt;&gt;&gt; test1([[9, 51, 3], [2, 4, 1], [6, 22, 7]], <br/>[[0, 70, 2], [7, 0, 43], [2, 41, 0]], <br/>[[0, 31, 6], [3, 0, 42], [6, 4, 0]])<br/>({0: 2, 1: 1, 2: 0}, 434)</span></pre><h1 id="97a0" class="ku kv ht bd kw kx ky kz la lb lc ld le iz lf ja lg jc lh jd li jf lj jg lk ll bi translated">结论</h1><p id="994d" class="pw-post-body-paragraph ji jj ht jk b jl lm iu jn jo ln ix jq jr lo jt ju jv lp jx jy jz lq kb kc kd hb bi translated">作为开始，<a class="ae ke" href="https://archive.org/details/QuadraticAssingmentProblem" rel="noopener ugc nofollow" target="_blank">这里的</a>是供你仔细检查的代码。你要觉得很正常，对于那些自称有很重要结构的人来说，很多问题都可以用简单的方法解决。</p><p id="5d2f" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">但是，还是有可能这种结构只是由于一些我自己没能成熟的失败而产生的改进。在任何情况下，它都应该被用作理解这些模型如何工作的培训。</p><h1 id="a77e" class="ku kv ht bd kw kx ky kz la lb lc ld le iz lf ja lg jc lh jd li jf lj jg lk ll bi translated">参考</h1><p id="637b" class="pw-post-body-paragraph ji jj ht jk b jl lm iu jn jo ln ix jq jr lo jt ju jv lp jx jy jz lq kb kc kd hb bi translated">[1] Sahni S，和Gonzalez t .<em class="lr">P-完全逼近问题</em>。计算机械协会杂志23(1976)555–565。</p><p id="c08b" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">[2]劳勒E. <em class="lr">二次分配问题</em>，《管理科学》9(1963)586–599。</p></div></div>    
</body>
</html>