<html>
<head>
<title>Typing Next.JS components using TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">接下来打字。使用TypeScript的JS组件</h1>
<blockquote>原文：<a href="https://medium.com/swlh/typing-next-js-components-using-typescript-2f1d0dc30c4c#2019-05-22">https://medium.com/swlh/typing-next-js-components-using-typescript-2f1d0dc30c4c#2019-05-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/722d3b16d3fbafae0586e81a17147755.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mtDnz3rh3aPu04xF1pyiyw.png"/></div></div></figure><blockquote class="iq ir is"><p id="90c3" class="it iu iv iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw js">注:</strong>本帖涵盖打字Next。使用v9之前版本的JS应用程序。从版本9开始，接下来。默认情况下，JS有自己的类型，它们的名称可能与DefinitelyTyped package中使用的不同。如果你用Next。JS版本9及以上，请参考<a class="ae jt" href="https://nextjs.org/docs#typescript" rel="noopener ugc nofollow" target="_blank">官方文档</a>。对于早期版本，请继续阅读:)</p></blockquote><p id="7002" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je ju jg jh ji jv jk jl jm jw jo jp jq jr hb bi translated">在这篇文章中，我们接下来将讨论打字。JS组件。接下来我们将使用<a class="ae jt" href="https://github.com/koss-lebedev/nextjs-typescript" rel="noopener ugc nofollow" target="_blank">这个。JS </a>应用程序，连接到Reddit API并显示给定子编辑中热门文章的列表。现在，主要组件<code class="du jx jy jz ka b">Posts.tsx</code>没有任何类型安全，所以我们将修复它。</p><p id="04fb" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je ju jg jh ji jv jk jl jm jw jo jp jq jr hb bi translated"><em class="iv">注意:</em>项目已经包含了配置的TypeScript，所以如果你不知道怎么做，请在这里阅读官方指南<a class="ae jt" href="https://github.com/zeit/next-plugins/tree/master/packages/next-typescript" rel="noopener ugc nofollow" target="_blank">，就像安装一些依赖项和放入一些配置文件一样简单。</a></p><p id="e23f" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je ju jg jh ji jv jk jl jm jw jo jp jq jr hb bi translated">现在让我们从GitHub克隆<a class="ae jt" href="https://github.com/koss-lebedev/nextjs-typescript" rel="noopener ugc nofollow" target="_blank">项目</a>并开始吧。</p><h2 id="dc39" class="kb kc hi bd kd ke kf kg kh ki kj kk kl ju km kn ko jv kp kq kr jw ks kt ku kv bi translated">功能组件</h2><p id="2688" class="pw-post-body-paragraph it iu hi iw b ix kw iz ja jb kx jd je ju ky jh ji jv kz jl jm jw la jp jq jr hb bi translated">首先，让我们看看一般情况下我们是如何输入React组件的。</p><p id="a234" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je ju jg jh ji jv jk jl jm jw jo jp jq jr hb bi translated">如果我们把组件写成函数，我们可以使用React库中的<code class="du jx jy jz ka b">FunctionComponent</code>类型。此类型采用描述道具形状的泛型类型参数。我们的<code class="du jx jy jz ka b">Posts</code>组件接受一个子编辑名和一个帖子列表，所以<code class="du jx jy jz ka b">props</code>对象看起来像这样:</p><figure class="lb lc ld le fd ij"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="934e" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je ju jg jh ji jv jk jl jm jw jo jp jq jr hb bi translated">现在当我们把道具分解成<code class="du jx jy jz ka b">posts</code>和<code class="du jx jy jz ka b">subreddit</code>的时候，我们得到了全类型安全。很漂亮，对吧？</p><p id="340f" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je ju jg jh ji jv jk jl jm jw jo jp jq jr hb bi translated">现在我们来看下一个。JS组件。</p><h2 id="74c1" class="kb kc hi bd kd ke kf kg kh ki kj kk kl ju km kn ko jv kp kq kr jw ks kt ku kv bi translated">NextFunctionComponent</h2><p id="6920" class="pw-post-body-paragraph it iu hi iw b ix kw iz ja jb kx jd je ju ky jh ji jv kz jl jm jw la jp jq jr hb bi translated">接下来的一件事。JS组件不同的是一个静态的<code class="du jx jy jz ka b">getInitialProps</code>函数。如果我们试图将它赋给我们的常规React组件，我们将得到一个类型错误:</p><figure class="lb lc ld le fd ij"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="c60e" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je ju jg jh ji jv jk jl jm jw jo jp jq jr hb bi translated">为了解决这个问题，我们需要使用一个特殊的组件类型。JS包名为<code class="du jx jy jz ka b">NextFunctionComponent</code>。这种类型用Next扩展了标准React的<code class="du jx jy jz ka b">FunctionComponent</code>类型。特定于JS的静态生命周期方法(实际上，只有一种方法)。所以现在我们的代码看起来像这样:</p><figure class="lb lc ld le fd ij"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="8654" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je ju jg jh ji jv jk jl jm jw jo jp jq jr hb bi translated">为了使我们的类型更加健壮，我们可以通过<em class="iv">推断从<code class="du jx jy jz ka b">getInitialProps</code>函数返回的<code class="du jx jy jz ka b">props</code>的形状，而不是手动定义它们。为此，首先，我们要将<code class="du jx jy jz ka b">getInitialProps</code>函数提取到一个单独的变量中。当我们开始推断道具的形状时，需要这一步来避免循环类型引用:</em></p><figure class="lb lc ld le fd ij"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="1202" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je ju jg jh ji jv jk jl jm jw jo jp jq jr hb bi translated">接下来，我们可以使用<code class="du jx jy jz ka b">ReturnType</code>帮助器类型来获取从<code class="du jx jy jz ka b">getInitialProps</code>函数返回的值的类型:</p><figure class="lb lc ld le fd ij"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="8bea" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je ju jg jh ji jv jk jl jm jw jo jp jq jr hb bi translated">由于<code class="du jx jy jz ka b">getInitialProps</code>函数是异步的，返回类型将是一个承诺，所以我们也需要提取它的值。我们可以定义一个全局助手类型，它将使用条件类型魔法来解开我们的承诺:</p><figure class="lb lc ld le fd ij"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="65f5" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je ju jg jh ji jv jk jl jm jw jo jp jq jr hb bi translated">现在我们可以把所有东西放在一起:</p><figure class="lb lc ld le fd ij"><div class="bz dy l di"><div class="lf lg l"/></div></figure><h2 id="366e" class="kb kc hi bd kd ke kf kg kh ki kj kk kl ju km kn ko jv kp kq kr jw ks kt ku kv bi translated">NextContext</h2><p id="856b" class="pw-post-body-paragraph it iu hi iw b ix kw iz ja jb kx jd je ju ky jh ji jv kz jl jm jw la jp jq jr hb bi translated">让我们通过从查询字符串中提取一个子编辑的名称来使这个例子更有趣。</p><p id="da96" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je ju jg jh ji jv jk jl jm jw jo jp jq jr hb bi translated">为了实现这一点，我们可以使用一个<code class="du jx jy jz ka b">context</code>参数，该参数被传递给到目前为止我们还没有使用过的<code class="du jx jy jz ka b">getInitialProps</code>函数。我们将使用<code class="du jx jy jz ka b">NextContext&lt;T&gt;</code> type来键入这个参数。类型<code class="du jx jy jz ka b">T</code>允许我们指定查询字符串中的参数(在我们的例子中是<code class="du jx jy jz ka b">subreddit</code>):</p><figure class="lb lc ld le fd ij"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="b2e4" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je ju jg jh ji jv jk jl jm jw jo jp jq jr hb bi translated">我们在<code class="du jx jy jz ka b">getInitialProps</code>函数中得到了类型安全，但是现在我们遇到了另一个类型错误，即<code class="du jx jy jz ka b">Context</code>的不兼容类型。</p><p id="350c" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je ju jg jh ji jv jk jl jm jw jo jp jq jr hb bi translated">原因是默认情况下<code class="du jx jy jz ka b">getInitialProps</code>期望一个上下文是通用类型<code class="du jx jy jz ka b">NextContext</code>，但是我们指定了一个更严格、更具体的类型— <code class="du jx jy jz ka b">NextContext&lt;{ subreddit: string }.</code>为了解决这个问题，我们需要向<code class="du jx jy jz ka b">NextFunctionComponent</code>类型传递更多的类型参数。它的完整签名如下所示:</p><figure class="lb lc ld le fd ij"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="ee4d" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je ju jg jh ji jv jk jl jm jw jo jp jq jr hb bi translated">如您所见，<code class="du jx jy jz ka b">NextFunctionComponent</code>最多可以有3种类型— <code class="du jx jy jz ka b">Props</code>、<code class="du jx jy jz ka b">InitialProps</code>和<code class="du jx jy jz ka b">Context</code>。<code class="du jx jy jz ka b">InitialProps</code>应该只包含从<code class="du jx jy jz ka b">getInitialProps</code>函数返回的道具。<code class="du jx jy jz ka b">Props</code>应该包含组件可以访问的所有道具，包括自己的组件道具、通过更高阶组件传递的道具(比如来自Redux的<code class="du jx jy jz ka b">connect</code>)，加上初始道具。最后，<code class="du jx jy jz ka b">Context</code>指定了组件所使用的上下文的形状。</p><p id="4b0d" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je ju jg jh ji jv jk jl jm jw jo jp jq jr hb bi translated">当我们把所有的东西放在一起，我们会得到一个完整的下一步。JS组件:</p><figure class="lb lc ld le fd ij"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="bccd" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je ju jg jh ji jv jk jl jm jw jo jp jq jr hb bi translated">您可以在<a class="ae jt" href="https://github.com/koss-lebedev/nextjs-typescript/tree/final" rel="noopener ugc nofollow" target="_blank">“final”分支</a>中找到完全类型化组件的源代码。</p><h2 id="91cb" class="kb kc hi bd kd ke kf kg kh ki kj kk kl ju km kn ko jv kp kq kr jw ks kt ku kv bi translated">结论</h2><p id="c26d" class="pw-post-body-paragraph it iu hi iw b ix kw iz ja jb kx jd je ju ky jh ji jv kz jl jm jw la jp jq jr hb bi translated">在本文中，我们探索了如何键入Next。JS组件。该方法不同于键入常规的React功能组件，因为接下来是特殊的<code class="du jx jy jz ka b">getInitialProps</code>函数。用JS编写的props数据服务器端。因此，我们需要使用Next附带的特殊的<code class="du jx jy jz ka b">NextFunctionComponent</code>和<code class="du jx jy jz ka b">NextContext</code>类型。JS打字包。</p><p id="0a32" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je ju jg jh ji jv jk jl jm jw jo jp jq jr hb bi translated">PS:如果你想知道为什么我们到处使用类型别名而不是接口，一定要看看这篇文章。</p></div><div class="ab cl lh li gp lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="hb hc hd he hf"><p id="7be4" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je ju jg jh ji jv jk jl jm jw jo jp jq jr hb bi translated"><strong class="iw js">不要脸的塞</strong>:如果你想在不写一大堆样板文件的情况下学习如何使用Redux，可以在Youtube上查看我的<a class="ae jt" href="http://bit.ly/rematch-course" rel="noopener ugc nofollow" target="_blank">“带重配的状态管理”</a>课程。</p><figure class="lb lc ld le fd ij"><div class="bz dy l di"><div class="lo lg l"/></div></figure></div></div>    
</body>
</html>