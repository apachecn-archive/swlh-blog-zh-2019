<html>
<head>
<title>Amazonian puppeteer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">亚马逊木偶师</h1>
<blockquote>原文：<a href="https://medium.com/swlh/amazonian-puppeteer-b590d199dfdc?source=collection_archive---------21-----------------------#2019-06-17">https://medium.com/swlh/amazonian-puppeteer-b590d199dfdc?source=collection_archive---------21-----------------------#2019-06-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="07b4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让木偶师在AWS Lambda中工作的冒险</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/53aa0638055ba1ff9943be13c6242dd6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1We8A15NJJnK9FQBejB6mg.jpeg"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx"><a class="ae jt" href="https://www.thegef.org/sites/default/files/Amazon_870.jpg" rel="noopener ugc nofollow" target="_blank">https://www.thegef.org/sites/default/files/Amazon_870.jpg</a></figcaption></figure><h1 id="cdbb" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">介绍</h1><p id="7132" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">我是我认识的最健忘的人。毫不奇怪，到了周末提交时间表的时候，我似乎总是忘记。好吧，我决定自己动手，把整件该死的事情自动化。</p><p id="1cca" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个想法是屏幕抓取我的时间记录应用程序，因为他们不提供一个API。然后获取该信息并提交给另一个时间表应用程序(也没有API)。我提到这些细节只是作为证明围绕该技术的决策的前言。</p><p id="2d08" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">归根结底，我需要自动执行每周提交，所以我需要某种cron作业。它将从javascript动态生成的屏幕抓取数据，所以我需要一个无头浏览器。我正在使用我的用户名和密码，所以我需要某种秘密存储。</p><p id="8b42" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">技术堆栈AWS Lambda、CloudWatch cron event、AWS Secrets Manager和木偶师中的选择。我不会详细说明我是如何让我的最终解决方案发挥作用的，而是会向您展示我的技术堆栈的工作实现。</p><h1 id="c3a5" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">要求</h1><p id="206d" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">在我们真正开始之前，我们需要事先了解一些事情。</p><ol class=""><li id="fff1" class="kx ky hi ih b ii ij im in iq kz iu la iy lb jc lc ld le lf bi translated">AWS账户:不言而喻，如果你要使用AWS，你需要有一个账户。我们将尽可能利用免费层服务。<a class="ae jt" href="https://aws.amazon.com/premiumsupport/knowledge-center/create-and-activate-aws-account/" rel="noopener ugc nofollow" target="_blank">https://AWS . Amazon . com/premium support/knowledge-center/create-and-activate-AWS-account/</a></li><li id="e3cc" class="kx ky hi ih b ii lh im li iq lj iu lk iy ll jc lc ld le lf bi translated"><strong class="ih lg">安装docker</strong>:AWS提倡的开发方式挺有意思的。为了模拟Lambda运行时环境，AWS提供了许多Docker映像供开发人员使用，这意味着我们需要Docker来使用它们。对于Mac系统<a class="ae jt" href="https://aws.amazon.com/premiumsupport/knowledge-center/create-and-activate-aws-account/" rel="noopener ugc nofollow" target="_blank">https://AWS . Amazon . com/premium support/knowledge-center/create-and-activate-AWS-account/</a>和Windows系统<a class="ae jt" href="https://docs.docker.com/docker-for-windows/install/" rel="noopener ugc nofollow" target="_blank">https://docs.docker.com/docker-for-windows/install/系统</a>。我用的版本是Mac 2.0.0.3的Docker桌面。</li><li id="e703" class="kx ky hi ih b ii lh im li iq lj iu lk iy ll jc lc ld le lf bi translated"><strong class="ih lg">安装Node JS </strong>:因为应用程序将使用Node JS，所以确保您已经安装了Node JS和NPM的最新版本是很有意义的。我用的版本是Node v11.9.0和NPM v 6.9.0。<a class="ae jt" href="https://nodejs.org/en/download/" rel="noopener ugc nofollow" target="_blank">https://nodejs.org/en/download/</a></li><li id="128e" class="kx ky hi ih b ii lh im li iq lj iu lk iy ll jc lc ld le lf bi translated"><strong class="ih lg">安装AWS命令行界面</strong>:我们将使用AWS无服务器应用程序模型来创建和提交lambda函数，这些函数又依赖于AWS Cli。这意味着还需要安装Python和PIP。<a class="ae jt" href="https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-install.html" rel="noopener ugc nofollow" target="_blank">https://docs . AWS . Amazon . com/CLI/latest/user guide/CLI-chap-install . html</a>要获得您正在使用的版本，您可以键入“aws - version ”,对我来说是:AWS-CLI/1 . 16 . 99 Python/2 . 7 . 15 Darwin/18 . 6 . 0 boto core/1 . 12 . 89</li><li id="e92b" class="kx ky hi ih b ii lh im li iq lj iu lk iy ll jc lc ld le lf bi translated"><strong class="ih lg">安装SAM命令行界面</strong>:我决定利用无服务器应用模型来提交和管理lambda函数，因为它将所有东西都保存在AWS堆栈中，并且我可以利用我对CloudFormation模板的熟悉程度。https://docs . AWS . Amazon . com/server less-application-model/latest/developer guide/server less-SAM-CLI-install . html对我来说这就是SAM CLI，版本0.16.1。</li></ol><h1 id="688f" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">地形* * TL灾难恢复警告**</h1><p id="afaa" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">在我进入这个过程之前，我想简单介绍一下我使用的技术和概念。我觉得对于那些不知道或者忘记了，需要提醒的人来说是公平的。公平的警告，虽然这是TL；如果你已经很熟悉这个东西，你可以跳过这个。</p><ul class=""><li id="61e5" class="kx ky hi ih b ii ij im in iq kz iu la iy lb jc lm ld le lf bi translated"><strong class="ih lg"> Lambda </strong> : Lambda是一款AWS无服务器产品。它是在你为你所使用的东西付费的基础上运作的。您基本上创建并上传了您期望执行的函数，并指定了它应该如何被调度，但是并不确定它将在实际的硬件上运行。Lambda是以GB秒为基础定价的，这意味着您需要为每个Lambda函数的持续时间内提供的千兆字节数付费，无论这些千兆字节是否被使用。Lambda可以在许多运行时环境NodeJS、Python、.网络等。像大多数AWS服务一样，它连接到AWS基础设施。<a class="ae jt" href="https://aws.amazon.com/lambda/" rel="noopener ugc nofollow" target="_blank">https://aws.amazon.com/lambda/</a></li><li id="635e" class="kx ky hi ih b ii lh im li iq lj iu lk iy ll jc lm ld le lf bi translated"><strong class="ih lg">cloud formation</strong>:cloud formation是AWS将其基础设施指定为代码的方式。它使用yaml或json格式来声明性地定义要提供哪些资源和基础设施。通过AWS中的CloudFormation，您可以定义想要使用的完整资源堆栈。它允许以幂等的方式提供资源。它使用模板引用、资源引用和参数。<a class="ae jt" href="https://aws.amazon.com/cloudformation/" rel="noopener ugc nofollow" target="_blank">https://aws.amazon.com/cloudformation/</a></li><li id="0c17" class="kx ky hi ih b ii lh im li iq lj iu lk iy ll jc lm ld le lf bi translated">SAM模板:SAM模板是CloudFormation的扩展，这意味着您可以使用全套资源。它附带了一些专门用于定义无服务器应用程序的简化结构。<a class="ae jt" href="https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-sam-template-basics.html" rel="noopener ugc nofollow" target="_blank">https://docs . AWS . Amazon . com/server less-application-model/latest/developer guide/server less-Sam-template-basics . html</a></li><li id="1566" class="kx ky hi ih b ii lh im li iq lj iu lk iy ll jc lm ld le lf bi translated"><strong class="ih lg">Cron expression</strong>:Cron expression源于unix系统中的一个实用程序，它允许用户安排任务在指定的日期/时间定期运行。cron语法表示一个描述事件何时执行的表达式。它通常由六个必填字段组成，其中&lt;年&gt;是可选的(<a class="ae jt" href="https://www.baeldung.com/cron-expressions" rel="noopener ugc nofollow" target="_blank">https://www.baeldung.com/cron-expressions</a>):</li></ul><blockquote class="ln lo lp"><p id="b186" class="if ig lq ih b ii ij ik il im in io ip lr ir is it ls iv iw ix lt iz ja jb jc hb bi translated">【T8<minute><hour><day-of-month><month><day-of-week><year/></day-of-week></month></day-of-month></hour></minute></p></blockquote><ul class=""><li id="0287" class="kx ky hi ih b ii ij im in iq kz iu la iy lb jc lm ld le lf bi translated"><strong class="ih lg"> Chrome DevTools协议</strong>:这是一个允许工具对Chrome、Chrome和其他基于Blink的浏览器进行检测、检查、调试和分析的协议。该协议给出了集成和调试浏览器的标准化方法<a class="ae jt" href="https://chromedevtools.github.io/devtools-protocol/" rel="noopener ugc nofollow" target="_blank">https://chromedevtools.github.io/devtools-protocol/</a></li><li id="ecc0" class="kx ky hi ih b ii lh im li iq lj iu lk iy ll jc lm ld le lf bi translated">Chromium是一个开源浏览器项目，它构成了Chrome网络浏览器的基础，不需要额外的东西，比如自动更新和对额外视频格式的支持。鉴于Chromium支持Chrome DevTools协议，它是无头浏览器的完美候选。一个<a class="ae jt" href="https://en.wikipedia.org/wiki/Headless_browser" rel="noopener ugc nofollow" target="_blank">无头<strong class="ih lg">T23】浏览器</strong></a>基本上是一个没有图形界面的网络浏览器。<a class="ae jt" href="https://www.howtogeek.com/202825/what%E2%80%99s-the-difference-between-chromium-and-chrome/" rel="noopener ugc nofollow" target="_blank">https://www . how togeek . com/202825/what % E2 % 80% 99s-the-difference-of-chromium-and-chrome/</a></li><li id="2f36" class="kx ky hi ih b ii lh im li iq lj iu lk iy ll jc lm ld le lf bi translated"><strong class="ih lg">木偶师</strong>:木偶师是一个节点库，它提供了一个高级API来控制Chrome或通过<a class="ae jt" href="https://chromedevtools.github.io/devtools-protocol/" rel="noopener ugc nofollow" target="_blank"> DevTools协议</a>的Chrome。默认情况下，木偶师运行无头的<a class="ae jt" href="https://developers.google.com/web/updates/2017/04/headless-chrome" rel="noopener ugc nofollow" target="_blank">，但可以配置为运行全(无头)铬或铬。在本文中，我使用了puppeter-core，它是相同的api，但默认情况下不下载chromium浏览器。</a><a class="ae jt" href="https://github.com/GoogleChrome/puppeteer" rel="noopener ugc nofollow" target="_blank">https://github.com/GoogleChrome/puppeteer</a></li><li id="9b96" class="kx ky hi ih b ii lh im li iq lj iu lk iy ll jc lm ld le lf bi translated">AWS Secrets Manager :这是AWS提供的一项服务，用于帮助管理受保护的机密。它允许我们使用证书在AWS中存储敏感信息。使用Secrets Manager，我们可以将加密和证书轮换等管理细节留给AWS。<a class="ae jt" href="https://aws.amazon.com/secrets-manager/" rel="noopener ugc nofollow" target="_blank">https://aws.amazon.com/secrets-manager/</a></li></ul><h1 id="be2c" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">冒险</h1><p id="bf30" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">一旦我安装并配置好了所有东西，我就通读了一下<a class="ae jt" href="https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-quick-start.html" rel="noopener ugc nofollow" target="_blank"> SAM文档</a>，看起来开始一切只是一个简单的SAM初始化。这里有几个注意事项，首先是你需要以<a class="ae jt" href="https://github.com/alixaxel/chrome-aws-lambda#usage" rel="noopener ugc nofollow" target="_blank"> nodejs8.10 </a>运行时为目标，因为这是<a class="ae jt" href="https://github.com/alixaxel/chrome-aws-lambda" rel="noopener ugc nofollow" target="_blank"> chrome-aws-lambda </a>包所需的运行时。第二，你可能不想把你的工作文件夹命名为hello-world，所以给它一个名字是个好主意。</p><pre class="je jf jg jh fd lu lv lw lx aw ly bi"><span id="11b0" class="lz jv hi lv b fi ma mb l mc md">sam init -r nodejs8.10 -n autoweb</span></pre><ul class=""><li id="4c8f" class="kx ky hi ih b ii ij im in iq kz iu la iy lb jc lm ld le lf bi translated">-r是运行时的缩写</li><li id="e715" class="kx ky hi ih b ii lh im li iq lj iu lk iy ll jc lm ld le lf bi translated">-n是名字的缩写</li><li id="3694" class="kx ky hi ih b ii lh im li iq lj iu lk iy ll jc lm ld le lf bi translated">您可以使用“sam init - help”获得帮助</li></ul><p id="f2c6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">生成的自述文件很好地解释了正在发生的一切，所以我不打算进一步展开。default template.yaml文件中的链接也非常好，所以最好记下它们并保存到您的收藏夹中以备后用。以防万一，我将在下面列出它们。</p><ul class=""><li id="d11b" class="kx ky hi ih b ii ij im in iq kz iu la iy lb jc lm ld le lf bi translated">关于全局的更多信息:<a class="ae jt" href="https://github.com/awslabs/serverless-application-model/blob/master/docs/globals.rst" rel="noopener ugc nofollow" target="_blank">https://github . com/aw slabs/server less-application-model/blob/master/docs/Globals . rst</a></li><li id="d281" class="kx ky hi ih b ii lh im li iq lj iu lk iy ll jc lm ld le lf bi translated">关于函数资源的更多信息:<a class="ae jt" href="https://github.com/awslabs/serverless-application-model/blob/master/versions/2016-10-31.md#awsserverlessfunction" rel="noopener ugc nofollow" target="_blank">https://github . com/aw slabs/server less-application-model/blob/master/versions/2016-10-31 . MD # awsserverlessfunction</a></li><li id="042b" class="kx ky hi ih b ii lh im li iq lj iu lk iy ll jc lm ld le lf bi translated">关于API事件源的更多信息:<a class="ae jt" href="https://github.com/awslabs/serverless-application-model/blob/master/versions/2016-10-31.md#api" rel="noopener ugc nofollow" target="_blank">https://github . com/aw slabs/server less-application-model/blob/master/versions/2016-10-31 . MD # API</a></li><li id="4339" class="kx ky hi ih b ii lh im li iq lj iu lk iy ll jc lm ld le lf bi translated">ServerlessRestApi是在Serverless::Function下用Events键创建的隐式Api。了解更多关于您可以在SAM中引用的其他隐式资源:<a class="ae jt" href="https://github.com/awslabs/serverless-application-model/blob/master/docs/internals/generated_resources.rst#api" rel="noopener ugc nofollow" target="_blank">https://github . com/aw slabs/server less-application-model/blob/master/docs/internals/generated _ resources . rst # API</a></li></ul><p id="d984" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">拥有一个默认的入门模板是很棒的，但是我们有一个名为hello-world的文件夹。我们也没有使用api端点，至少在这个例子中没有，所以让我们来解决这个问题。在template.yaml中，对全局变量下面的资源部分进行更改。</p><pre class="je jf jg jh fd lu lv lw lx aw ly bi"><span id="b913" class="lz jv hi lv b fi ma mb l mc md">Resources:<br/>   AutoWebFunction:<br/>   Type: AWS::Serverless::Function<br/>   Properties:<br/>      CodeUri: auto-web/<br/>      Handler: app.lambdaHandler<br/>      Runtime: nodejs8.10</span><span id="63b6" class="lz jv hi lv b fi me mb l mc md">Outputs:<br/>   AutoWebFunction:<br/>      Description: "Hello World Lambda Function ARN"<br/>      Value: !GetAtt AutoWebFunction.Arn<br/>   AutoWebFunctionIamRole:<br/>      Description: "Implicit IAM Role created"<br/>      Value: !GetAtt AutoWebFunctionRole.Arn</span></pre><p id="b487" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在CloudFormation模板中，您可以直接在resources部分下面指定您正在使用的资源的名称。在我们的例子中，我们不再想称它为HelloWorldFunction，而是称它为AutoWebFunction。CodeUri属性指定了lambda函数的文件夹位置，在这种情况下，它的文件夹位置是相对于我们希望成为auto-web/的template.yaml文件的。我们现在可以删除Events部分，因为我们没有使用API端点。由于资源部分已经改变，我们需要在输出部分反映新的参考值。最后，API输出也可以删除，因为我们在这个例子中没有使用Api。要重命名文件夹，我们可以使用mv bash命令。</p><pre class="je jf jg jh fd lu lv lw lx aw ly bi"><span id="7feb" class="lz jv hi lv b fi ma mb l mc md">mv hello-world auto-web</span></pre><p id="e1c2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">看起来不错，但是让我们开始吧。再次快速回头看一下<a class="ae jt" href="https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-quick-start.html" rel="noopener ugc nofollow" target="_blank">文档</a>，看起来要运行的命令是sam local。因为我们没有使用API，所以我们需要用我们想要调用的函数名来指定invoke参数，在本例中是AutoWebFunction。</p><pre class="je jf jg jh fd lu lv lw lx aw ly bi"><span id="4c12" class="lz jv hi lv b fi ma mb l mc md">sam local invoke AutoWebFunction</span></pre><p id="e09a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该死，它在提醒我。如果我仔细看提示，它说还有另一个选项，使用输入文件代替。如果我查看文件和文件夹，我会注意到同一个文件夹中有一个event.json文件。好了，现在我们有东西可以用了。</p><pre class="je jf jg jh fd lu lv lw lx aw ly bi"><span id="7b76" class="lz jv hi lv b fi ma mb l mc md">sam local invoke AutoWebFunction --event event.json</span></pre><p id="aa70" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">嗯，我可以运行它，但我如何调试它。再看一下<a class="ae jt" href="https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-sam-cli-using-debugging.html" rel="noopener ugc nofollow" target="_blank">文档</a>，我们有一个如何启用调试的纲要。我使用的是<a class="ae jt" href="https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-sam-cli-using-debugging-nodejs.html" rel="noopener ugc nofollow" target="_blank"> VSCode </a>，所以我需要创建一个定制的启动配置并选择一个端口号。为此，我选择调试菜单&gt;在VSCode中添加配置…,默认情况下会创建一个。工作文件夹中的vscode/launch.json文件。下面是我的launch.json的样子:</p><pre class="je jf jg jh fd lu lv lw lx aw ly bi"><span id="0c0a" class="lz jv hi lv b fi ma mb l mc md">{<br/>"version": "0.2.0",<br/>"configurations": [<br/> {<br/>  "type": "node",<br/>  "request": "attach",<br/>  "name": "Attach to AutoWeb",<br/>  "address": "localhost",<br/>  "port": 9229,<br/>  "localRoot": "${workspaceFolder}/auto-web",<br/>  "remoteRoot": "/var/task",<br/>  "protocol": "inspector",<br/>  "stopOnEntry": false<br/> }<br/>]<br/>}</span></pre><p id="5d13" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要进行调试，您需要首先启动调试器，并让它监听您在launch.json文件中指定的端口，在本例中是9229。</p><pre class="je jf jg jh fd lu lv lw lx aw ly bi"><span id="8cb7" class="lz jv hi lv b fi ma mb l mc md">sam local invoke AutoWebFunction --event event.json -d 9229</span></pre><p id="f66f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当它运行并侦听时，您可以使用刚刚创建的启动配置从VSCode启动调试器。不要忘记在。/auto-web/app.js文件。</p><p id="c1c2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们得到了函数并可以调试，我认为现在是一个进入函数细节的好时机。在我们继续之前，我觉得有必要指出一个关于Lambda的非常重要的细节，那就是对<a class="ae jt" href="https://docs.aws.amazon.com/lambda/latest/dg/deployment-package-v2.html" rel="noopener ugc nofollow" target="_blank">部署包</a>大小的限制，基本上你的包最大需要<a class="ae jt" href="https://docs.aws.amazon.com/lambda/latest/dg/limits.html" rel="noopener ugc nofollow" target="_blank"> 50 MB压缩和250 MB解压缩</a>。为什么我现在提到这个是因为我犯了一个错误，就是安装了木偶师。当我部署或测试时，我不知道哪里出了问题，它以意想不到的方式中断，在第一次等待时冻结，等等。当我进一步调查时，我发现默认情况下，木偶师安装了一个大小为<a class="ae jt" href="https://www.npmjs.com/package/puppeteer#installation" rel="noopener ugc nofollow" target="_blank"> ~170 MB </a>的Chromium版本。如你所见，这对于Lambda函数来说不是一个可行的选择。幸运的是，我发现了chrome-AWS-lambda(T7 ),它的容量仍然高达33.21 MB(T8 ),但我们仍然可以做到这一点。因此，我们可以安装<a class="ae jt" href="https://github.com/alixaxel/chrome-aws-lambda" rel="noopener ugc nofollow" target="_blank"> chrome-aws-lambda </a>和<a class="ae jt" href="https://www.npmjs.com/package/puppeteer-core" rel="noopener ugc nofollow" target="_blank">puppeter-core</a>来代替木偶师，这是与木偶师相同的API，只是没有默认下载Chromium。将目录从工作文件夹切换到子文件夹auto-web。然后npm安装<a class="ae jt" href="https://github.com/alixaxel/chrome-aws-lambda" rel="noopener ugc nofollow" target="_blank"> chrome-aws-lambda </a>和<a class="ae jt" href="https://www.npmjs.com/package/puppeteer-core" rel="noopener ugc nofollow" target="_blank">木偶核心</a></p><pre class="je jf jg jh fd lu lv lw lx aw ly bi"><span id="cdbf" class="lz jv hi lv b fi ma mb l mc md">cd auto-web<br/>npm install chrome-aws-lambda puppeteer-core</span></pre><p id="bbba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在有了可调试和可部署的解决方案，是时候进入一些代码了。木偶师的文档非常好，所以如果你需要任何帮助，你可能会在https://devdocs.io/puppeteer/找到你需要的东西。</p><p id="1b59" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于Puppeteer只不过是DevTools协议上的一个高级api，所以我们需要一个运行Chromium浏览器的实例。一旦浏览器启动并运行，Puppeteer就可以建立到其主机的Web套接字连接，并开始交换消息。在app.js文件中:</p><pre class="je jf jg jh fd lu lv lw lx aw ly bi"><span id="b777" class="lz jv hi lv b fi ma mb l mc md">const chromium = require('chrome-aws-lambda')<br/>let browser = null<br/>let page = null</span><span id="1166" class="lz jv hi lv b fi me mb l mc md">....<br/>....<br/>....</span><span id="93f6" class="lz jv hi lv b fi me mb l mc md">exports.lambdaHandler = async (event, context) =&gt; {<br/>try {<br/>        browser = await chromium.puppeteer.launch({<br/>            args: chromium.args,<br/>            defaultViewport: chromium.defaultViewport,<br/>            executablePath: await chromium.executablePath,<br/>            headless: chromium.headless<br/>        })</span><span id="5077" class="lz jv hi lv b fi me mb l mc md">....<br/>....<br/>....</span></pre><p id="9a00" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">chromium.puppeteer.launch函数向浏览器对象返回一个承诺。它基本上启动浏览器，并通过websockets将puppeteer连接到正在运行的实例。有了浏览器对象，我们现在可以从浏览器创建一个页面对象。</p><pre class="je jf jg jh fd lu lv lw lx aw ly bi"><span id="4806" class="lz jv hi lv b fi ma mb l mc md">page = await browser.newPage()</span></pre><p id="9c38" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">page对象让我们可以访问我们需要的功能，比如浏览到一个url或者从页面上生成的html中获取一个选择器。我们现在可以使用页面对象与浏览器进行交互。</p><pre class="je jf jg jh fd lu lv lw lx aw ly bi"><span id="9606" class="lz jv hi lv b fi ma mb l mc md">const navigationPromise = page.waitForNavigation()<br/>await page.goto("https://www.example.com", { waitUntil: 'networkidle2' })<br/>await page.setViewport({ width: 1920, height: 1001 })<br/>await navigationPromise</span></pre><p id="4e2e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这里的第一行，我们使用了<a class="ae jt" href="https://devdocs.io/puppeteer/index#pagewaitfornavigationoptions" rel="noopener ugc nofollow" target="_blank"> waitForNavigation </a>函数，它向主资源响应返回一个承诺。当页面导航到一个新的URL或重新加载时，这个承诺就兑现了。当我们想要阻止执行以确保页面在我们继续之前被加载时，这是很有用的。</p><p id="94e6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下一行是<a class="ae jt" href="https://devdocs.io/puppeteer/index#pagegotourl-options" rel="noopener ugc nofollow" target="_blank"> goto </a> function这将导航到指定的url，在本例中为“https://www.example.com”。具有waitUntil属性的对象基本上是告诉page何时认为导航成功。在这种情况下，我们认为当至少<code class="du mf mg mh lv b">500</code>毫秒内没有超过2个网络连接时，导航就完成了。结果是一个与<a class="ae jt" href="https://devdocs.io/puppeteer/index#pagewaitfornavigationoptions" rel="noopener ugc nofollow" target="_blank"> waitForNavigation </a>非常相似的承诺，它允许我们在页面完成导航之前阻止执行。</p><p id="cda2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jt" href="https://devdocs.io/puppeteer/index#pagesetviewportviewport" rel="noopener ugc nofollow" target="_blank"> setViewport </a>调用只是设置视窗页面的预期宽度和高度。在此之后，我们阻止等待navigationPromise，它将双重确保我们已经成功导航到我们正在寻找的页面。</p><p id="cdea" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们在页面上，我们可以做一些屏幕报废，并从网页上获取一些值。</p><pre class="je jf jg jh fd lu lv lw lx aw ly bi"><span id="fbea" class="lz jv hi lv b fi ma mb l mc md">const footerleft = await page.waitForSelector('body &gt; div &gt; p:nth-child(2)')</span><span id="790a" class="lz jv hi lv b fi me mb l mc md">const textContent = await (await footerleft.getProperty('textContent')).jsonValue()</span></pre><p id="b7e8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">page对象有一个非常有用的函数<a class="ae jt" href="https://devdocs.io/puppeteer/index#pagewaitforselectorselector-options" rel="noopener ugc nofollow" target="_blank"> waitForSelector </a>。这个函数允许您指定一个<a class="ae jt" href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors" rel="noopener ugc nofollow" target="_blank">选择器</a>字符串(比如jquery)并向选择器指定的<a class="ae jt" href="https://devdocs.io/puppeteer/index#class-elementhandle" rel="noopener ugc nofollow" target="_blank">元素句柄</a>返回一个承诺。顾名思义，它会等待选择器出现在页面上。不过，你需要小心，如果你试图获取的元素不在页面上，这只会在30秒后超时，默认情况下，这是30秒的Lambda时间，可能会变得很昂贵。</p><p id="975e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这一点上，我们有一个<a class="ae jt" href="https://devdocs.io/puppeteer/index#class-elementhandle" rel="noopener ugc nofollow" target="_blank"> ElementHandle </a>来从中获取任何属性值，我们需要使用<a class="ae jt" href="https://devdocs.io/puppeteer/index#elementhandlegetpropertypropertyname" rel="noopener ugc nofollow" target="_blank"> getProperty </a>函数，它返回一个对<a class="ae jt" href="https://devdocs.io/puppeteer/index#class-jshandle" rel="noopener ugc nofollow" target="_blank"> JSHandle </a>的承诺。不完全是我们所追求的字符串值，所以我们需要再做一个技巧，那就是<a class="ae jt" href="https://devdocs.io/puppeteer/index#jshandlejsonvalue" rel="noopener ugc nofollow" target="_blank"> jsonValue </a>，它会给我们一个我们所追求的字符串值的承诺。</p><p id="009d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们得到了现在可以浏览和屏幕抓取的代码。其他有用的功能是<a class="ae jt" href="https://devdocs.io/puppeteer/index#pagetypeselector-text-options" rel="noopener ugc nofollow" target="_blank">页面。键入</a>和<a class="ae jt" href="https://devdocs.io/puppeteer/index#pageclickselector-options" rel="noopener ugc nofollow" target="_blank">页面。单击</a>可以让您在文本框中键入文本或单击选择器指定的按钮。</p><p id="b5fb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">确保您的函数可以优雅地退出总是一个好主意，所以确保您关闭页面并断开浏览器是一个好习惯。我们可以在finally块中这样做，以确保我们调用这些函数，不管我们可能遇到的任何异常。</p><pre class="je jf jg jh fd lu lv lw lx aw ly bi"><span id="cb59" class="lz jv hi lv b fi ma mb l mc md">....<br/>....<br/>....</span><span id="0f67" class="lz jv hi lv b fi me mb l mc md">exports.lambdaHandler = async (event, context) =&gt; {<br/>try {<br/>....<br/>....<br/>....<br/>    } catch (err) {<br/>       console.log(err)<br/>       return err<br/>    } finally {<br/>       if (page) {<br/>          await page.close()<br/>       }<br/>       if (browser) {<br/>          await browser.disconnect()<br/>       }<br/>}</span></pre><p id="61ef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">代码应该如下所示:</p><pre class="je jf jg jh fd lu lv lw lx aw ly bi"><span id="f902" class="lz jv hi lv b fi ma mb l mc md">const chromium = require('chrome-aws-lambda')</span><span id="6081" class="lz jv hi lv b fi me mb l mc md">let browser = null<br/>let page = null</span><span id="5582" class="lz jv hi lv b fi me mb l mc md">exports.lambdaHandler = async (event, context) =&gt; {<br/>   try {<br/>      browser = await chromium.puppeteer.launch({<br/>         args: chromium.args,<br/>         defaultViewport: chromium.defaultViewport,<br/>         executablePath: await chromium.executablePath,<br/>         headless: chromium.headless<br/>      })<br/>      <br/>      page = await browser.newPage()<br/>      const navigationPromise = page.waitForNavigation()<br/>      await page.goto("https://www.example.com", { waitUntil: 'networkidle2' })<br/>      await page.setViewport({ width: 1920, height: 1001 })<br/>      await navigationPromise<br/>      <br/>      const footerleft = await page.waitForSelector('body &gt; div &gt; p:nth-child(2)')<br/>      const textContent = await (await footerleft.getProperty('textContent')).jsonValue()<br/>      return { textContent }<br/>   } catch (err) {<br/>      console.log(err)<br/>      return err<br/>   } finally {<br/>      if (page) {<br/>         await page.close()<br/>      }<br/>      if (browser) {<br/>         await browser.disconnect()<br/>      }<br/>   }<br/>}</span></pre><p id="e1a7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此时，我们可以通过单步调试代码来验证一切正常。然而，我们仍然缺少的是一种在特定时间自动启动它的方法。这就是cron表达式发挥作用的地方，因此我们将重新访问SAM模板，并给出一个cron <a class="ae jt" href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-events-rule.html" rel="noopener ugc nofollow" target="_blank">事件</a>。最初，我在这里遇到一些困难，因为常规的<a class="ae jt" href="https://www.baeldung.com/cron-expressions" rel="noopener ugc nofollow" target="_blank"> cron表达式</a>包括6个必填字段，第七年是可选的。<a class="ae jt" href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/events/ScheduledEvents.html" rel="noopener ugc nofollow" target="_blank"> AWS cron expression </a>但是似乎不包括秒，所以我们需要记住这一点。让我们将Events部分添加到template.yaml中的AutoWebFunction中。</p><pre class="je jf jg jh fd lu lv lw lx aw ly bi"><span id="a5af" class="lz jv hi lv b fi ma mb l mc md">Resources:<br/>   AutoWebFunction:<br/>   Type: AWS::Serverless::Function<br/>   Properties:<br/>      CodeUri: auto-web/<br/>      Handler: app.lambdaHandler<br/>      Runtime: nodejs8.10<br/>      Events:<br/>         CronEvent:<br/>         Type: Schedule<br/>         Properties:<br/>            Schedule:<br/>               cron(0 17 ? * FRI *)</span></pre><p id="ae36" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里的cron表情基本上每周五下午5点左右就会火。幸运的是，SAM模板是CloudFormation模板的扩展，因此如果需要，我们可以轻松地包含新的资源以及添加参数，我更希望cron计划是可以作为参数指定的东西。因此，让我们添加一个新参数，我们可以用它来指定cron调度，而不是硬编码它。就在资源部分的上方，我们可以添加一个参数部分，它允许我们在CloudFormation开始提供堆栈时指定值。</p><pre class="je jf jg jh fd lu lv lw lx aw ly bi"><span id="32b8" class="lz jv hi lv b fi ma mb l mc md">Parameters:<br/>   CronExpression:<br/>      Type: String<br/>      Default: cron(0 17 ? * FRI *)</span><span id="dbf2" class="lz jv hi lv b fi me mb l mc md">Resources:<br/>   AutoWebFunction:<br/>   Type: AWS::Serverless::Function<br/>   Properties:<br/>      CodeUri: auto-web<br/>      Handler: app.lambdaHandler<br/>      Runtime: nodejs8.10<br/>      Events:<br/>         CronEvent:<br/>         Type: Schedule<br/>         Properties:<br/>            Schedule: Ref: CronExpression</span></pre><p id="5cff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在最后一部分是secrets，这意味着是时候添加SecretsManager资源了。正如我前面提到的，SAM模板实际上是CloudFormation模板的扩展，因此添加SecretsManager资源的方式与在CloudFormation中的方式相同。SecretsManager有一个将数据保存为JSON对象的惯例，所以如果我们要保存用户名和密码，我们应该使用JSON字符串来这样做。所以我们可能需要一个类似。</p><pre class="je jf jg jh fd lu lv lw lx aw ly bi"><span id="1b06" class="lz jv hi lv b fi ma mb l mc md">SecretString:<br/>   '{"username":"user","password":"secret"}'</span></pre><p id="be63" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我认为用户名和密码也不是我想在模板中固定的东西，所以我更愿意把它们作为参数。</p><pre class="je jf jg jh fd lu lv lw lx aw ly bi"><span id="5476" class="lz jv hi lv b fi ma mb l mc md">Parameters:<br/>   CronExpression:<br/>      Type: String<br/>      Default: cron(0 17 ? * FRI *)<br/>   Password:<br/>      NoEcho: true<br/>      Type: String<br/>      Default: password<br/>   UserName:<br/>      NoEcho: true<br/>      Type: String<br/>      Default: username</span></pre><p id="73c0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在参数中，我使用了<a class="ae jt" href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/parameters-section-structure.html" rel="noopener ugc nofollow" target="_blank"> NoEcho: true </a>它的作用是让AWS知道，当提示输入值给模板时，它应该用星号(*)屏蔽这些值。掩盖密码之类的秘密是很有用的。</p><p id="e557" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要添加SecretsManager资源，现在我们可以在AutoWebFunction下添加另一个资源。我们将把它命名为“autowebsecrets ”,这在以后会很重要。</p><pre class="je jf jg jh fd lu lv lw lx aw ly bi"><span id="5df3" class="lz jv hi lv b fi ma mb l mc md">Resources:<br/># the AutoWebFunction goes here<br/>   AutoWebSecrets:<br/>      Type: AWS::SecretsManager::Secret<br/>      Properties:<br/>         Name: autowebsecrets<br/>         SecretString:<br/>            Fn::Join:<br/>            - ''<br/>            - - '{"username":"'<br/>              - Ref: UserName<br/>              - '","password":"'<br/>              - Ref: Password<br/>              - '"}'</span></pre><p id="fc9b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在模板中，我们使用了云形成函数<a class="ae jt" href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/intrinsic-function-reference-join.html" rel="noopener ugc nofollow" target="_blank"> Fn::Join </a>。这是一个CloudFormation函数，允许我们将一组值附加到一个值中，由指定的分隔符分隔。如果分隔符是空字符串，则值集在没有分隔符的情况下连接在一起。在这种情况下，我们只是用它来做简单的字符串连接，以便为SecretString形成有效的JSON值。</p><p id="ec26" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，需要注意的一件重要事情是，运行该函数的角色需要读取机密的权限。幸运的是，在AWS SAM中有专门为这类事情构建的<a class="ae jt" href="https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-policy-templates.html" rel="noopener ugc nofollow" target="_blank">策略模板</a>，并且有一个专门用于此目的的<a class="ae jt" href="https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-policy-template-list.html#secrets-manager-get-secret-value-policy" rel="noopener ugc nofollow" target="_blank">AWSSecretsManagerGetSecretValuePolicy</a>。我们现在需要更改AutoWebFunction的资源声明，以包含此策略声明。</p><pre class="je jf jg jh fd lu lv lw lx aw ly bi"><span id="2e9d" class="lz jv hi lv b fi ma mb l mc md">Resources:<br/>   AutoWebFunction:<br/>      Type: AWS::Serverless::Function<br/>      Properties:<br/>         Policies:<br/>            - AWSSecretsManagerGetSecretValuePolicy:<br/>                SecretArn:<br/>                  !Ref AutoWebSecrets<br/>         CodeUri: auto-web<br/>         Handler: app.lambdaHandler<br/>         Runtime: nodejs8.10<br/>         Events:<br/>            CronEvent:<br/>               Type: Schedule<br/>               Properties:<br/>                  Schedule:<br/>                     Ref: CronExpression<br/>   AutoWebSecrets:<br/>      Type: AWS::SecretsManager::Secret<br/>      Properties:<br/>         Name: autowebsecrets<br/>         SecretString:<br/>            Fn::Join:<br/>            - ''<br/>            - - '{"username":"'<br/>              - Ref: UserName<br/>              - '","password":"'<br/>              - Ref: Password<br/>              - '"}'</span></pre><p id="c1d1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">模板提供了秘密并授予角色足够的权限来读取秘密，现在我们可以将集成编码到AWS SecretsManager中。要做se，我们需要添加<a class="ae jt" href="https://github.com/aws/aws-sdk-js" rel="noopener ugc nofollow" target="_blank"> aws-sdk-js </a>库。所以回到工作目录中的auto-web子文件夹，安装<a class="ae jt" href="https://github.com/aws/aws-sdk-js" rel="noopener ugc nofollow" target="_blank"> aws-sdk </a> npm库。</p><pre class="je jf jg jh fd lu lv lw lx aw ly bi"><span id="1c2f" class="lz jv hi lv b fi ma mb l mc md">cd auto-web<br/>npm install aws-sdk </span></pre><p id="e9c4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">aws-sdk 让我们可以访问aws中可能需要的大部分资源，包括SecretsManager。要访问SecretsManager，我们必须首先创建一个客户端。一旦我们有了客户端，我们就可以使用我们之前在模板中指定的名称值作为SecretId，在我们的例子中是“autowebsecrets”。需要注意的是AWS。SecretsManager需要一个区域请确保该区域是您要部署SAM模板的区域，因为这是您将用来设置资源的区域。在。/auto-web/app.js文件:</p><pre class="je jf jg jh fd lu lv lw lx aw ly bi"><span id="c53c" class="lz jv hi lv b fi ma mb l mc md">....<br/>const AWS = require('aws-sdk')<br/>const client = new AWS.SecretsManager({ region: 'eu-west-1' })<br/>....<br/>....<br/>....</span></pre><p id="79fd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">客户端对象有<a class="ae jt" href="https://docs.aws.amazon.com/secretsmanager/latest/apireference/API_GetSecretValue.html" rel="noopener ugc nofollow" target="_blank"> getSecretValue </a>函数，我们可以用它从秘密管理器中获取秘密。这个函数不返回一个承诺，而是将回调函数作为第二个参数，当调用完成时，您可以期望调用这个回调函数。回调函数接受两个参数，第一个是调用失败时的错误对象，第二个是包含重要属性SecretString的数据对象，这是一个字符串形式的解密JSON值，就像我们在模板中指定的一样。鉴于使用回调函数的尴尬，我决定创建一个助手函数，允许我通过使用Promise对象继续使用await async。</p><pre class="je jf jg jh fd lu lv lw lx aw ly bi"><span id="d915" class="lz jv hi lv b fi ma mb l mc md">function getSecret(secretId) {<br/>   return new Promise((resolve, reject) =&gt; {<br/>      client.getSecretValue({ SecretId: secretId }, (err, data) =&gt; {<br/>         if (err) {<br/>            reject(err)<br/>            return<br/>         }<br/>         try {<br/>            let result = JSON.parse(data.SecretString)<br/>            resolve(result)<br/>         } catch (e) {<br/>            reject(e)<br/>         }<br/>      })<br/>   })<br/>};</span></pre><p id="203b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">基本上，这里发生的事情是，这个函数返回一个Promise对象，它允许我在一个异步函数中调用await，如果回调出错或者抛出异常，我们会拒绝这个函数，否则我们会从data和JSON中获取SecretString。解析(因为SecretString将采用JSON格式)。使用解析后的对象，我们将其作为承诺的解析返回。这允许我在异步函数中等待结果。</p><pre class="je jf jg jh fd lu lv lw lx aw ly bi"><span id="381e" class="lz jv hi lv b fi ma mb l mc md">....<br/>....<br/>....<br/>exports.lambdaHandler = async (event, context) =&gt; {<br/>try {<br/>   const autowebsecrets = await getSecret('autowebsecrets')<br/>   const username = autowebsecrets.username<br/>   const password = autowebsecrets.password<br/>....<br/>....<br/>....</span></pre><p id="994a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如我前面提到的，中的secretId需要是我们在模板中提供的SecretsManager秘密的名称，在我们的例子中是“autowebsecrets”。最终的脚本应该是这样的:</p><pre class="je jf jg jh fd lu lv lw lx aw ly bi"><span id="a7ea" class="lz jv hi lv b fi ma mb l mc md">const chromium = require('chrome-aws-lambda')<br/>const AWS = require('aws-sdk')<br/>const client = new AWS.SecretsManager({ region: 'eu-west-1' })</span><span id="f252" class="lz jv hi lv b fi me mb l mc md">let browser = null<br/>let page = null</span><span id="da31" class="lz jv hi lv b fi me mb l mc md">function getSecret(secretId) {<br/>   return new Promise((resolve, reject) =&gt; {<br/>      client.getSecretValue({ SecretId: secretId }, (err, data) =&gt; {<br/>         if (err) {<br/>            reject(err)<br/>            return<br/>         }<br/>         try {<br/>            let result = JSON.parse(data.SecretString)<br/>            resolve(result)<br/>         } catch (e) {<br/>            reject(e)<br/>         }<br/>      })<br/>   })<br/>};</span><span id="fa9c" class="lz jv hi lv b fi me mb l mc md">exports.lambdaHandler = async (event, context) =&gt; {<br/>   try {<br/>      const autowebsecrets = await getSecret('autowebsecrets')<br/>      const username = autowebsecrets.username<br/>      const password = autowebsecrets.password<br/>      <br/>      browser = await chromium.puppeteer.launch({<br/>         args: chromium.args,<br/>         defaultViewport: chromium.defaultViewport,<br/>         executablePath: await chromium.executablePath,<br/>         headless: chromium.headless<br/>      })<br/>      page = await browser.newPage()<br/>      <br/>      const navigationPromise = page.waitForNavigation()<br/>      await page.goto("https://www.example.com", { waitUntil: 'networkidle2' })<br/>     <br/>      await page.setViewport({ width: 1920, height: 1001 })<br/>      <br/>      await navigationPromise<br/>    <br/>      const footerleft = await page.waitForSelector('body &gt; div &gt; p:nth-child(2)')<br/>      const textContent = await (await footerleft.getProperty('textContent')).jsonValue()<br/>      <br/>      return { username, password, textContent }</span><span id="2d95" class="lz jv hi lv b fi me mb l mc md">   } catch (err) {<br/>      console.log(err)<br/>      return err<br/>   } finally {<br/>      if (page) {<br/>         await page.close()<br/>      }<br/>      if (browser) {<br/>         await browser.disconnect()<br/>      }<br/>   }<br/>}</span></pre><p id="ff3d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">经过所有这些艰苦的工作，我们终于可以部署了。在我们部署之前，需要注意的是，即使我们使用的是<a class="ae jt" href="https://github.com/alixaxel/chrome-aws-lambda" rel="noopener ugc nofollow" target="_blank"> chrome-aws-lambda </a>浏览器，运行一个简单的示例页面也很容易占用430 MB的运行内存。因此，如果我们希望我们的函数正常工作，我们就必须为lambda函数的运行提供足够的内存。这就是为什么我们在模板的<a class="ae jt" href="https://github.com/awslabs/serverless-application-model/blob/master/versions/2016-10-31.md#globals-section" rel="noopener ugc nofollow" target="_blank">全局变量</a>部分添加了一个内存大小。当我们在<a class="ae jt" href="https://github.com/awslabs/serverless-application-model/blob/master/versions/2016-10-31.md#globals-section" rel="noopener ugc nofollow" target="_blank">全局</a>部分时，我还会将超时增加到900秒，这是可以给出的最高值，因为lambda的最大超时是15分钟。这应该给我们足够的时间来运行该功能，以防网页由于任何原因而变慢。</p><pre class="je jf jg jh fd lu lv lw lx aw ly bi"><span id="e6d2" class="lz jv hi lv b fi ma mb l mc md">Globals:<br/>   Function:<br/>      Timeout: 900<br/>      MemorySize: 512</span></pre><p id="d35c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了进行部署，我们需要首先创建S3桶。我们需要一个“S3 bucket ”,在部署任何东西之前，我们可以上传打包为ZIP的Lambda函数。Lambda基本上会将包提取到一个容器中，然后执行模板中指定的函数。因此，使用AWS cli:</p><pre class="je jf jg jh fd lu lv lw lx aw ly bi"><span id="721b" class="lz jv hi lv b fi ma mb l mc md">aws s3 mb s3://BUCKET_NAME</span></pre><p id="241f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">其中，存储桶名称是您帐户的唯一存储桶名称。为了打包解决方案，我们使用sam package命令。</p><pre class="je jf jg jh fd lu lv lw lx aw ly bi"><span id="8ab2" class="lz jv hi lv b fi ma mb l mc md">sam package --template-file template.yaml --s3-bucket BUCKET_NAME --output-template-file template-out.yaml</span></pre><p id="065f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">同样，BUCKET_NAME是您帐户的唯一存储桶。sam package命令基本上压缩了您在CodeUri文件夹中为模板中的函数指定的文件夹的内容，它为该压缩文件指定了一个唯一的名称，并将其上传到S3。如果您仔细查看template-out.yaml文件，您会注意到CodeUri的值与template.yaml中的值不同，它现在有一个有效的S3://BUCKET _ NAME/random number URL。sam package命令足够智能，可以自动计算出该属性的正确值，确保您的模板有正确的值供CloudFormation使用。</p><p id="3b75" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">随着代码的上传和模板的更新，我们可以将应用程序部署到AWS CloudFormation。要使用的模板文件应该是从sam package命令输出的文件(template-out.yaml)。栈名可以是您喜欢的任何名称，只要它符合栈名约定。您的区域需要是您希望部署堆栈的特定区域，如果您还记得之前在SecretsManager代码中指定了一个区域，请确保该值是相同的值，否则您的代码将无法工作。capabilities是AWS CloudFormation创建特定堆栈之前必须指定的功能列表。由于该模板将代表您提供IAM角色，这意味着它将影响您的帐户的安全性，因此您需要指定CAPABILITY_IAM来基本上给予它这样做的权限。</p><pre class="je jf jg jh fd lu lv lw lx aw ly bi"><span id="8404" class="lz jv hi lv b fi ma mb l mc md">sam deploy --template-file template-out.yaml --stack-name auto-web --capabilities CAPABILITY_IAM --region eu-west-1</span></pre><p id="8b16" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们的功能已经完成，应该按照cron计划执行了。如果您需要更改参数值，您可以简单地更改CloudFormation堆栈并再次启动配置。如果你需要测试，你可以转到Lambda部分并启动一个函数，它应该使用你在模板中指定的默认值。</p><h1 id="83cd" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">结论</h1><p id="2bbe" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">当我第一次着手这项工作时，我认为这将是一件简单而直接的事情。很快我发现了我未知的未知。对我来说，这强调了真正投入和行动的重要一课，直到那时你才真正知道所涉及的努力。这里有一个链接，链接到我在Github中的代码。</p></div></div>    
</body>
</html>