<html>
<head>
<title>Preparing your Django Application for Google Cloud Run</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为Google Cloud Run准备Django应用程序</h1>
<blockquote>原文：<a href="https://medium.com/swlh/preparing-your-django-application-for-google-cloud-run-7c8cb7b7464b?source=collection_archive---------6-----------------------#2019-05-20">https://medium.com/swlh/preparing-your-django-application-for-google-cloud-run-7c8cb7b7464b?source=collection_archive---------6-----------------------#2019-05-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="2d00" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最近谷歌在他们的云平台上发布了一款名为<a class="ae jd" href="https://cloud.google.com/run/" rel="noopener ugc nofollow" target="_blank"> Cloud Run </a>的新产品。该产品有可能减少开发人员的工作量和早期开发实验成本，因为它弥合了无服务器云功能和kubernetes引擎之间的差距:无服务器为您带来了在云上运行简单工作负载的按使用付费，而Kubernetes为您带来了运行自定义映像的协调工作负载。Cloud Run为您提供了两全其美的优势:在一个可扩展至零的系统上运行您的定制Docker映像和所有内置库:不再有设置基础架构的麻烦，也不再需要为闲置的虚拟机付费。</p><p id="2c93" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你只需要满足几个条件:</p><ol class=""><li id="ebfa" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated">您的应用程序必须响应HTTP调用。</li><li id="a4fe" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">你的应用程序必须是完全无状态的。与kubernetes引擎不同，您不能将卷附加到您的工作负载。所有持久的、非静态的数据都必须在容器之外。</li><li id="dd85" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">显然，你的应用程序必须是集装箱化的。</li><li id="7250" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">您的容器应该侦听Cloud Run可以在启动时定义的端口上的流量。因此，当启动容器内的web服务器时，确保它监听由<code class="du js jt ju jv b">PORT</code>环境变量定义的端口。</li></ol><p id="20b1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一个非常好的用例是个人主页。它们基本上是网络上的名片，不需要存在，除非有人在看它们。</p><p id="31f7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在下面的例子中，我们将使用Django-CMS和Postgres数据库创建个人主页，并对其进行修改，使其在云上运行，数据库托管在云SQL上，所有媒体和静态图像托管在GCP存储桶上。这些说明假设您熟悉云SQL，因此我们不会详细介绍最基本的步骤，尽管我会介绍一些以前让我犯过错误的问题。</p><h1 id="b948" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">当它和歌剧相遇</h1><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es ku"><img src="../Images/0bb281b093aef3fe94146a78b67178ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*16zOJVG1nQ2RpOUZ"/></div></div><figcaption class="lg lh et er es li lj bd b be z dx">Photo by <a class="ae jd" href="https://unsplash.com/@gwundrig?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Manuel Nägeli</a> on <a class="ae jd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="37c4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我自学Django的方法之一是用Django-CMS为我的朋友制作主页。起初，由于我对服务器和nginx一无所知，我在<a class="ae jd" href="https://djangoeurope.com/" rel="noopener ugc nofollow" target="_blank"> Djangoeurope </a>上建立了网站:这是一个非常好的Django托管网站，有敬业和乐于助人的员工，价格也非常友好。</p><p id="b883" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">1.5年前，当我的歌剧歌手朋友<a class="ae jd" href="http://kristianlindroos.fi/en/biography/" rel="noopener ugc nofollow" target="_blank"> Kristian Lindroos </a>需要一个主页时，我决定利用这个机会再次学习一些新东西:nginx和AWS上的主机。不幸的是，在我意识到这一点之前，我在AWS上的试用期结束了，我不得不为T2.micro实例买单。</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div class="er es lk"><img src="../Images/31812e8fcba3741bf23a8c9c47f493fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1116/format:webp/1*k1hygTE25cIHvNIA5xwDyg.png"/></div><figcaption class="lg lh et er es li lj bd b be z dx">Kristian preparing for a performance, photo by Markku Pihlaja.</figcaption></figure><p id="2941" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当谷歌宣布Cloud Run时，我意识到这将是托管网站的最佳地点:我总是在GCP上运行一个Cloud SQL实例，用于个人项目，这样我就可以把Postgres数据库放在那里，其他一切都在Cloud Run上运行。</p><p id="75ec" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了让我们的应用程序在云上运行，我们需要完成以下步骤。</p><ol class=""><li id="6a36" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated">通过从启动脚本中删除所有耗时的任务来减少启动时间。</li><li id="e964" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">从本地数据库切换到云SQL。</li><li id="897c" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">让云运行服务于应用。</li><li id="b25c" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">从磁盘存储切换到存储桶。</li><li id="ff27" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">让云运行服务于正确域下的应用。</li></ol><h1 id="95fe" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">减少启动时间</h1><p id="1017" class="pw-post-body-paragraph if ig hi ih b ii ll ik il im lm io ip iq ln is it iu lo iw ix iy lp ja jb jc hb bi translated">Django应用程序的一个非常常见的惯例是将所有东西都塞进启动脚本:首先运行迁移，然后运行collectstatic，然后启动应用服务器。事实上，我的<strong class="ih lq"> run.sh </strong>启动文件看起来是这样的:</p><pre class="kv kw kx ky fd lr jv ls lt aw lu bi"><span id="9844" class="lv jx hi jv b fi lw lx l ly lz"><strong class="jv lq">#!/bin/bash<br/><br/></strong><em class="ma">python </em>manage.py migrate<br/><br/><em class="ma">python </em>manage.py collectstatic<br/><br/># Start the server<br/><em class="ma">/usr/local/bin/gunicorn </em>kristian.wsgi:application -w 2 -b :$PORT</span></pre><p id="46ca" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您使用的是VM，并且您的应用程序一直处于运行状态，那么这种方法是可行的。有了云运行，您的应用程序每次在一段时间内没有收到流量时都会从头开始运行，并且您不希望您的用户等待迁移和收集静态文件。特别是当我们切换到使用bucket作为存储后端时，复制单个文件会慢得令人痛苦:即使是运行<strong class="ih lq">python manage . py collect static</strong>的这个简单的Django-CMS应用程序也要花费2分多钟！我们将注释掉这两行，因此我们的启动脚本如下所示:</p><pre class="kv kw kx ky fd lr jv ls lt aw lu bi"><span id="b4b7" class="lv jx hi jv b fi lw lx l ly lz"><strong class="jv lq">#!/bin/bash<br/><br/></strong><em class="ma"># python </em>manage.py migrate<br/><br/><em class="ma"># python </em>manage.py collectstatic<br/><br/># Start the server<br/><em class="ma">/usr/local/bin/gunicorn </em>kristian.wsgi:application -w 2 -b :$PORT</span></pre><h1 id="9962" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">从本地数据库切换到云SQL</h1><h2 id="bdf9" class="lv jx hi bd jy mb mc md kc me mf mg kg iq mh mi kk iu mj mk ko iy ml mm ks mn bi translated">创建云SQL实例并激活云SQL代理</h2><p id="e278" class="pw-post-body-paragraph if ig hi ih b ii ll ik il im lm io ip iq ln is it iu lo iw ix iy lp ja jb jc hb bi translated">首先，我们需要创建一个云SQL实例。简单明了的说明可以在官方文档页面<a class="ae jd" href="https://cloud.google.com/sql/docs/postgres/quickstart" rel="noopener ugc nofollow" target="_blank">这里</a>找到。<br/> <strong class="ih lq"> Pro提示:</strong>在撰写本文时，Cloud Run仅在<strong class="ih lq"> us-central1 </strong>地区可用，因此请将您的数据库实例放在那里。一开始我没有，后来证明是个错误。稍后会详细介绍。</p><p id="fefb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，我们需要在您的云SQL实例上创建一个新用户。为了简单起见，我们可以使用与原始设置相同的用户名和密码，一旦一切正常，我们就可以更改它们。</p><p id="3786" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">之后，我们需要让云SQL代理从我们的本地设置(最终是云运行)连接到数据库。我们需要执行以下步骤中的<a class="ae jd" href="https://cloud.google.com/sql/docs/postgres/quickstart-proxy-test" rel="noopener ugc nofollow" target="_blank">:</a></p><ol class=""><li id="85af" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated">启用云SQL API以启用远程连接。</li><li id="3520" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">创建一个服务帐户，并授予其云SQL客户端权限。</li><li id="bdb7" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">下载服务账户凭证文件，姑且称之为<strong class="ih lq"> db-proxy.json </strong>。</li><li id="a2bb" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">下载代理。</li><li id="01a3" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">使代理可执行。</li><li id="dc83" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">使用正确的实例连接名称和正确的端口号启动代理。</li></ol><p id="192c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">实例连接名称可以在实例的overview选项卡上找到，并且将始终采用以下形式</p><pre class="kv kw kx ky fd lr jv ls lt aw lu bi"><span id="389b" class="lv jx hi jv b fi lw lx l ly lz">PROJECT_ID:REGION:INSTANCE_NAME</span></pre><p id="b69f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">至于端口，我们可以使用任何可用的东西。我已经有Postgres在本地运行，所以<strong class="ih lq"> 5432 </strong>已经被占用，但<strong class="ih lq"> 6543 </strong>工作正常。运行代理的命令如下所示:</p><pre class="kv kw kx ky fd lr jv ls lt aw lu bi"><span id="a78d" class="lv jx hi jv b fi lw lx l ly lz">./cloud_sql_proxy -instances=&lt;PROJECT_ID:REGION:INSTANCE_NAME&gt;=tcp:6543 -credentials=/path/to/credentials/db-proxy.json</span></pre><p id="6f5c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们运行该命令，然后进入下一部分。</p><h2 id="7293" class="lv jx hi bd jy mb mc md kc me mf mg kg iq mh mi kk iu mj mk ko iy ml mm ks mn bi translated">创建和填充数据库</h2><p id="2e61" class="pw-post-body-paragraph if ig hi ih b ii ll ik il im lm io ip iq ln is it iu lo iw ix iy lp ja jb jc hb bi translated">接下来，我们需要在云SQL上创建一个新的数据库。不幸的是，我们不能为此使用Cloud SQL Google Cloud Console，因为数据库所有权将自动分配给<strong class="ih lq"> postgres </strong>，这将弄乱Django所需的所有表和序列权限。相反，我们可以使用我们的open Cloud SQL代理连接来连接到我们的数据库实例并创建新的数据库。</p><p id="f007" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">运行以下命令，并在系统提示时输入postgres密码:</p><pre class="kv kw kx ky fd lr jv ls lt aw lu bi"><span id="9b06" class="lv jx hi jv b fi lw lx l ly lz">psql -U postgres -h 127.0.0.1 -p 6543 -d postgres</span></pre><p id="7ac9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，将之前创建的用户授予postgres并创建数据库</p><pre class="kv kw kx ky fd lr jv ls lt aw lu bi"><span id="97a4" class="lv jx hi jv b fi lw lx l ly lz">-- necessary so postgres has permission to set your user as owner.<br/>GRANT &lt;USERNAME&gt; TO postgres;</span><span id="417e" class="lv jx hi jv b fi mo lx l ly lz">CREATE DATABASE &lt;DATABASE_NAME&gt; OWNER &lt;USERNAME&gt;;</span></pre><p id="ba24" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">完成了。你猜怎么着？现在我们准备运行我们的第一个测试！我让所有东西都在本地运行，并且它连接到本地postgres服务器上的一个测试数据库。现在我只需要在我的<strong class="ih lq">设置中将端口号从5432更改为6543。py</strong>和Django应该可以连接到新的数据库。</p><p id="bf80" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">测试的一个好方法是运行<strong class="ih lq">python manage . py show migrations</strong>。事实上，因为数据库是空的，所以我看到了大量尚未运行的迁移:</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div class="er es mp"><img src="../Images/2ce68df0b45b7cfaf56b1021f18a5ad8.png" data-original-src="https://miro.medium.com/v2/resize:fit:906/format:webp/1*88ZBcTYpzYBpup_CVgfpUg.png"/></div></figure><p id="c3d4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下一步是将我们的数据库复制到云SQL。我已经使用<strong class="ih lq"> pg_dump </strong>转储了数据库，所以现在我可以使用仍然打开的代理连接来恢复数据库。因为我们使用重定向来填充数据库，所以不能让psql提示我们输入密码。我们可以通过在命令开始时将密码设置为环境变量来解决这个问题:</p><pre class="kv kw kx ky fd lr jv ls lt aw lu bi"><span id="aa07" class="lv jx hi jv b fi lw lx l ly lz">PGPASSWORD=&lt;PASSWORD&gt; psql -U &lt;USERNAME&gt; -h 127.0.0.1 -p 6543 -d &lt;DATABASE_NAME&gt; &lt; dump.sql</span></pre><p id="4ec4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">运行<strong class="ih lq">python manage . py show migrations</strong>让我们看到导入成功了！</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div class="er es mq"><img src="../Images/493545dc643d529b899704f32e230966.png" data-original-src="https://miro.medium.com/v2/resize:fit:928/format:webp/1*PC-VApARtBxlm2ALnjGIQg.png"/></div></figure><h1 id="8220" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">让云运行服务于应用</h1><p id="c42d" class="pw-post-body-paragraph if ig hi ih b ii ll ik il im lm io ip iq ln is it iu lo iw ix iy lp ja jb jc hb bi translated">我坚信定期测试。也就是说，每当从事一个项目并准备好一个阶段时，看到您的应用程序在该阶段的限制内工作得如何总是好的。例如，现在如果我们在Cloud Run上运行我们的应用程序，我们应该能够在某种程度上中断的状态下启动它:应用程序应该工作，HTML应该存在，静态文件也应该存在，但是我们会丢失所有的媒体文件，并且应该不可能上传任何新的媒体文件。</p><p id="1657" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了能够测试这一点，我们需要执行以下操作:</p><ol class=""><li id="e7ce" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated">在项目中启用云运行。</li><li id="0bc2" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">将云SQL代理嵌入到我们的应用程序中。</li><li id="c2f0" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">授予云运行服务访问数据库实例的权限。</li><li id="81fd" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">构建docker图像，并将其上传到我们项目的Google容器库中。</li><li id="5b95" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">创建使用我们映像的云运行服务。</li></ol><p id="0219" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第一步很简单。在云控制台中，找到“云运行”选项卡，然后单击“尝试云运行”。</p><p id="307f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在第二步中，我们需要让Dockerfile执行我们在本地运行应用程序时执行的相同步骤:下载云SQL代理并将其转换为可执行文件。为此，我们将修改docker文件。修改之前，docker文件如下所示:</p><pre class="kv kw kx ky fd lr jv ls lt aw lu bi"><span id="3d53" class="lv jx hi jv b fi lw lx l ly lz">FROM python:3.6.4<br/><br/>RUN apt-get install bash<br/>RUN mkdir -p /usr/src/app<br/>WORKDIR /usr/src/app<br/>COPY requirements.txt /usr/src/app/<br/>RUN pip install --no-cache-dir -r requirements.txt<br/><br/>RUN ln -sf /dev/stdout /var/log/access.log &amp;&amp; \<br/>    ln -sf /dev/stderr /var/log/error.log<br/><br/>ADD . /usr/src/app<br/>CMD ["./run.sh"]</span></pre><p id="df9e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们只需添加两行，工作就完成了。</p><pre class="kv kw kx ky fd lr jv ls lt aw lu bi"><span id="2f33" class="lv jx hi jv b fi lw lx l ly lz">FROM python:3.6.4<br/><br/>RUN apt-get install bash<br/>RUN mkdir -p /usr/src/app<br/>WORKDIR /usr/src/app<br/>COPY requirements.txt /usr/src/app/<br/>RUN pip install --no-cache-dir -r requirements.txt<br/><br/># download the cloudsql proxy<br/>RUN wget https://dl.google.com/cloudsql/cloud_sql_proxy.linux.amd64 -O /usr/src/app/cloud_sql_proxy</span><span id="5bf7" class="lv jx hi jv b fi mo lx l ly lz"># make cloudsql proxy executable<br/>RUN chmod +x /usr/src/app/cloud_sql_proxy<br/><br/>RUN ln -sf /dev/stdout /var/log/access.log &amp;&amp; \<br/>    ln -sf /dev/stderr /var/log/error.log<br/><br/>ADD . /usr/src/app<br/>CMD ["./run.sh"]</span></pre><p id="e963" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有几个选项可以完成第三步，为云运行提供足够的权限:</p><ol class=""><li id="1bd5" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated">将之前下载的<strong class="ih lq"> db-proxy.json </strong>放入容器中，将云SQL代理作为一个单独的进程运行，使用代理命令中定义的端口进行连接(这种方法的功劳归于<a class="ae jd" rel="noopener" href="/@petomalina"> <strong class="ih lq">彼得·马利纳</strong> </a> <strong class="ih lq"> </strong>和<a class="ae jd" rel="noopener" href="/@petomalina/connecting-to-cloud-sql-from-cloud-run-dcff2e20152a">这篇中帖</a>)。</li><li id="63e3" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">授予云运行服务帐户<strong class="ih lq">云SQL客户端</strong>权限，作为单独的进程运行云SQL代理，使用代理命令中定义的端口进行连接。</li><li id="1b2c" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">即将推出的一项功能将为Cloud Run带来直接的云SQL支持。这将允许直接连接到代理的unix套接字，该代理可能会在您的容器之外运行，这将进一步缩短您的冷启动时间。<strong class="ih lq">更新</strong>:这个功能刚刚进入测试版，如何使用的说明可以在<a class="ae jd" href="https://cloud.google.com/run/docs/configuring/connect-cloudsql" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</li></ol><p id="8166" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">就我个人而言，我更喜欢第一个选项，尤其是现在我是云运行的新手。如果我们将凭证放在容器中，我们应该能够在Cloud Run上运行容器之前从本地设置中运行容器。这样，我们可以在部署到云运行之前立即发现任何配置错误，而不是部署它，看到应用程序失败，然后试图找出原因是云运行还是我们的配置。在对云运行更加熟悉之后，我会选择第二个选项，一旦第三个选项可用，我肯定会选择第三个选项。</p><p id="793f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但首先要做的是。让我们在我们的应用程序根目录中创建一个名为secrets的文件夹，并将<strong class="ih lq"> db-proxy.json </strong>文件添加到其中。然后，让我们打开之前编辑的<strong class="ih lq"> run.sh </strong>文件，并添加启动代理的命令。</p><pre class="kv kw kx ky fd lr jv ls lt aw lu bi"><span id="8183" class="lv jx hi jv b fi lw lx l ly lz"><strong class="jv lq">#!/bin/bash<br/><br/></strong><em class="ma"># python </em>manage.py migrate</span><span id="649e" class="lv jx hi jv b fi mo lx l ly lz"><em class="ma"># python </em>manage.py collectstatic</span><span id="d11b" class="lv jx hi jv b fi mo lx l ly lz"><em class="ma">./cloud_sql_proxy </em>-instances=&lt;PROJECT_ID:REGION:INSTANCE_NAME&gt;=tcp:6543 -credential_file=secrets/db-proxy-central.json &amp;</span><span id="da10" class="lv jx hi jv b fi mo lx l ly lz"># wait for the proxy to spin up<br/><em class="ma">sleep </em>1</span><span id="9a1a" class="lv jx hi jv b fi mo lx l ly lz"># Start the server<br/><em class="ma">/usr/local/bin/gunicorn </em>kristian.wsgi:application -w 2 -b :$PORT</span></pre><p id="93e7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在第四步中，我们只需要导航到包含docker文件的目录，并运行构建和推送命令:</p><pre class="kv kw kx ky fd lr jv ls lt aw lu bi"><span id="a45a" class="lv jx hi jv b fi lw lx l ly lz">docker build -t gcr.io/&lt;YOUR_PROJECT_ID&gt;/&lt;YOUR_IMAGE_NAME&gt;:latest -f Dockerfile .<br/>docker push gcr.io/&lt;YOUR_PROJECT_ID&gt;/&lt;YOUR_IMAGE_NAME&gt;:latest</span></pre><p id="6808" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是等一下！既然我们已经将代理和凭证添加到了我们的共同容器中，我们可以在尝试部署之前进行本地测试。一旦构建操作完成，我们就可以用</p><pre class="kv kw kx ky fd lr jv ls lt aw lu bi"><span id="378c" class="lv jx hi jv b fi lw lx l ly lz">docker run -e “PORT=8888” -p 8888:8888 gcr.io/&lt;YOUR_PROJECT_ID&gt;/&lt;YOUR_IMAGE_NAME&gt;:latest</span></pre><p id="d678" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意，我们将PORT环境变量传递给容器，这样服务器就知道要监听哪个端口。这与云运行执行的操作相同。通过导航到127.0.0.1:8888，我们可以确认应用程序确实在运行，静态文件和图像可以工作，但媒体文件不能。大获成功！</p><p id="f646" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，让我们将我们有些不完整的映像部署到Cloud Run。再次导航到“云运行”选项卡，然后选择“创建服务”</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div class="er es mr"><img src="../Images/447c05686596582db6b5eb97830b8ee5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/1*Nyfx5fLufHq5hhNR97u-Cg.png"/></div></figure><p id="1cd3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于我们已经在上一步中推送了图像，因此可以在第一个下拉列表中选择它。然后，我们给我们的图像一个名称，并允许未经验证的调用，因为我们正在部署一个网站。完成后，我们单击创建。</p><p id="034c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">过了一会儿，我们看到服务变绿了，可以通行了。下面是Cloud Run的一些最棒的功能。它会自动为我们生成一个URL，甚至会让我们为它加密https证书。太棒了。</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es ms"><img src="../Images/4b648f180043c6c58778f83bfffaf855.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WIadJA9pMNGVrSqH1GkVSA.png"/></div></div></figure><p id="2f4e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们只需点击网址就可以看到我们美丽的…内部服务器错误？让我们检查一下日志，看看哪里出了问题。我们不需要滚动很远就能找到罪魁祸首:</p><pre class="kv kw kx ky fd lr jv ls lt aw lu bi"><span id="a827" class="lv jx hi jv b fi lw lx l ly lz">Invalid HTTP_HOST header: ‘django-cms-wfyujfe4wa-uc.a.run.app’. You may need to add ‘django-cms-wfyujfe4wa-uc.a.run.app’ to ALLOWED_HOSTS.</span></pre><p id="e5ca" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih lq"> settings.py </strong>文件中的ALLOWED_HOSTS已经是这样了</p><pre class="kv kw kx ky fd lr jv ls lt aw lu bi"><span id="10f8" class="lv jx hi jv b fi lw lx l ly lz">ALLOWED_HOSTS = [os.environ.get('CURRENT_HOST', 'localhost'), '127.0.0.1', 'kristianlindroos.fi',                 'www.kristianlindroos.fi', ]</span></pre><p id="65d3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们只需要将自动生成的URL作为一个CURRENT_HOST环境变量来传递，就万事大吉了。首先让我们复制自动生成的URL，然后点击<strong class="ih lq">部署新版本</strong>来更新我们的设置。这将显示一些可配置的选项以及添加环境变量的选项，这是我们要做的，然后单击“deploy”。</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div class="er es mt"><img src="../Images/59062c54493b892c4d49d9a108da128b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1142/format:webp/1*hTPjKUZ1mX3MTVQm5TrjzA.png"/></div></figure><p id="aeb1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">大约十秒钟后，过程完成，我们可以重新加载页面，它的工作！</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es mu"><img src="../Images/e974b336cf50a5f111d99ee23d19311f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R9XC3AHbubruexi5QxG0yQ.png"/></div></div></figure><p id="05d9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在下一节中，我们将从磁盘存储——在云运行上不工作——切换到使用存储桶。然而，如果您不需要持久存储，并且正在部署一个简单的Django Rest框架后端，那么只需跳到最后一节，标题为<strong class="ih lq">让云运行服务于正确域下的应用</strong>。</p><h1 id="f25c" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">从磁盘存储转换到存储桶</h1><p id="1b34" class="pw-post-body-paragraph if ig hi ih b ii ll ik il im lm io ip iq ln is it iu lo iw ix iy lp ja jb jc hb bi translated">当从文件存储转移到静态存储时，我们需要添加一些依赖项，然后修改我们的配置。首先，让我们安装必要的依赖项并更新我们的需求</p><pre class="kv kw kx ky fd lr jv ls lt aw lu bi"><span id="a24b" class="lv jx hi jv b fi lw lx l ly lz">pip install django-storages[google]<br/>pip freeze &gt; requirements.txt</span></pre><p id="5134" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，让我们再次转到我们在GCP控制台上的项目，做三件事:</p><ol class=""><li id="b0e4" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated">创建一个服务帐户来访问我们的bucket，下载凭证，将它们重命名为<strong class="ih lq"> bucket-admin.json </strong>，将该文件放在我们之前创建的应用程序的<strong class="ih lq"> secrets </strong>文件夹中。</li><li id="a894" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">为<strong class="ih lq">静态</strong>内容创建一个bucket，并为其添加两种不同的权限:我们刚刚创建的<strong class="ih lq">服务帐户</strong>获得了<strong class="ih lq">存储管理员</strong>权限，因此它可以读取、写入和列出bucket中的对象，<strong class="ih lq"> allUsers </strong>标识符获得了<strong class="ih lq">存储对象查看器</strong>权限，有效地将bucket公开。</li><li id="b073" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">为<strong class="ih lq">媒体</strong>内容创建一个桶，并为其添加两种不同的权限:我们刚刚创建的<strong class="ih lq">服务帐户</strong>获得<strong class="ih lq">存储管理</strong>权限，因此它可以读取、写入和列出桶中的对象，而<strong class="ih lq"> allUsers </strong>标识符获得<strong class="ih lq">存储对象查看器</strong>权限，从而有效地使桶成为公共的。</li></ol><p id="ce2e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在此之后，我们将根据<a class="ae jd" href="https://stackoverflow.com/questions/34247702/configure-django-and-google-cloud-storage/50116653#50116653" rel="noopener ugc nofollow" target="_blank">这个栈溢出回答</a>继续修改我们的<strong class="ih lq"> settings.py </strong>文件。</p><p id="91f1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，在项目根目录下创建一个名为config的python文件夹和一个名为<strong class="ih lq"> storage_backends.py </strong>的新文件，其内容如下:</p><pre class="kv kw kx ky fd lr jv ls lt aw lu bi"><span id="ebaa" class="lv jx hi jv b fi lw lx l ly lz"><em class="ma">"""<br/>GoogleCloudStorage extensions suitable for handing Django's<br/>Static and Media files.<br/><br/>Requires following settings:<br/>MEDIA_URL, GS_MEDIA_BUCKET_NAME<br/>STATIC_URL, GS_STATIC_BUCKET_NAME<br/><br/>In addition to<br/>https://django-storages.readthedocs.io/en/latest/backends/gcloud.html<br/>"""<br/></em>from django.conf import settings<br/>from storages.backends.gcloud import GoogleCloudStorage<br/>from storages.utils import setting<br/>from urllib.parse import urljoin<br/><br/><br/>class GoogleCloudMediaStorage(GoogleCloudStorage):<br/>    <em class="ma">"""GoogleCloudStorage suitable for Django's Media files."""<br/><br/>    </em>def __init__(self, *args, **kwargs):<br/>        if not settings.MEDIA_URL:<br/>            raise Exception('MEDIA_URL has not been configured')<br/>        kwargs['bucket_name'] = setting('GS_MEDIA_BUCKET_NAME')<br/>        super(GoogleCloudMediaStorage, self).__init__(*args, **kwargs)<br/><br/>    def url(self, name):<br/>        <em class="ma">""".url that doesn't call Google."""<br/>        </em>return urljoin(settings.MEDIA_URL, name)<br/><br/><br/>class GoogleCloudStaticStorage(GoogleCloudStorage):<br/>    <em class="ma">"""GoogleCloudStorage suitable for Django's Static files"""<br/><br/>    </em>def __init__(self, *args, **kwargs):<br/>        if not settings.STATIC_URL:<br/>            raise Exception('STATIC_URL has not been configured')<br/>        kwargs['bucket_name'] = setting('GS_STATIC_BUCKET_NAME')<br/>        super(GoogleCloudStaticStorage, self).__init__(*args, **kwargs)<br/><br/>    def url(self, name):<br/>        <em class="ma">""".url that doesn't call Google."""<br/>        </em>return urljoin(settings.STATIC_URL, name)</span></pre><p id="81bf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这将消除在构建URL时对桶的一些不必要的调用，这将使我们的GCP使用成本得到更好的控制。添加之后，我们的Django项目看起来有点像这样:</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div class="er es mv"><img src="../Images/4a28a63c51c38e0cf927e99d79143d18.png" data-original-src="https://miro.medium.com/v2/resize:fit:586/format:webp/1*uREeh4Wg7EMZxDQTCFLzRg.png"/></div></figure><p id="a618" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">将以下几行添加到您的<strong class="ih lq"> settings.py </strong>文件中，用您自己的名称替换存储桶名称:</p><pre class="kv kw kx ky fd lr jv ls lt aw lu bi"><span id="dbf8" class="lv jx hi jv b fi lw lx l ly lz"># add the correct application credentials<br/>os.environ["GOOGLE_APPLICATION_CREDENTIALS"] = "secrets/bucket-admin.json"</span><span id="cdbe" class="lv jx hi jv b fi mo lx l ly lz"># define the default file storage for both static and media<br/>DEFAULT_FILE_STORAGE = 'config.storage_backends.GoogleCloudMediaStorage'<br/>STATICFILES_STORAGE = 'config.storage_backends.GoogleCloudStaticStorage'</span><span id="4c15" class="lv jx hi jv b fi mo lx l ly lz"># add the names of the buckets<br/>GS_MEDIA_BUCKET_NAME = '&lt;MEDIA_BUCKET_NAME&gt;'<br/>GS_STATIC_BUCKET_NAME = '&lt;STATIC_BUCKET_NAME&gt;'</span><span id="19ea" class="lv jx hi jv b fi mo lx l ly lz"># define the static urls for both static and media<br/>STATIC_URL = 'https://storage.googleapis.com/{}/'.format(GS_STATIC_BUCKET_NAME)<br/>MEDIA_URL = 'https://storage.googleapis.com/{}/'.format(GS_MEDIA_BUCKET_NAME)</span></pre><p id="80cb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们在本地重新构建并重新启动docker应用程序<strong class="ih lq"/>，我们会看到一切都像预期的那样工作，但是我们错过了静态和媒体。通过在容器中运行<strong class="ih lq">python manage . py collect static</strong>，我们应该将所有的样式和静态图像放入新创建的桶中。</p><pre class="kv kw kx ky fd lr jv ls lt aw lu bi"><span id="e8a3" class="lv jx hi jv b fi lw lx l ly lz">docker exec &lt;YOUR_RUNNING_DOCKER_NAME&gt; python manage.py collectstatic --noinput</span></pre><p id="23f6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">出于某种原因，GCP桶使得显示字体比其他静态资产更困难(如果你知道为什么，请在评论中告诉我)。这意味着，如果我们引用位于我们的bucket中的字体，当访问Django-CMS admin时，我们将得到类似这样的内容:</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es mw"><img src="../Images/80a1c3a431c5394020e0bf82fd075889.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z2nrRMECsaPypjOPa1hkeA.png"/></div></div></figure><p id="673b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以看到作为字体的图标显示不正确。这是因为CORS的水桶政策。为了允许从任何目的地访问字体文件，让我们以<a class="ae jd" href="https://stackoverflow.com/a/39758208/3193371" rel="noopener ugc nofollow" target="_blank">这个堆栈的建议为标题，创建一个<strong class="ih lq"> cors.json </strong>文件，其内容如下:</a></p><pre class="kv kw kx ky fd lr jv ls lt aw lu bi"><span id="3a5c" class="lv jx hi jv b fi lw lx l ly lz">[<br/>    {<br/>      "origin": ["*"],<br/>      "responseHeader": ["Content-Type"],<br/>      "method": ["GET"],<br/>      "maxAgeSeconds": 3600<br/>    }<br/>]</span></pre><p id="bc54" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后设定CORS政策为</p><pre class="kv kw kx ky fd lr jv ls lt aw lu bi"><span id="8026" class="lv jx hi jv b fi lw lx l ly lz">gsutil cors set cors.json gs://&lt;STATIC_BUCKET_NAME&gt;</span></pre><p id="3ddf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">结果将会是:</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es mx"><img src="../Images/2399e3093355fc6ad24db6071587dd61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JWtagNG6b_G9erO0fksoEw.png"/></div></div></figure><p id="e97f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">同时，让我们也为我们的媒体桶设置CORS策略，否则我们在使用Django-CMS admin时将无法看到图像缩略图。</p><pre class="kv kw kx ky fd lr jv ls lt aw lu bi"><span id="fb9a" class="lv jx hi jv b fi lw lx l ly lz">gsutil cors set cors.json gs://&lt;MEDIA_BUCKET_NAME&gt;</span></pre><p id="a29c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，让我们将应用程序的最终版本推送到GCR，并在Cloud Run上创建应用程序的新版本。</p><h1 id="0b10" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">让云运行服务于正确域下的应用</h1><p id="0994" class="pw-post-body-paragraph if ig hi ih b ii ll ik il im lm io ip iq ln is it iu lo iw ix iy lp ja jb jc hb bi translated">现在，我们要做的最后一件事是给云运行一个它可以使用的自定义域。在主云运行视图中，我们单击<strong class="ih lq">管理自定义域</strong>，并在<strong class="ih lq">下添加映射</strong></p><figure class="kv kw kx ky fd kz er es paragraph-image"><div class="er es my"><img src="../Images/7ffaad912f734c31c25ec625f7f59fa3.png" data-original-src="https://miro.medium.com/v2/resize:fit:998/format:webp/1*m3uIcxn2Dx09fndq3G1m1Q.png"/></div></figure><p id="8676" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们选择我们想要映射的服务，然后键入我们想要附加到它的域名。</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div class="er es mz"><img src="../Images/77d58543c3b96b7270e270e39f75ea18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1162/format:webp/1*E-bDWnV1W6xZSfpjqNRzGQ.png"/></div></figure><p id="4c7b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，您将被要求选择一个域名提供商。Kristian的域名是从一家名为Zoner的芬兰域名提供商处购买的，显然它不会出现在列表中，但在大多数情况下，验证过程是相同的:您只需在DNS配置中添加一条TXT记录，这样google就知道您控制了该域名。无论域名提供商是谁，TXT记录的内容几乎都是一样的，所以我只选择name price作为域名提供商，然后继续添加记录TXT记录。</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es na"><img src="../Images/e557d19650827d0d5597077df1eae4e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ynukgxQVKiuXRoOE1tyxkg.png"/></div></div></figure><p id="6717" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">验证名称后，您将获得IP4和IP6地址，这是您的云运行服务的网关。复制这些地址，并将它们作为A和AAA记录添加到您的DNS配置中。给DNS一些时间来解决。对我来说，流量成功路由到新服务需要半个小时，但DNS缓存刷新可能需要4到24小时。</p><p id="dd0e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你完了！您已经将Django应用程序迁移到使用Cloud Run！</p><h1 id="037f" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">常见问题解答</h1><h2 id="f6fb" class="lv jx hi bd jy mb mc md kc me mf mg kg iq mh mi kk iu mj mk ko iy ml mm ks mn bi translated">Cloud Run表现如何？</h2><p id="3ac9" class="pw-post-body-paragraph if ig hi ih b ii ll ik il im lm io ip iq ln is it iu lo iw ix iy lp ja jb jc hb bi translated">一旦您的映像启动并运行，它将运行得非常好。这项服务位于美国中部的<strong class="ih lq"/>,我仍然看到从芬兰一路访问网站时有大约500毫秒的延迟。不利的是，我得到的冷启动时间大约是11秒，这对于个人网站来说还是可以的，但如果我能把它降低到5秒以内，那就更好了。我猜主要的问题是我使用了一个普通的Debian镜像作为基本的docker镜像。如果我有时间，我会尝试切换到阿尔卑斯山，看看是否有所不同。</p><h2 id="c28f" class="lv jx hi bd jy mb mc md kc me mf mg kg iq mh mi kk iu mj mk ko iy ml mm ks mn bi translated">便宜点吗？</h2><p id="67ca" class="pw-post-body-paragraph if ig hi ih b ii ll ik il im lm io ip iq ln is it iu lo iw ix iy lp ja jb jc hb bi translated">是的，也不是。这肯定比运行一个完整的虚拟机来托管一个docker映像要便宜，但我没有得到我希望的免费搭车:因为这项服务只在<strong class="ih lq">美国-中心1 </strong>可用，我不能使用我在<strong class="ih lq">欧洲-北方</strong>运行的常规Postgres数据库实例，而是必须在<strong class="ih lq">美国-中心1 </strong>创建一个新的<strong class="ih lq"> db-f1-micro </strong>实例，其成本大约是每月8欧元。(我的意思是，从技术上讲，我可以把我的数据库实例放在芬兰，但是当我尝试的时候，SQL查询在大西洋上跳跃，我变得<em class="ma">疯狂</em>延迟:冷启动30秒，每个后续请求5-7秒)。</p><p id="5d61" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们忽略运行数据库的成本，那么到目前为止，我在云上运行这个网站的成本正好是0€。我认为在Cloud Run上运行一个个人网站甚至不会耗尽免费层的显著部分，所以这个项目的实际Cloud Run成本将保持在0€。</p><h2 id="3e59" class="lv jx hi bd jy mb mc md kc me mf mg kg iq mh mi kk iu mj mk ko iy ml mm ks mn bi translated">值得吗？</h2><p id="144d" class="pw-post-body-paragraph if ig hi ih b ii ll ik il im lm io ip iq ln is it iu lo iw ix iy lp ja jb jc hb bi translated">肯定！对于运行流量相对较小的容器来说，这是一项很好的技术，因此最好的用例是个人网站、原型制作，以及——一旦Cloud Run退出测试——试图向市场推销的初创公司的生产实例。您只需为您使用的东西付费，而且您的基础架构成本几乎为零。</p><h1 id="3778" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">结论</h1><p id="d165" class="pw-post-body-paragraph if ig hi ih b ii ll ik il im lm io ip iq ln is it iu lo iw ix iy lp ja jb jc hb bi translated">我希望你发现这篇文章信息丰富。如果你有任何改进的建议，请在下面的评论中留下，我会努力解决它们，让这篇文章尽可能有用。</p><p id="a38e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">干杯！</p></div></div>    
</body>
</html>