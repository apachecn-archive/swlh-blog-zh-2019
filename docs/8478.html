<html>
<head>
<title>Atomikos — multi db transaction system</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">atomikos——多数据库事务系统</h1>
<blockquote>原文：<a href="https://medium.com/swlh/atomikos-multi-db-transaction-system-c16168df22e5?source=collection_archive---------18-----------------------#2019-07-17">https://medium.com/swlh/atomikos-multi-db-transaction-system-c16168df22e5?source=collection_archive---------18-----------------------#2019-07-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/a0c7ca46e8a8a492252b8771e89d7db4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*U50HBBPk4BGQO7C_HPJcsg.png"/></div></figure><p id="18dc" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">最终一致性、弹性、微服务、CQRS、十二因素应用程序或反应性不再是热门词汇。大多数开发者声称<a class="ae jk" href="https://www.reactivemanifesto.org" rel="noopener ugc nofollow" target="_blank">反应宣言</a>，<a class="ae jk" href="https://12factor.net" rel="noopener ugc nofollow" target="_blank"> 12因素应用</a>是构建反应灵敏的网络应用的最好也是唯一的方法。<em class="jl">事务</em>主要存在于服务或数据库中，术语<em class="jl">传播事务</em>听起来很可疑。我完全同意这一点，但是当你处理一个带有多个数据库的老式整体系统时，你很可能会与这个地狱作斗争。</p><p id="2d57" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在这种情况下，<a class="ae jk" href="https://www.atomikos.com" rel="noopener ugc nofollow" target="_blank"> Atomikos </a>听起来是最好的解决方案。根据<a class="ae jk" href="https://www.atomikos.com" rel="noopener ugc nofollow" target="_blank">网页</a>介绍，Atomikos是一个面向Java和REST的云原生事务管理系统。但这意味着什么呢？Atomikos是一个支持多数据库事务的库，包括消息和REST。更重要的是，不需要交易服务器，根据他们的网页，这是唯一支持交易服务器的库。</p><h2 id="5633" class="jm jn hi bd jo jp jq jr js jt ju jv jw ix jx jy jz jb ka kb kc jf kd ke kf kg bi translated">用例</h2><p id="9ed2" class="pw-post-body-paragraph im in hi io b ip kh ir is it ki iv iw ix kj iz ja jb kk jd je jf kl jh ji jj hb bi translated">我甚至不会考虑Atomikos，但是有一天，我正在使用一个中型的分布式monolith为企业客户提供SaaS解决方案。其中一个关键问题是在客户端之间分离数据。虽然对他们中的大多数人来说，隐私是最重要的，但我们决定选择物理隔离，而不是逻辑隔离。使用Spring，在数据源之间路由非常容易。查看<a class="ae jk" rel="noopener" href="/@szczerbicki.pawel/transparent-datasource-routing-in-spring-9fbfb2a9664">这个故事</a>了解更多信息。但是，如果您必须存储进入您系统的每个新客户机，然后引导一个单独的数据库，那该怎么办呢？作为一个团队，我们决定开发一个管理系统，该系统预先准备好虚拟环境，然后在成功注册后分配它。这个流需要在两个数据库中插入多个条目:client和admin，并在一个原子事务中发送一些事件。为什么？别问了——这是许多错误决定的结果。但是，对于这种情况，Atomikos听起来是完美的解决方案——事实也的确如此。</p><h2 id="585b" class="jm jn hi bd jo jp jq jr js jt ju jv jw ix jx jy jz jb ka kb kc jf kd ke kf kg bi translated">解决办法</h2><p id="4da5" class="pw-post-body-paragraph im in hi io b ip kh ir is it ki iv iw ix kj iz ja jb kk jd je jf kl jh ji jj hb bi translated">Spring处理开箱即用的单一数据源。对于多个DS，需要额外的配置，尤其是当您需要分散事务时。</p><p id="3b2a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">首先，你必须从<code class="du km kn ko kp b">javax.sql.Datasource</code>切换到<code class="du km kn ko kp b">com.atomikos.jdbc.nonxa.AtomikosNonXADataSourceBean</code>，这当然实现了<code class="du km kn ko kp b">javax.sql.Datasource</code>，并且内置了一个连接池。要创建<code class="du km kn ko kp b">Datasource</code>，只需设置新的bean</p><pre class="kq kr ks kt fd ku kp kv kw aw kx bi"><span id="7a4e" class="jm jn hi kp b fi ky kz l la lb">AtomikosNonXADataSourceBean ds = new AtomikosNonXADataSourceBean();<br/>ds.setDriverClassName(<em class="jl">DRIVER</em>);<br/>ds.setUrl(endpoint);<br/>ds.setUser(user);<br/>ds.setPassword(password);<br/>ds.setUniqueResourceName(<em class="jl">randomAlphabetic</em>(10));<br/>ds.setTestQuery(<em class="jl">SQL</em>);<br/>ds.setMaxPoolSize(<em class="jl">MAX_CONNECTIONS_PER_DATABASE</em>);</span></pre><p id="3715" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">请注意，使用<code class="du km kn ko kp b">AtomikosNonXADataSourceBean</code>对于恢复是不安全的。为此，请使用<code class="du km kn ko kp b">XA</code>数据源。</p><p id="1646" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">然后用Atomikos提供的事务管理器覆盖默认的Spring事务管理器。使用<code class="du km kn ko kp b">UserTransactionManager </code>，根据<a class="ae jk" href="https://www.atomikos.com/downloads/transactions-essentials/com/atomikos/AtomikosTransactionsEssentials/javadoc/3.7/com/atomikos/icatch/jta/UserTransactionManager.html" rel="noopener ugc nofollow" target="_blank">文档</a>它是<code class="du km kn ko kp b">TransactionManager</code>的零设置实现</p><pre class="kq kr ks kt fd ku kp kv kw aw kx bi"><span id="8802" class="jm jn hi kp b fi ky kz l la lb">@Bean(destroyMethod = "close", initMethod = "init")<br/>public TransactionManager atomikosTransactionManager() {<br/>    UserTransactionManager userTransactionManager = new                    UserTransactionManager();<br/>    userTransactionManager.setForceShutdown(false);<br/>    userTransactionManager.setTransactionTimeout(<em class="jl">TRANSACTION_TIMEOUT</em>);<br/>    return userTransactionManager;<br/>}</span></pre><p id="d780" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">创建允许应用程序显式管理事务的<code class="du km kn ko kp b">UserTransaction</code>对象。只有当用户希望创建自己的事务管理器时，才应该使用这个类，我们希望使用Atomikos来实现这一点</p><pre class="kq kr ks kt fd ku kp kv kw aw kx bi"><span id="35e9" class="jm jn hi kp b fi ky kz l la lb">@Bean<br/>public UserTransaction userTransaction() throws SystemException {<br/>    UserTransactionImp userTransaction = new UserTransactionImp();<br/>    userTransaction.setTransactionTimeout(<em class="jl">TRANSACTION_TIMEOUT</em>);<br/>    return userTransaction;<br/>}</span></pre><p id="e806" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">然后最终覆盖<code class="du km kn ko kp b">PlatformTransactionManager</code>，根据<a class="ae jk" href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/transaction/PlatformTransactionManager.html" rel="noopener ugc nofollow" target="_blank"> Spring文档</a>它是Spring事务基础设施中的中央接口。Atomikos建议使用<code class="du km kn ko kp b">JtaTransactionManager</code>,它必须与我们之前创建的<code class="du km kn ko kp b">UserTransaction</code>和<code class="du km kn ko kp b">TransactionManager</code>一起使用</p><pre class="kq kr ks kt fd ku kp kv kw aw kx bi"><span id="c366" class="jm jn hi kp b fi ky kz l la lb">@Bean(name = "transactionManager")<br/>public PlatformTransactionManager transactionManager(UserTransaction userTransaction, TransactionManager atomikosTransactionManager) throws Throwable {<br/>    JtaTransactionManager jtaTransactionManager = new JtaTransactionManager(userTransaction, atomikosTransactionManager);<br/>    jtaTransactionManager.setDefaultTimeout(<em class="jl">TRANSACTION_TIMEOUT</em>);<br/>    return jtaTransactionManager;<br/>}</span></pre><p id="3c9b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在只需使用<code class="du km kn ko kp b">@EnableTransactionManagement</code>启用交易，就大功告成了！</p><h2 id="a981" class="jm jn hi bd jo jp jq jr js jt ju jv jw ix jx jy jz jb ka kb kc jf kd ke kf kg bi translated">摘要</h2><p id="7776" class="pw-post-body-paragraph im in hi io b ip kh ir is it ki iv iw ix kj iz ja jb kk jd je jf kl jh ji jj hb bi translated">即使我们生活在一个事件驱动和最终一致性微服务架构的时代，多系统事务管理系统仍然至关重要。性感的词，如反应，排队等。并不适用于我们所有的设计。架构师在他们的方法上走得太远了，试图用微服务解决所有的问题，这通常会导致一个充满设计陷阱和错误的分布式整体。在某些情况下，特别是当软件还年轻的时候，模块化的整体正是你所需要的。而且有时候应该停留在这个水平。然后，您可能需要multi db的事务系统，Atomikos将很好地为您工作。对于一个分布式的整体，它在我的情况下工作得很好。我不鼓励您工作或编写这样的代码，但是当您不知何故陷入这个陷阱时，请将Atomikos视为一个事务管理系统。</p></div></div>    
</body>
</html>