<html>
<head>
<title>RepoDb, a hybrid-ORM library for .NET</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">RepoDb，一个混合ORM库。网</h1>
<blockquote>原文：<a href="https://medium.com/swlh/repodb-a-hybrid-orm-library-for-net-904b02ecdb07#2019-05-29">https://medium.com/swlh/repodb-a-hybrid-orm-library-for-net-904b02ecdb07#2019-05-29</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="d4ac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">众所周知，数据库访问在产品和软件开发中起着不可或缺的作用。它是应用程序中最关键的部分之一，因为它需要具体化，或者需要设计得更好以变得更加可插拔。</p><p id="1796" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，对象关系映射(ORM)开始发挥作用。这是大多数开发人员在数据可访问性方面的共同点。ORM库有助于简化和巩固实现，同时有助于加速开发。在我们使用它的过程中，它一直在做着复杂的工作。但是当然，我们应该知道在我们的应用程序中使用ORM的“优点”和“缺点”。</p><p id="c21c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如今，在C#世界里(或者。NET作为一个整体)，市面上有很多ORM库，有开源的，也有商业的。最流行的是Entity Framework(微软的一个数据建模框架)，其他的如NHibernate、Dapper(stack overflow的一个微表单)和LLBLGen Pro也可以使用。</p><p id="6b15" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有了这些，我们作为开发人员有责任选择最适合我们需求的(开发时间、简单性、效率、性能等)。</p><h1 id="461b" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated"><strong class="ak">为什么要使用RepoDb？</strong></h1><figure class="kc kd ke kf fd kg er es paragraph-image"><div role="button" tabindex="0" class="kh ki di kj bf kk"><div class="er es kb"><img src="../Images/e594fe6ad2121f1fc142cd0d25fa1a43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rllD5ZSZBc85Yt5n7JxJOw.png"/></div></div></figure><p id="9cd9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是一个面向. NET的动态、轻量级、高效和高性能的混合ORM库。</p><ol class=""><li id="4b0e" class="kn ko hi ih b ii ij im in iq kp iu kq iy kr jc ks kt ku kv bi translated">“高性能”一词指的是“多快”这个ORM将原始数据转换成类对象，并将类对象作为实际数据传输到数据库中。</li><li id="c122" class="kn ko hi ih b ii kw im kx iq ky iu kz iy la jc ks kt ku kv bi translated">“高效”这个词指的是在整个过程中操作对象时，这个ORM对计算机内存的“管理有多好”。</li></ol><p id="e0e3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它被认为是“混合ORM ”,因为它同时提供了微ORM和全ORM的功能。它为开发人员提供了灵活性，以简化开发期间何时使用“微”和“完整”操作的“切换”。</p><p id="46e2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个库支持micro-ORM的全部特性，因为它可以通过“原始SQL”进行CRUD操作。它还支持full-ORM的专门特性，允许开发人员通过基于方法的操作来操纵数据。</p><p id="3cb9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以下是原始SQL的示例代码:</p><figure class="kc kd ke kf fd kg"><div class="bz dy l di"><div class="lb lc l"/></div></figure><p id="6121" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是等效的基于方法的调用:</p><figure class="kc kd ke kf fd kg"><div class="bz dy l di"><div class="lb lc l"/></div></figure><p id="c34d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过基于方法的调用(即:<em class="ld"> BatchQuery、BulkInsert、Delete、DeleteAll、Insert、InsertAll、Update、UpdateAll、Merge、MergeAll等</em>)，full-ORMs的其他特性也可以在这个库上使用。</p><h1 id="8791" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated"><strong class="ak">批量操作</strong></h1><p id="fb34" class="pw-post-body-paragraph if ig hi ih b ii le ik il im lf io ip iq lg is it iu lh iw ix iy li ja jb jc hb bi translated">这个库的批处理操作都是打包语句。也就是说，单个<em class="ld"> DbCommand </em>对象用于一次执行多个SQL语句。过程是<a class="ae lj" href="https://en.wikipedia.org/wiki/ACID_(computer_science)" rel="noopener ugc nofollow" target="_blank">酸</a>；如果调用者不提供隐式事务，它就在内部使用它。默认情况下，它在每批中使用10条压缩语句。请参见下面的示例代码。</p><figure class="kc kd ke kf fd kg"><div class="bz dy l di"><div class="lb lc l"/></div></figure><p id="134f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上述语句通过<em class="ld">InsertAll</em>packed-statements创建<em class="ld">客户10045 </em>的<em class="ld"> 2个订单</em>记录。如果任何批处理失败，那么此操作的所有更改都将回滚。</p><p id="1554" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这些功能也适用于<em class="ld"> MergeAll </em>和<em class="ld"> UpdateAll </em>操作。</p><h1 id="4e3d" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated"><strong class="ak">批量操作</strong></h1><p id="35e8" class="pw-post-body-paragraph if ig hi ih b ii le ik il im lf io ip iq lg is it iu lh iw ix iy li ja jb jc hb bi translated">另一方面，批量操作使用由<em class="ld">ADO.NET</em>提供的“批量操作”。默认情况下，库使用<em class="ld"> SqlBulkCopy </em>类对SQL Server数据库进行“批量插入”操作。</p><figure class="kc kd ke kf fd kg"><div class="bz dy l di"><div class="lb lc l"/></div></figure><p id="cbc7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">尽管批量操作比批量操作快得多，但它也有自己的缺点。开发人员必须知道<em class="ld">何时</em>和<em class="ld">何处</em>才能在应用程序中正确使用批量操作。</p><h2 id="52c9" class="lk je hi bd jf ll lm ln jj lo lp lq jn iq lr ls jr iu lt lu jv iy lv lw jz lx bi translated"><strong class="ak">通过批量插入复制大数据</strong></h2><p id="86cc" class="pw-post-body-paragraph if ig hi ih b ii le ik il im lf io ip iq lg is it iu lh iw ix iy li ja jb jc hb bi translated">使用批量操作的一个常见场景是在将数据从一个数据库复制到另一个数据库时最大限度地提高性能。让我们说从<em class="ld"> Oracle </em>数据库进入<em class="ld"> SqlServer </em>数据库，或者反之亦然。参见下面的示例。</p><figure class="kc kd ke kf fd kg"><div class="bz dy l di"><div class="lb lc l"/></div></figure><p id="958c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面的脚本从名为<em class="ld"> Person </em>的<em class="ld"> Oracle </em>数据库表中检索100万行，其中<em class="ld"> Id </em>大于<em class="ld"> 10000 </em>，并且被<em class="ld"> 1 </em>分页<em class="ld">，并将数据插入到<em class="ld"> SqlServer </em>数据库的<em class="ld"> Person </em>表中。</em></p><p id="e2ed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">比方说，开发人员希望通过类进行复制；假设一个名为<em class="ld">客户</em>的类在<em class="ld"> Oracle </em>和<em class="ld"> SQL Server </em>的两个数据库中都有一个等价的表。这可以通过下面的脚本来完成。</p><figure class="kc kd ke kf fd kg"><div class="bz dy l di"><div class="lb lc l"/></div></figure><p id="9c1f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意，上面的脚本没有经过测试。</p><h1 id="fc0c" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated"><strong class="ak">执行存储过程</strong></h1><p id="c66b" class="pw-post-body-paragraph if ig hi ih b ii le ik il im lf io ip iq lg is it iu lh iw ix iy li ja jb jc hb bi translated">要执行存储过程，必须调用<em class="ld"> IDbConnection </em>对象的扩展<em class="ld"> Execute </em>方法。命令的类型也必须设置为<em class="ld"> CommandType。在调用<em class="ld">期间存储过程</em>。</em></p><h2 id="0ca2" class="lk je hi bd jf ll lm ln jj lo lp lq jn iq lr ls jr iu lt lu jv iy lv lw jz lx bi translated"><strong class="ak">执行方法列表:</strong></h2><ol class=""><li id="5c18" class="kn ko hi ih b ii le im lf iq ly iu lz iy ma jc ks kt ku kv bi translated"><em class="ld"> ExecuteQuery </em> —执行一条SQL语句，并将结果转换成。NET CLR类型。</li><li id="c206" class="kn ko hi ih b ii kw im kx iq ky iu kz iy la jc ks kt ku kv bi translated"><em class="ld"> ExecuteNonQuery </em> —执行SQL语句并返回受影响的行数。</li><li id="cf1a" class="kn ko hi ih b ii kw im kx iq ky iu kz iy la jc ks kt ku kv bi translated"><em class="ld"> ExecuteReader </em> —执行SQL语句并返回<em class="ld"> DbDataReader的实例。</em></li><li id="34ce" class="kn ko hi ih b ii kw im kx iq ky iu kz iy la jc ks kt ku kv bi translated"><em class="ld"> ExecuteScalar — </em>执行SQL语句并返回第一行的第一列。</li><li id="bcdd" class="kn ko hi ih b ii kw im kx iq ky iu kz iy la jc ks kt ku kv bi translated"><em class="ld"> ExecuteQueryMultiple — </em>执行多个打包的SQL语句，并允许开发人员通过<em class="ld"> QueryMultipleExtractor </em>类控制结果的提取。</li></ol><p id="8a18" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设数据库中有一个名为<em class="ld"> sp_get_customer_orders </em>的存储过程。</p><figure class="kc kd ke kf fd kg"><div class="bz dy l di"><div class="lb lc l"/></div></figure><p id="6683" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，可以通过下面的代码调用它。</p><figure class="kc kd ke kf fd kg"><div class="bz dy l di"><div class="lb lc l"/></div></figure><h1 id="ed9b" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated"><strong class="ak">通过MultipleQuery得到多个结果集</strong></h1><p id="afe0" class="pw-post-body-paragraph if ig hi ih b ii le ik il im lf io ip iq lg is it iu lh iw ix iy li ja jb jc hb bi translated">引入这个特性是为了帮助开发人员最大限度地减少客户端应用程序和数据库之间的往返调用。它允许开发人员在一次调用中执行多个SQL语句。</p><p id="ae32" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有两种方法可以做到这一点，通过本地的<em class="ld"> ExecuteQueryMultiple </em>方法，另一种是通过基于方法的<em class="ld"> QueryMultiple &lt; T1，T2 &gt;。</em></p><h2 id="823e" class="lk je hi bd jf ll lm ln jj lo lp lq jn iq lr ls jr iu lt lu jv iy lv lw jz lx bi translated"><strong class="ak"> ExecuteQueryMultiple </strong></h2><p id="e32b" class="pw-post-body-paragraph if ig hi ih b ii le ik il im lf io ip iq lg is it iu lh iw ix iy li ja jb jc hb bi translated"><em class="ld"> ExecuteQueryMultiple </em>要求调用者发出多个SQL语句。请参见下面的示例代码。</p><figure class="kc kd ke kf fd kg"><div class="bz dy l di"><div class="lb lc l"/></div></figure><p id="79bf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这些调用也可以与存储过程相结合。</p><figure class="kc kd ke kf fd kg"><div class="bz dy l di"><div class="lb lc l"/></div></figure><h2 id="76cd" class="lk je hi bd jf ll lm ln jj lo lp lq jn iq lr ls jr iu lt lu jv iy lv lw jz lx bi translated"><strong class="ak">查询乘数&lt; T1，T2&gt;T13】</strong></h2><p id="7f41" class="pw-post-body-paragraph if ig hi ih b ii le ik il im lf io ip iq lg is it iu lh iw ix iy li ja jb jc hb bi translated"><em class="ld"> QueryMultiple &lt; T1，T2 &gt; </em>方法的工作方式与<em class="ld"> ExecuteQueryMultiple </em>方法类似，只是要求开发人员通过泛型。NET CLR类型。</p><p id="bdde" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">开发人员还需要为查询表达式传递基于Linq的参数。</p><p id="e3be" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个方法返回一个<em class="ld">系统。元组</em>对象。请参见下面的示例代码。</p><figure class="kc kd ke kf fd kg"><div class="bz dy l di"><div class="lb lc l"/></div></figure><p id="aa9d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="ld"> ExecuteQueryMultiple </em>和<em class="ld"> QueryMultiple </em>方法都支持直到<em class="ld">的7元组。</em></p><h1 id="4732" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated"><strong class="ak">动态对象</strong></h1><p id="53b9" class="pw-post-body-paragraph if ig hi ih b ii le ik il im lf io ip iq lg is it iu lh iw ix iy li ja jb jc hb bi translated">这个库非常支持动态对象。本库的大多数操作接受对象<em class="ld">动态</em>和<em class="ld">系统。expand object</em>作为参数。</p><p id="5835" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面的示例代码使用了<em class="ld">动态</em>对象作为表达式。</p><figure class="kc kd ke kf fd kg"><div class="bz dy l di"><div class="lb lc l"/></div></figure><p id="4d0d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它返回所有来自西班牙的顾客，其中姓氏是圣地亚哥。返回值的类型为<em class="ld">IEnumerable&lt;expand object&gt;。</em></p><p id="6c55" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此外，如果在操作数据库中的数据时“不”创建“模型”类，开发人员可以利用这个特性。请参见下面的示例代码。</p><figure class="kc kd ke kf fd kg"><div class="bz dy l di"><div class="lb lc l"/></div></figure><p id="98bd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">或者更新现有的<em class="ld">客户</em>记录<em class="ld">。</em></p><figure class="kc kd ke kf fd kg"><div class="bz dy l di"><div class="lb lc l"/></div></figure><p id="269e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这同样适用于其他操作，如<em class="ld"> BulkInsert、</em> <em class="ld"> Delete、Merge、DeleteAll、MergeAll、UpdateAll、</em>等。</p><p id="8ef4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih mb">注意</strong>:从1.9.7版本开始，库不支持<em class="ld"> BulkInsert中的<em class="ld">expand object</em>，Insert </em>，<em class="ld"> InsertAll </em>，<em class="ld"> Merge </em>，<em class="ld"> MergeAll </em>，<em class="ld"> Update </em>和<em class="ld"> UpdateAll </em>操作。</p><p id="8030" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面的代码将会工作，因为<em class="ld">实体</em>变量的类型是<em class="ld">动态</em>。</p><figure class="kc kd ke kf fd kg"><div class="bz dy l di"><div class="lb lc l"/></div></figure><p id="4cb7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面的代码对<em class="ld">更新</em>操作无效，因为<em class="ld">查询</em>操作的返回类型是<em class="ld">扩展对象</em>。在<em class="ld">更新</em>操作中会抛出异常。</p><figure class="kc kd ke kf fd kg"><div class="bz dy l di"><div class="lb lc l"/></div></figure><p id="889e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是下面的代码将适用于<em class="ld">更新</em>操作。</p><figure class="kc kd ke kf fd kg"><div class="bz dy l di"><div class="lb lc l"/></div></figure><h1 id="33bb" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated"><strong class="ak">储存库</strong></h1><p id="7716" class="pw-post-body-paragraph if ig hi ih b ii le ik il im lf io ip iq lg is it iu lh iw ix iy li ja jb jc hb bi translated">该库有两个内置存储库，名为<em class="ld"> DbRepository </em>和<em class="ld"> BaseRepository </em>，用于数据分层。开发人员可以立即抽象和实例化这些存储库。</p><h2 id="4a39" class="lk je hi bd jf ll lm ln jj lo lp lq jn iq lr ls jr iu lt lu jv iy lv lw jz lx bi translated"><strong class="ak">数据库库&lt;数据库连接&gt;T17】</strong></h2><p id="3704" class="pw-post-body-paragraph if ig hi ih b ii le ik il im lf io ip iq lg is it iu lh iw ix iy li ja jb jc hb bi translated">该存储库用于创建一个更高级别的存储库，该存储库由数据库的整个模型共享。</p><figure class="kc kd ke kf fd kg"><div class="bz dy l di"><div class="lb lc l"/></div></figure><p id="2ed9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上述存储库使用数据库的<em class="ld">客户</em>和<em class="ld">订单</em>模型。它由所有其他模型共享。</p><p id="5f60" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要使用它，请使用下面的代码。</p><figure class="kc kd ke kf fd kg"><div class="bz dy l di"><div class="lb lc l"/></div></figure><p id="4633" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">开发人员也可以通过直接实例化<em class="ld"> DbRepository </em>类来简化调用。</p><figure class="kc kd ke kf fd kg"><div class="bz dy l di"><div class="lb lc l"/></div></figure><h2 id="c7e1" class="lk je hi bd jf ll lm ln jj lo lp lq jn iq lr ls jr iu lt lu jv iy lv lw jz lx bi translated"><strong class="ak"> BaseRepository &lt; TEntity，TDB connection&gt;T25】</strong></h2><p id="1403" class="pw-post-body-paragraph if ig hi ih b ii le ik il im lf io ip iq lg is it iu lh iw ix iy li ja jb jc hb bi translated">该存储库用于创建特定于模型的存储库。它是作为抽象实现的，不能立即实例化。</p><figure class="kc kd ke kf fd kg"><div class="bz dy l di"><div class="lb lc l"/></div></figure><h1 id="bb7e" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated"><strong class="ak">性能和效率</strong></h1><p id="9190" class="pw-post-body-paragraph if ig hi ih b ii le ik il im lf io ip iq lg is it iu lh iw ix iy li ja jb jc hb bi translated">这个功能是图书馆的“心脏”。这也是这个库最初存在的主要原因。目前，该库已经在Frans Bouma的RawDataAccessBencher最近的“正式运行”中，无论是“性能”还是“内存效率”测试中都名列前茅。</p><p id="a838" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面的截图是“性能”测试的结果。</p><figure class="kc kd ke kf fd kg er es paragraph-image"><div role="button" tabindex="0" class="kh ki di kj bf kk"><div class="er es mc"><img src="../Images/2030817f3e6a89d731b9a88b0bce0f3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DrBsmwAjC60je1UopgYkfw.png"/></div></div></figure><p id="6686" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面的截图是“内存效率”测试的结果。</p><figure class="kc kd ke kf fd kg er es paragraph-image"><div role="button" tabindex="0" class="kh ki di kj bf kk"><div class="er es md"><img src="../Images/ff0c3444020a9cba135b2f589963068a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2i4jbeGpYveC_A0JzioPVA.png"/></div></div></figure><p id="4b8d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">官方结果可以在<a class="ae lj" href="https://github.com/FransBouma/RawDataAccessBencher/blob/master/Results/20190520_netcore.txt" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><h2 id="f8f3" class="lk je hi bd jf ll lm ln jj lo lp lq jn iq lr ls jr iu lt lu jv iy lv lw jz lx bi translated">包装插入试验</h2><p id="4fe1" class="pw-post-body-paragraph if ig hi ih b ii le ik il im lf io ip iq lg is it iu lh iw ix iy li ja jb jc hb bi translated">图书馆爆满声明不是官方<em class="ld"> RDAB的一部分。</em>根据<em class="ld"> RDAB </em>的作者Frans Bouma的说法，这是一个<em class="ld">苹果</em>和<em class="ld">橙子</em>的对比。那个测试中包括的ORM是那些只做变更/状态跟踪库的人，而这个库不做那件事。</p><p id="47de" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，在我的开发环境中，这个库也超过了“打包插入”执行。<a class="ae lj" href="https://github.com/mikependon/RawDataAccessBencher" rel="noopener ugc nofollow" target="_blank"> <em class="ld"> RDAB </em> </a>的修改版可以在我的<a class="ae lj" href="https://github.com/mikependon" rel="noopener ugc nofollow" target="_blank"> Github </a>账号上找到。任何人都可以克隆存储库并执行bencher来本地查看结果。</p><figure class="kc kd ke kf fd kg er es paragraph-image"><div role="button" tabindex="0" class="kh ki di kj bf kk"><div class="er es me"><img src="../Images/c0db6145dac7845f239dd132446d48da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GkD3GEeKaNWyZOF7FClScA.png"/></div></div></figure><h1 id="8b6d" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">贮藏</h1><p id="cf85" class="pw-post-body-paragraph if ig hi ih b ii le ik il im lf io ip iq lg is it iu lh iw ix iy li ja jb jc hb bi translated">这个特性允许开发者缓存<em class="ld">查询</em>和<em class="ld">查询所有</em>操作的结果。默认情况下，库正在使用<em class="ld"> MemoryCache </em>内部类。缓存项目到期时间为<em class="ld"> 180分钟</em>。</p><p id="985a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要缓存结果，只需向<em class="ld">查询</em>或<em class="ld">查询所有</em>操作的<em class="ld"> cacheKey </em>参数传递一个值。请参见下面的示例代码。</p><figure class="kc kd ke kf fd kg"><div class="bz dy l di"><div class="lb lc l"/></div></figure><p id="d665" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上面的代码中，返回的<em class="ld">产品</em>对象列表被缓存在计算机内存中。下次执行这段代码时，引擎将在接下来的3个小时内从缓存中而不是从数据库中选取结果。</p><p id="c998" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于希望缓存“不变”或“查找”数据的开发人员来说，这个场景非常有用。</p><p id="163c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">开发人员也可以通过简单地实现接口<em class="ld"> ICache来创建<em class="ld">缓存类</em>的定制版本。关于这方面的更多信息，请访问这里的官方文档<a class="ae lj" href="https://repodb.readthedocs.io/en/latest/pages/cache.html" rel="noopener ugc nofollow" target="_blank">。</a></em></p><h1 id="28a5" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated"><strong class="ak">扩展性</strong></h1><p id="b1db" class="pw-post-body-paragraph if ig hi ih b ii le ik il im lf io ip iq lg is it iu lh iw ix iy li ja jb jc hb bi translated">该库已经完全支持SQL Server。也支持其他数据库提供程序，但仅当使用“RawSql”操作时。原始SQL操作包括以下方法:<em class="ld"> ExecuteQuery、ExecuteNonQuery、ExecuteReader、ExecuteScalar </em>和<em class="ld"> ExecuteQueryMultiple。</em></p><p id="5acd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了扩展对“基于方法”的调用的“流畅”支持，开发人员需要通过所需的接口实现必要的类。</p><h2 id="5c71" class="lk je hi bd jf ll lm ln jj lo lp lq jn iq lr ls jr iu lt lu jv iy lv lw jz lx bi translated">支持其他数据提供者</h2><p id="85cd" class="pw-post-body-paragraph if ig hi ih b ii le ik il im lf io ip iq lg is it iu lh iw ix iy li ja jb jc hb bi translated">为了完全支持Oracle数据提供者，开发人员需要实现以下内容。</p><ol class=""><li id="6926" class="kn ko hi ih b ii ij im in iq kp iu kq iy kr jc ks kt ku kv bi translated"><em class="ld">实现<em class="ld"> IStatementBuilder </em>接口的OracleStamentBuilder </em>。</li><li id="993d" class="kn ko hi ih b ii kw im kx iq ky iu kz iy la jc ks kt ku kv bi translated"><em class="ld">实现<em class="ld"> IDbOperationProvider </em>接口的OracleDbOperationProvider </em>。</li><li id="0d70" class="kn ko hi ih b ii kw im kx iq ky iu kz iy la jc ks kt ku kv bi translated"><em class="ld">实现<em class="ld"> IDbHelper </em>接口的OracleDbHelper </em>。</li></ol><p id="66e3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦实现，开发人员就可以通过调用以下映射来映射对象。</p><figure class="kc kd ke kf fd kg"><div class="bz dy l di"><div class="lb lc l"/></div></figure><p id="7a3a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要完全支持其他数据提供者，必须完成相同的过程。</p><h1 id="b33f" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">图书馆质量</h1><p id="23bc" class="pw-post-body-paragraph if ig hi ih b ii le ik il im lf io ip iq lg is it iu lh iw ix iy li ja jb jc hb bi translated">实际开发的方法是TDD，在某个时间点，通过后期代码单元测试开发来保护代码。在撰写本文时，该库有2300多个集成测试和1200多个单元测试。</p><p id="87e8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每个测试覆盖不同的场景，并被编写为测试<em class="ld">同步</em>和<em class="ld">异步</em>操作。</p><p id="9b1b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一些测试场景可能同时存在于<em class="ld"> IDbConnection </em>、<em class="ld"> DbRepository </em>和<em class="ld"> BaseRepository </em>中，但是针对不同的代码库。</p><figure class="kc kd ke kf fd kg er es paragraph-image"><div role="button" tabindex="0" class="kh ki di kj bf kk"><div class="er es mf"><img src="../Images/fa2bd99ba7d85a3105aff421c92637a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jnVI2ysL_Nc9BYBZQO4X0Q.png"/></div></div></figure><h1 id="0b21" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated"><strong class="ak">链接</strong></h1><p id="48e0" class="pw-post-body-paragraph if ig hi ih b ii le ik il im lf io ip iq lg is it iu lh iw ix iy li ja jb jc hb bi translated">以下是该库的访问链接。</p><ol class=""><li id="b780" class="kn ko hi ih b ii ij im in iq kp iu kq iy kr jc ks kt ku kv bi translated">项目:<a class="ae lj" href="https://github.com/mikependon/RepoDb" rel="noopener ugc nofollow" target="_blank">https://github.com/mikependon/RepoDb</a></li><li id="0470" class="kn ko hi ih b ii kw im kx iq ky iu kz iy la jc ks kt ku kv bi translated">套餐:【https://www.nuget.org/packages/RepoDb T2】</li><li id="9ea6" class="kn ko hi ih b ii kw im kx iq ky iu kz iy la jc ks kt ku kv bi translated">文档:【https://repodb.readthedocs.io/en/latest/ T4】</li></ol><h1 id="626f" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">摘要</h1><p id="9035" class="pw-post-body-paragraph if ig hi ih b ii le ik il im lf io ip iq lg is it iu lh iw ix iy li ja jb jc hb bi translated">这个库非常简单和轻量级。它仍然被认为是一个微ORM，因为它不具备大ORM的任何高级功能，如<em class="ld">变更跟踪</em>、<em class="ld">状态跟踪</em>等。</p><p id="5578" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个库是为那些习惯于使用微表单特性并愿意使用完整表单中的操作的开发人员准备的。</p><p id="88eb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个库的构建考虑了性能、效率、可扩展性和质量。</p><p id="263f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">作为本库的作者，我将非常感谢通过这个<a class="ae lj" href="https://github.com/mikependon/RepoDb/issues" rel="noopener ugc nofollow" target="_blank">链接</a>接收任何反馈、建议甚至是错误。我期待着更多的合作。网络社区。</p><p id="6e00" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">非常感谢您阅读这篇文章。/迈克尔</p></div></div>    
</body>
</html>