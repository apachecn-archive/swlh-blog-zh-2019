<html>
<head>
<title>Updating Users to the Latest Version of Your iOS App</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将用户更新到最新版本的iOS应用程序</h1>
<blockquote>原文：<a href="https://medium.com/swlh/updating-users-to-the-latest-app-release-on-ios-ed96e4c76705?source=collection_archive---------1-----------------------#2019-07-18">https://medium.com/swlh/updating-users-to-the-latest-app-release-on-ios-ed96e4c76705?source=collection_archive---------1-----------------------#2019-07-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="f7f9" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">在需要时将用户过渡到最新应用程序更新的挑战</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/35fad0b46ac1e0360a7658ed94e0bf1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g_B4JNulmfXSj0AyEjImyA.jpeg"/></div></div></figure><p id="3ace" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">当紧急情况发生时，有一个适当的机制将用户温和地过渡到最新的应用程序更新是有益的。然而，这种机制可能需要一个后端解决方案来让应用程序用户知道何时发布更新，这在开发开销和维护方面都可能是昂贵的。如果要在开发这样的解决方案或向用户提供新功能之间做出选择，后者很可能会胜出，这意味着在最坏的情况下，大多数应用程序很少或根本没有迁移用户的手段。</p><p id="83b5" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">当谈到将用户迁移到最新版本的应用程序时，我们很幸运，iOS为我们做了大部分的跑腿工作。App Store的默认设置是通宵自动下载应用程序更新，这意味着大多数用户通常会在几天内收到最新的应用程序版本。</p><p id="929e" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">但是如果几天之内还不够快呢？如果一个我们无法控制的API发生意外变化，导致所有功能丧失，该怎么办？或者用于SSL固定的证书意外过期？与web开发不同，不可能轻松地将用户回滚到软件的早期版本，因此不难想象，有时能够将用户迁移到包含最新错误修复等的最新版本的应用程序可能是有用的。应用程序开发人员显然会尽量避免这种情况，但如果我们未能预测到这些情况的发生，那么当紧急情况出现时，采取行动就为时已晚。</p><p id="b22c" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">除了例外情况，在很多情况下，让用户知道有新的应用程序版本可用可能会很好——例如，如果新的应用程序功能在最新发布的版本中可用，该版本已被广泛宣传，或者针对用户遇到的非关键但令人讨厌的问题发布了修复程序。</p><h2 id="5cd5" class="kg kh hi bd ki kj kk kl km kn ko kp kq js kr ks kt jw ku kv kw ka kx ky kz la bi translated">放弃对旧版本iOS的支持</h2><p id="414f" class="pw-post-body-paragraph jj jk hi jl b jm lb ij jo jp lc im jr js ld ju jv jw le jy jz ka lf kc kd ke hb bi translated">苹果非常成功地创造了一个吸引因素，鼓励用户更新到最新版本的iOS。此外，iOS本身通过标记和通知让用户清楚地知道新版本的操作系统已经推出。因此，大多数iOS用户倾向于运行最新或以前版本的iOS。对于开发者来说，这意味着我们很少需要非常旧版本的操作系统。就让用户更新到我们应用程序的最新版本而言，让大多数设备都拥有最新版本的iOS显然是一个很大的帮助——特别是如果我们的应用程序只支持两个最新发布的iOS版本。</p><p id="0939" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">然而，考虑一个支持旧版本iOS的应用程序，开发团队希望放弃对它的支持。如果团队放弃对旧版本iOS的支持，那么应用程序更新将不再由App Store自动提供给该版本操作系统的用户，直到他们更新。此外，如果用户访问应用商店中的应用页面，他们将只能看到他们的设备有资格获得的最新更新。让用户知道，一旦他们更新了iOS的更高版本，他们就可以使用新版本的应用程序，这可能是值得的，这样他们就不会认为应用程序的开发已经结束。</p><h1 id="8c58" class="lg kh hi bd ki lh li lj km lk ll lm kq io ln ip kt ir lo is kw iu lp iv kz lq bi translated">更新</h1><p id="1812" class="pw-post-body-paragraph jj jk hi jl b jm lb ij jo jp lc im jr js ld ju jv jw le jy jz ka lf kc kd ke hb bi translated"><a class="ae lr" href="https://github.com/rwbutler/Updates" rel="noopener ugc nofollow" target="_blank">更新</a>是一个开源框架，它会自动检查你的应用程序是否有新版本。当发布更新时，Updates能够向用户提供新的版本号和附带的发行说明，让他们选择更新。选择继续的用户可以无缝地看到应用商店的应用程序，这样更新就变得轻松了。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ls"><img src="../Images/b0bea4d09bd32b2ddbd93ae442540c50.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*YvyU-XAdMR72SRi1o7aAuQ.png"/></div><figcaption class="lt lu et er es lv lw bd b be z dx">Screenshot showing Updates in automatic configuration</figcaption></figure><p id="b3e8" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">能够自动处理这些的框架是有益的，因为开发团队通常更关注开发新的功能来为用户提供价值，而不是实现更新用户的功能，这些功能可能永远都不需要使用。</p><p id="3839" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">Updates使用<a class="ae lr" href="https://developer.apple.com/library/archive/documentation/AudioVideo/Conceptual/iTuneSearchAPI/index.html" rel="noopener ugc nofollow" target="_blank"> iTunes搜索API </a>从商店中检索最新版本的应用程序的版本号。除此之外，还会为您的应用获取发行说明和数字应用商店标识符，这意味着当发布新版本时，Updates能够告诉您的用户更新的版本号以及新增内容。</p><p id="7122" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">该框架能够自动解析用户的设备区域设置，确保应用程序更新针对相关的应用程序商店区域以及详细信息，例如用户的设备是否有资格接收更新。</p><p id="0911" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">使用数字应用商店标识符，如果用户选择更新，那么更新可以使用<a class="ae lr" href="https://developer.apple.com/documentation/storekit/skstoreproductviewcontroller" rel="noopener ugc nofollow" target="_blank">skstoreprodiviewcontroller</a>呈现应用商店，允许用户无缝更新，而不必离开应用。</p><p id="ac97" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">如果您希望手动设置这些信息(而不是让更新为您检索)，您可以通过将必要的信息指定为JSON配置文件的一部分来实现。此外，拥有一个JSON配置文件允许您指定是自动还是手动检查更新——您可以稍后远程切换此设置。也可以通过编程来配置所有设置。</p><h2 id="610e" class="kg kh hi bd ki kj kk kl km kn ko kp kq js kr ks kt jw ku kv kw ka kx ky kz la bi translated">自动检查更新</h2><p id="cf70" class="pw-post-body-paragraph jj jk hi jl b jm lb ij jo jp lc im jr js ld ju jv jw le jy jz ka lf kc kd ke hb bi translated">要让更新自动检查应用程序的新版本，您可以使用JSON配置文件来配置框架。您需要通过指定如下配置URL，让更新知道在哪里查找该文件:</p><pre class="iy iz ja jb fd lx ly lz ma aw mb bi"><span id="c9b0" class="kg kh hi ly b fi mc md l me mf">let url = "https://exampledomain.com/updates.json"</span><span id="2257" class="kg kh hi ly b fi mg md l me mf">Updates.configurationURL = URL(string: url)</span></pre><p id="9bf1" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">或者，URL可以使用文件URL引用您的应用捆绑包中的本地文件，例如</p><pre class="iy iz ja jb fd lx ly lz ma aw mb bi"><span id="f15f" class="kg kh hi ly b fi mc md l me mf">Updates.configurationURL = Bundle.main.url(forResource: "Updates", withExtension: "json")</span></pre><p id="b2dd" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">一个简单的配置文件可能如下所示:</p><pre class="iy iz ja jb fd lx ly lz ma aw mb bi"><span id="4e6c" class="kg kh hi ly b fi mc md l me mf">{<br/>    "updates": {<br/>        "check-for": "automatically",<br/>        "notify": "once"<br/>    }<br/>}</span></pre><p id="54f8" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">注意，Updates寻找一个名为<code class="du mh mi mj ly b">updates</code>的顶级键，这意味着可以添加到一个现有的JSON文件中，而不是创建一个全新的文件。</p><p id="98d8" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">上面的配置告诉Updates解决所有需要的信息，以确定您的应用程序的新版本是否可以通过最少的配置自动获得。它还表明，用户应该只被通知一次特定的应用程序更新，以避免困扰他们。该属性的可选值为<code class="du mh mi mj ly b">twice</code>、<code class="du mh mi mj ly b">thrice</code>、<code class="du mh mi mj ly b">never</code>和<code class="du mh mi mj ly b">always</code>。</p><p id="74bf" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">部署应用程序后，拥有远程JSON配置可以提供最大的灵活性，因为这使得从自动模式远程切换到手动模式成为可能，然后如果您愿意，可以自己提供应用程序最新更新的详细信息。</p><p id="02fb" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">如果需要，您可以放弃远程JSON配置，而简单地以编程方式配置更新，如下所示:</p><pre class="iy iz ja jb fd lx ly lz ma aw mb bi"><span id="4e38" class="kg kh hi ly b fi mc md l me mf">Updates.updatingMode = .automatically</span><span id="92eb" class="kg kh hi ly b fi mg md l me mf">Updates.notifying = .once</span></pre><p id="2f2f" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这相当于上面JSON代码片段中的配置。</p><h2 id="1fdf" class="kg kh hi bd ki kj kk kl km kn ko kp kq js kr ks kt jw ku kv kw ka kx ky kz la bi translated">手动通知用户更新</h2><p id="d20d" class="pw-post-body-paragraph jj jk hi jl b jm lb ij jo jp lc im jr js ld ju jv jw le jy jz ka lf kc kd ke hb bi translated">要手动通知用户应用程序的更新，请按如下方式配置JSON文件:</p><pre class="iy iz ja jb fd lx ly lz ma aw mb bi"><span id="8b12" class="kg kh hi ly b fi mc md l me mf">{<br/>    "updates": {<br/>        "check-for": "manually",<br/>        "notify": "always",<br/>        "app-store-id": "123456",<br/>        "comparing": "major-versions",<br/>        "min-os-required": "12.0.0",<br/>        "version": "2.0.0"<br/>     }<br/>}</span></pre><ul class=""><li id="a969" class="mk ml hi jl b jm jn jp jq js mm jw mn ka mo ke mp mq mr ms bi translated"><code class="du mh mi mj ly b">check-for</code>指定更新应该自动还是手动检查更新。</li><li id="9b38" class="mk ml hi jl b jm mt jp mu js mv jw mw ka mx ke mp mq mr ms bi translated"><code class="du mh mi mj ly b">notifying</code>参数允许开发者指定用户被提示更新的次数。</li><li id="75cc" class="mk ml hi jl b jm mt jp mu js mv jw mw ka mx ke mp mq mr ms bi translated"><code class="du mh mi mj ly b">app-store-id</code>参数指定App Store中应用程序的数字标识符。只有当您希望使用<code class="du mh mi mj ly b">UpdatesUI</code>组件来显示允许用户更新的<code class="du mh mi mj ly b">SKStoreProductViewController</code>时，才需要该参数。如果开发自定义用户界面，可以省略该参数。</li><li id="c4ef" class="mk ml hi jl b jm mt jp mu js mv jw mw ka mx ke mp mq mr ms bi translated"><code class="du mh mi mj ly b">comparing</code>确定通知用户通知版本所需的版本号增量，例如<code class="du mh mi mj ly b">major-versions</code>表示仅当应用的主版本号增加时才会通知用户。这里其他可能的值是<code class="du mh mi mj ly b">minor-versions</code>和<code class="du mh mi mj ly b">patch-versions</code>。</li><li id="7406" class="mk ml hi jl b jm mt jp mu js mv jw mw ka mx ke mp mq mr ms bi translated"><code class="du mh mi mj ly b">min-os-required</code>属性确保如果你的应用程序的新版本不支持以前支持的iOS旧版本，那么不能利用更新的用户不会得到关于新版本的通知。</li><li id="fa64" class="mk ml hi jl b jm mt jp mu js mv jw mw ka mx ke mp mq mr ms bi translated"><code class="du mh mi mj ly b">version</code>属性指示可从应用商店获得的新应用版本。</li></ul><p id="f208" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">如果您选择不承载远程配置文件，则可以通过编程方式获得相同的配置:</p><pre class="iy iz ja jb fd lx ly lz ma aw mb bi"><span id="422b" class="kg kh hi ly b fi mc md l me mf">Updates.updatingMode = .manually</span><span id="e3eb" class="kg kh hi ly b fi mg md l me mf">Updates.notifying = .always</span><span id="003d" class="kg kh hi ly b fi mg md l me mf">Updates.appStoreId = "123456"</span><span id="2ff4" class="kg kh hi ly b fi mg md l me mf">Updates.comparingVersions = .major</span><span id="5273" class="kg kh hi ly b fi mg md l me mf">Updates.minimumOSVersion = "12.0.0"</span><span id="9515" class="kg kh hi ly b fi mg md l me mf">Updates.versionString = "2.0.0"</span></pre><h1 id="69c7" class="lg kh hi bd ki lh li lj km lk ll lm kq io ln ip kt ir lo is kw iu lp iv kz lq bi translated">检查更新</h1><p id="b2b6" class="pw-post-body-paragraph jj jk hi jl b jm lb ij jo jp lc im jr js ld ju jv jw le jy jz ka lf kc kd ke hb bi translated">无论您是否已将更新配置为自动或手动检查更新，请在您的应用中调用<code class="du mh mi mj ly b">checkForUpdates</code>以获得新应用更新的通知，如下所示:</p><pre class="iy iz ja jb fd lx ly lz ma aw mb bi"><span id="dc29" class="kg kh hi ly b fi mc md l me mf">Updates.checkForUpdates { result in</span><span id="87a6" class="kg kh hi ly b fi mg md l me mf">    // Implement custom UI or use UpdatesUI component</span><span id="a2cd" class="kg kh hi ly b fi mg md l me mf">}</span></pre><p id="5720" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">下一节中描述的<code class="du mh mi mj ly b">UpdatesUI</code>组件可以与该方法调用结合使用，以在应用程序中呈现应用商店(在无法加载前者的情况下使用<code class="du mh mi mj ly b">SKStoreProductViewController</code>或<code class="du mh mi mj ly b">SFSafariViewController</code>),从而允许用户无缝更新。或者，您可以选择在回调中实现您自己的自定义UI。</p><p id="40a4" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">回调返回一个指示更新是否可用的<code class="du mh mi mj ly b">UpdatesResult</code>枚举值:</p><pre class="iy iz ja jb fd lx ly lz ma aw mb bi"><span id="89ef" class="kg kh hi ly b fi mc md l me mf">public enum UpdatesResult {</span><span id="38fe" class="kg kh hi ly b fi mg md l me mf">    case available(Update)</span><span id="d827" class="kg kh hi ly b fi mg md l me mf">    case none</span><span id="651c" class="kg kh hi ly b fi mg md l me mf">}</span></pre><p id="cf35" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在更新可用的情况下，当使用自动配置时，提供更新的版本号以及发行说明的<code class="du mh mi mj ly b">Update</code>值是可用的:</p><pre class="iy iz ja jb fd lx ly lz ma aw mb bi"><span id="27d4" class="kg kh hi ly b fi mc md l me mf">public struct Update {</span><span id="32c8" class="kg kh hi ly b fi mg md l me mf">   public let newVersionString: String</span><span id="8aca" class="kg kh hi ly b fi mg md l me mf">   public let releaseNotes: String?</span><span id="f2df" class="kg kh hi ly b fi mg md l me mf">   public let shouldNotify: Bool</span><span id="a3c7" class="kg kh hi ly b fi mg md l me mf">}</span></pre><p id="bb1a" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">注意，JSON配置中的<code class="du mh mi mj ly b">notify</code>属性的值用于确定<code class="du mh mi mj ly b">shouldNotify</code>是<code class="du mh mi mj ly b">true</code>还是<code class="du mh mi mj ly b">false</code>。在编写自定义UI时，开发人员需要尊重<code class="du mh mi mj ly b">shouldNotify</code>的值。如果使用<code class="du mh mi mj ly b">UpdatesUI</code>组件，该属性将自动生效。</p><h1 id="fc86" class="lg kh hi bd ki lh li lj km lk ll lm kq io ln ip kt ir lo is kw iu lp iv kz lq bi translated">UI组件</h1><p id="7a26" class="pw-post-body-paragraph jj jk hi jl b jm lb ij jo jp lc im jr js ld ju jv jw le jy jz ka lf kc kd ke hb bi translated">UpdatesUI组件独立于核心更新框架，允许开发人员在需要时创建自定义UI。对于不需要自定义UI的开发者来说，<code class="du mh mi mj ly b">UpdatesUI</code>让用户更新尽可能简单。用户将看到一个<code class="du mh mi mj ly b">UIAlertController</code>，询问是更新还是取消。如果用户选择更新，那么将显示一个<code class="du mh mi mj ly b">SKStoreProductViewController</code>，允许在应用程序内启动更新。</p><p id="a56b" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">为了显示UI，只需将更新检查返回的<code class="du mh mi mj ly b">UpdatesResult</code>值传递给UI，如下所示:</p><pre class="iy iz ja jb fd lx ly lz ma aw mb bi"><span id="3555" class="kg kh hi ly b fi mc md l me mf">Updates.checkForUpdates { result in</span><span id="9036" class="kg kh hi ly b fi mg md l me mf">    UpdatesUI.promptToUpdate(result, presentingViewController: self)</span><span id="b334" class="kg kh hi ly b fi mg md l me mf">}</span></pre><h1 id="45a5" class="lg kh hi bd ki lh li lj km lk ll lm kq io ln ip kt ir lo is kw iu lp iv kz lq bi translated">摘要</h1><p id="1ba7" class="pw-post-body-paragraph jj jk hi jl b jm lb ij jo jp lc im jr js ld ju jv jw le jy jz ka lf kc kd ke hb bi translated">无论是在紧急情况下，还是作为计划更新的一部分，如放弃对旧版本iOS的支持，开发人员都应该谨慎地计划将用户迁移到最新版本的应用程序。Updates是一个旨在帮助开发人员完成这项任务的框架，它可以自动检测App Store中哪里有新版本的应用程序，并向用户提供一个可选的预配置UI组件，轻轻推动他们进行更新。</p><p id="014e" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">如果要在开发新功能以向用户交付价值和开发功能以将用户迁移到最新版本的应用程序之间做出选择，前者可能会胜出，从而使开发开销最小的迁移解决方案受益。</p><h1 id="c263" class="lg kh hi bd ki lh li lj km lk ll lm kq io ln ip kt ir lo is kw iu lp iv kz lq bi translated">挑战</h1><ul class=""><li id="2a69" class="mk ml hi jl b jm lb jp lc js my jw mz ka na ke mp mq mr ms bi translated">不像在网络上，开发者不能回滚应用部署。相反，他们必须尝试将用户迁移到最新版本的应用程序上，以便解决问题。</li><li id="1eed" class="mk ml hi jl b jm mt jp mu js mv jw mw ka mx ke mp mq mr ms bi translated">如果停止对旧版本iOS的支持，旧版本iOS的用户将不会收到App Store的应用程序更新通知(直到他们有资格通过更新iOS来下载它们)。开发者可能希望用户知道，一旦他们更新，新版本的应用程序就可用了。</li><li id="cfb6" class="mk ml hi jl b jm mt jp mu js mv jw mw ka mx ke mp mq mr ms bi translated">托管后端系统以让用户知道有应用程序更新可用并手动保持更新可能很麻烦。</li></ul><h1 id="1c63" class="lg kh hi bd ki lh li lj km lk ll lm kq io ln ip kt ir lo is kw iu lp iv kz lq bi translated">优势</h1><ul class=""><li id="aceb" class="mk ml hi jl b jm lb jp lc js my jw mz ka na ke mp mq mr ms bi translated">更新可以自动查询应用程序的新版本是否可用，并以最少的配置向用户显示提示。</li><li id="2927" class="mk ml hi jl b jm mt jp mu js mv jw mw ka mx ke mp mq mr ms bi translated">提供的UI组件允许用户无缝更新，而不必离开应用程序。</li><li id="c8f3" class="mk ml hi jl b jm mt jp mu js mv jw mw ka mx ke mp mq mr ms bi translated">可用于仅向设备上有资格接收更新的用户显示更新消息，或者仅向需要更新iOS才能接收更新的用户显示更新消息。</li><li id="8599" class="mk ml hi jl b jm mt jp mu js mv jw mw ka mx ke mp mq mr ms bi translated">自动处理挑战，例如查询正确的App Store区域。</li></ul></div><div class="ab cl nb nc gp nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="hb hc hd he hf"><p id="3862" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><em class="kf">更新可以在麻省理工学院许可下的</em> <a class="ae lr" href="https://github.com/rwbutler/updates" rel="noopener ugc nofollow" target="_blank"> <em class="kf"> GitHub </em> </a> <em class="kf">上找到，并且兼容</em><a class="ae lr" href="https://cocoapods.org/pods/Updates" rel="noopener ugc nofollow" target="_blank"><em class="kf">Cocoapods</em></a><em class="kf">和Carthage。</em></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ni"><img src="../Images/46abe3e97ddb299b17f3d1c96e7f4e6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:300/format:webp/1*uMjEQmhxpoVQ001N3PmSyg.png"/></div></figure></div></div>    
</body>
</html>