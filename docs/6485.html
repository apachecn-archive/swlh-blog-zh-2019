<html>
<head>
<title>Layman’s iptables 101</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">外行人的iptables 101</h1>
<blockquote>原文：<a href="https://medium.com/swlh/https-medium-com-iximiuz-laymans-iptables-101-9277f9072afb?source=collection_archive---------7-----------------------#2019-06-21">https://medium.com/swlh/https-medium-com-iximiuz-laymans-iptables-101-9277f9072afb?source=collection_archive---------7-----------------------#2019-06-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="6adb" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">序</h1><p id="b919" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">哎呀，现在轮到我来介绍iptables了！有数百甚至数千篇关于这个主题的文章，包括介绍性的文章。我不会把正式的<a class="ae kb" href="https://www.netfilter.org/projects/iptables/index.html" rel="noopener ugc nofollow" target="_blank">定义</a>放在这里，也不会把<a class="ae kb" href="https://www.digitalocean.com/community/tutorials/how-to-list-and-delete-iptables-firewall-rules" rel="noopener ugc nofollow" target="_blank">有用命令</a>的列在<a class="ae kb" href="https://www.digitalocean.com/community/tutorials/iptables-essentials-common-firewall-rules-and-commands" rel="noopener ugc nofollow" target="_blank">里。在阅读所有这些<em class="kc">表格</em>、<em class="kc">规则</em>、<em class="kc">目标</em>和<em class="kc">政策</em>之前，我宁愿尝试使用外行的术语并尽可能地潦草地给你一些关于该领域的见解。顺便说一下，当我第一次面对这个工具时，我也被这个术语搞糊涂了！</a></p><p id="6399" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kf jq jr js kg ju jv jw kh jy jz ka hb bi translated">大概你已经知道<strong class="jf ki"> iptables </strong>跟<strong class="jf ki"> IP </strong>包有关系。也许更深一层——数据包过滤。还是最深的——包修改！也许你已经听说过，一切都发生在内核端，不涉及用户空间代码。为此，iptables提供了一种特殊的语法来编码不同的影响包的规则…</p><h1 id="a4a9" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">Linux网络堆栈</h1><p id="51b6" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">…但是在试图对内核空间中的数据包的幸福生活产生影响之前，让我们试着理解它们的世界。当包被创建时，它们在内核中的路径是什么，它们的来源和目的地是什么，等等？看看下面的场景:</p><ul class=""><li id="0fa9" class="kj kk hi jf b jg kd jk ke jo kl js km jw kn ka ko kp kq kr bi translated">数据包到达网络接口，通过网络堆栈，到达用户空间进程。</li><li id="ddac" class="kj kk hi jf b jg ks jk kt jo ku js kv jw kw ka ko kp kq kr bi translated">数据包由用户空间进程创建，发送到网络堆栈，然后传送到网络接口。</li><li id="2ae9" class="kj kk hi jf b jg ks jk kt jo ku js kv jw kw ka ko kp kq kr bi translated">数据包到达网络接口，然后根据某些路由规则被转发到另一个网络接口。</li></ul><p id="d200" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kf jq jr js kg ju jv jw kh jy jz ka hb bi translated">所有这些场景中的<em class="kc">共性</em>是什么？基本上，它们都描述了从一个网络接口通过网络栈到一个用户空间进程(或另一个接口)的数据包路径的铺设和返回。当我在这里说<em class="kc">一个网络栈</em>时，我只是指由Linux内核提供的处理网络数据传输和接收的一堆层。</p><figure class="ky kz la lb fd lc er es paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="er es kx"><img src="../Images/5e50337a9911c2c4305a637a1309562d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*YQxJguBdbN5uhBL9.png"/></div></div></figure><p id="6cec" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kf jq jr js kg ju jv jw kh jy jz ka hb bi translated">中间的路由部分由Linux内核的内置能力提供，也称为<em class="kc"> IP转发</em>。向<code class="du lj lk ll lm b">/proc/sys/net/ipv4/ip_forward</code>文件发送一个非零值激活不同网络接口之间的数据包转发，有效地将Linux机器转变为虚拟路由器。</p><p id="7761" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kf jq jr js kg ju jv jw kh jy jz ka hb bi translated">显而易见，设计合理的网络堆栈应该具有不同的数据包处理逻辑阶段。例如，<em class="kc">预路由</em>阶段可以位于数据包接收和实际路由过程之间。另一个例子是<em class="kc">输入</em>阶段，它位于用户空间进程之前。</p><figure class="ky kz la lb fd lc er es paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="er es kx"><img src="../Images/d9d1c7c5d568729159251fba76b39eb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*qMfKCKWM1YaMbSp_.png"/></div></div></figure><p id="6f28" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kf jq jr js kg ju jv jw kh jy jz ka hb bi translated">事实上，Linux network stack确实提供了这种阶段的逻辑分离。现在，让我们回到我们的主要任务—数据包过滤和/或更改。如果我们想丢弃一些到达<em class="kc"> a.out </em>进程的数据包，该怎么办？例如，我们可能不喜欢带有某个特定源IP地址的数据包，因为我们怀疑这个IP地址属于某个恶意用户。如果在网络堆栈中有一个钩子，对应于输入阶段，并允许一些额外的逻辑应用于输入包，那就太好了。在我们的例子中，我们可能希望注入一个函数来检查数据包的源IP地址，并根据这个信息决定是丢弃还是接受数据包。</p><p id="681b" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kf jq jr js kg ju jv jw kh jy jz ka hb bi translated">概括地说，我们需要一种方法来注册一个任意的回调函数，以便在给定阶段对每个传入的包执行。幸运的是，有一个名为<a class="ae kb" href="https://www.netfilter.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="jf ki"> netfilter </strong> </a>的项目正好提供了这种功能！netfilter的代码驻留在Linux内核中，并将所有这些扩展点(<em class="kc">即钩子</em>)添加到网络堆栈的不同阶段。值得注意的是，<em class="kc"> iptables </em>只是配置netfilter钩子的几个用户空间前端工具之一。这里还要注意的是，netfilter的功能不受网络(即IP)层的限制，例如，修改以太网帧也是可能的。然而，顾名思义，<strong class="jf ki"> ip </strong> tables关注的是从<a class="ae kb" href="https://en.wikipedia.org/wiki/Network_layer" rel="noopener ugc nofollow" target="_blank">网络</a> ( <strong class="jf ki"> IP </strong>)开始的层及以上。</p><h1 id="d6a5" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">链条(开始)</h1><p id="bb23" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">现在，让我们最终尝试理解iptables术语。您可能已经注意到，我们在网络堆栈中使用的名称对应于iptables。但是究竟为什么有人会用<em class="kc">链</em>这个词呢？我不知道背后有什么趣闻，但解释这种命名的一种方法是看一下用法:</p><pre class="ky kz la lb fd ln lm lo lp aw lq bi"><span id="37c1" class="lr ig hi lm b fi ls lt l lu lv"><em class="kc"># add rule "LOG every packet" to chain INPUT </em><br/>$ iptables --append INPUT --jump LOG </span><span id="6306" class="lr ig hi lm b fi lw lt l lu lv"><em class="kc"># add rule "DROP every packet" to chain INPUT </em><br/>$ iptables --append INPUT --jump DROP</span></pre><p id="81dd" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kf jq jr js kg ju jv jw kh jy jz ka hb bi translated">在上面的代码片段中，我们向输入<em class="kc">阶段</em>添加了多个回调，这绝对是合法的iptables用法。这意味着回调的执行顺序必须被定义。实际上，当一个新的包到达时，首先执行第一个添加的回调(记录包)，然后执行第二个回调(丢弃包)。因此，我们所有的回调都在一个！但是这个链是由它所在的逻辑阶段命名的。现在，让我们结束链，转到iptables的其他部分。稍后，我们将会看到，在链抽象中有一些模糊性。</p><h1 id="bef1" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">规则、目标和政策</h1><p id="3486" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">接下来,<em class="kc">是规则</em>。我们在上面的例子中使用的规则是基本的。首先，我们无条件地为输入链中的每个数据包记录一个内核消息，然后我们无条件地从网络堆栈中丢弃每个数据包。然而，规则可以更复杂。一般来说，规则为数据包和<em class="kc">目标</em>指定标准。为了简单起见，现在让我们将<em class="kc">目标</em>定义为一个动作，如记录、接受或丢弃，并看一些例子:</p><pre class="ky kz la lb fd ln lm lo lp aw lq bi"><span id="cb82" class="lr ig hi lm b fi ls lt l lu lv"><em class="kc"># block packets with source IP 46.36.222.157 <br/># -A is a shortcut for --append <br/># -j is a shortcut for --jump </em><br/>$ iptables -A INPUT -s 46.36.222.157 -j DROP </span><span id="a8a4" class="lr ig hi lm b fi lw lt l lu lv"><em class="kc"># block outgoing SSH connections</em><br/>$ iptables -A OUTPUT -p tcp --dport 22 -j DROP </span><span id="000d" class="lr ig hi lm b fi lw lt l lu lv"><em class="kc"># allow all incoming HTTP(S) connections</em><br/>$ iptables -A INPUT -p tcp -m multiport --dports 80,443  \ <br/>    -m conntrack --ctstate NEW,ESTABLISHED -j ACCEPT <br/>$ iptables -A OUTPUT -p tcp -m multiport --dports 80,443 \ <br/>    -m conntrack --ctstate ESTABLISHED -j ACCEPT</span></pre><p id="849d" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kf jq jr js kg ju jv jw kh jy jz ka hb bi translated">正如我们所看到的，规则的标准可能相当复杂。在决定采取行动之前，我们可以检查数据包的多个属性，甚至TCP连接的一些属性(由于<em class="kc"> conntrack </em>模块，这意味着netfilter是有状态的)。对此我很抱歉，但作为一名程序员，我需要编写一些代码:</p><pre class="ky kz la lb fd ln lm lo lp aw lq bi"><span id="cd01" class="lr ig hi lm b fi ls lt l lu lv">def handle_packet(packet, chain): <br/>    for rule in chain: <br/>        modules = rule.modules <br/>        for m in modules: <br/>            m.ensure_loaded() </span><span id="6b83" class="lr ig hi lm b fi lw lt l lu lv">        conditions = rule.conditions <br/>        if all(c.apply(packet) for c in conditions): <br/>            <em class="kc"># terminal target, break the chain </em><br/>            if rule.target in ('ACCEPT', 'DROP'): <br/>                return rule.target </span><span id="d2a7" class="lr ig hi lm b fi lw lt l lu lv">            <em class="kc"># TODO: handle other targets </em></span><span id="c427" class="lr ig hi lm b fi lw lt l lu lv"><em class="kc">    # TODO: what shall we do if there is no single <br/>    #       terminal target in the whole chain?</em></span></pre><p id="957a" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kf jq jr js kg ju jv jw kh jy jz ka hb bi translated">这个想法很简单。按顺序应用链中的所有规则，直到遇到终端目标或到达链的末尾。这里我们可以注意到伪代码中一个未覆盖的分支。我们需要一个默认的<em class="kc">动作</em>(即目标)，用于设法到达链末端而没有同时被分派到任何终端目标的数据包。而设置它的方式叫做<strong class="jf ki">策略</strong>:</p><pre class="ky kz la lb fd ln lm lo lp aw lq bi"><span id="0ad5" class="lr ig hi lm b fi ls lt l lu lv"><em class="kc"># check the default policies</em><br/>$ sudo iptables --list-rules # or -S<br/>-P INPUT ACCEPT <br/>-P FORWARD ACCEPT <br/>-P OUTPUT ACCEPT </span><span id="7bb6" class="lr ig hi lm b fi lw lt l lu lv"><em class="kc"># change policy for chain FORWARD to target DROP</em><br/>$ iptables --policy FORWARD DROP # or -P</span></pre><h1 id="3521" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">链条(续)</h1><p id="b72b" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">最后，让我们了解一下为什么目标被称为<em class="kc">目标</em>，而不是行动或其他什么。让我们看看我们用来设置规则<code class="du lj lk ll lm b">iptables -A INPUT -s 46.36.222.157 -j DROP</code>的命令，其中<code class="du lj lk ll lm b">-j</code>代表<code class="du lj lk ll lm b">--jumps</code>。也就是说，作为规则的结果，我们可以<em class="kc">跳跃</em>到一个目标。从<code class="du lj lk ll lm b">man iptables</code>开始:</p><pre class="ky kz la lb fd ln lm lo lp aw lq bi"><span id="7ed4" class="lr ig hi lm b fi ls lt l lu lv">-j, --jump target</span><span id="c03a" class="lr ig hi lm b fi lw lt l lu lv">        This specifies the target of the rule; i.e., <br/>        what to do if the packet matches it. The target <br/>        can be a user-defined chain (other than the one <br/>        this rule is in), one of the special builtin <br/>        targets which decide the fate of the packet <br/>        immediately, or an extension (see EXTENSIONS below).</span></pre><p id="8901" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kf jq jr js kg ju jv jw kh jy jz ka hb bi translated">在这里！<strong class="jf ki">用户自定义链！像往常一样，首先让我们来看看这个例子:</strong></p><pre class="ky kz la lb fd ln lm lo lp aw lq bi"><span id="634d" class="lr ig hi lm b fi ls lt l lu lv">$ iptables -P INPUT ACCEPT<br/><em class="kc"># drop all forwards by default</em><br/>$ iptables -P FORWARD DROP <br/>$ iptables -P OUTPUT ACCEPT </span><span id="99ce" class="lr ig hi lm b fi lw lt l lu lv"><em class="kc"># create a new chain</em><br/>$ iptables -N DOCKER <em class="kc"># or --new-chain </em></span><span id="65fd" class="lr ig hi lm b fi lw lt l lu lv"><em class="kc"># if outgoing interface is docker0, jump to DOCKER chain</em><br/>$ iptables -A FORWARD -o docker0 -j DOCKER </span><span id="e19b" class="lr ig hi lm b fi lw lt l lu lv"><em class="kc"># add some specific to Docker rules to the user-defined chain</em><br/>$ iptables -A DOCKER ... <br/>$ iptables -A DOCKER ... <br/>$ iptables -A DOCKER ... </span><span id="0059" class="lr ig hi lm b fi lw lt l lu lv"><em class="kc"># jump back to the caller (i.e. FORWARD) chain</em><br/>$ iptables -A DOCKER -j RETURN</span></pre><p id="0742" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kf jq jr js kg ju jv jw kh jy jz ka hb bi translated">但是为什么呢？正如我们在上面看到的，链与网络堆栈的预定义逻辑阶段有着一一对应的关系。用户可以定义自己的链这一事实是否意味着我们可以为内核的处理管道引入新的阶段？我不这么认为。我可能完全错了，但对我来说，这似乎违反了<a class="ae kb" href="https://en.wikipedia.org/wiki/Single_responsibility_principle" rel="noopener ugc nofollow" target="_blank">单一责任原则</a>。一个<em class="kc">链</em>似乎是一个命名规则序列的很好的抽象。在传统编程语言中，链和<a class="ae kb" href="https://en.wikipedia.org/wiki/Subroutine" rel="noopener ugc nofollow" target="_blank">命名的子程序</a>(又名函数，又名过程)有一些相似之处。从一个链中的任意位置跳到另一个链的开头，然后返回到调用方链的能力使得相似性更强。但是，<em class="kc">预路由</em>、<em class="kc">输入</em>、<em class="kc">正向</em>、<em class="kc">输出</em>和<em class="kc">后路由</em>链具有特殊含义，不能被覆盖。我可以在一些具有特殊用途的编程语言中看到与<em class="kc"> main() </em>函数的一些相似之处，但是链的这种双端性质使得iptables的学习曲线对我来说相当陡峭。</p><p id="08af" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kf jq jr js kg ju jv jw kh jy jz ka hb bi translated">总而言之，用户定义的链是一种特殊的目标，用作规则的命名序列。用户定义链的功能相当有限。例如，用户定义的链不能有策略。从<code class="du lj lk ll lm b">man iptables</code>开始:</p><pre class="ky kz la lb fd ln lm lo lp aw lq bi"><span id="0afc" class="lr ig hi lm b fi ls lt l lu lv">-P, --policy chain target </span><span id="b24b" class="lr ig hi lm b fi lw lt l lu lv">        Set the policy for the chain to the given target. <br/>        See the section TARGETS for the legal targets. Only <br/>        built-in (non-user-defined) chains can have policies, <br/>        and neither built-in nor user-defined chains can be <br/>        policy targets.</span></pre><figure class="ky kz la lb fd lc er es paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="er es lx"><img src="../Images/eb7be03f1430d00396fffa111012b84d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*fLuuMbMmtf5FjSVo.png"/></div></div></figure><p id="2291" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kf jq jr js kg ju jv jw kh jy jz ka hb bi translated">显然，上面的代码片段应该进行重大重写，以包含用户定义链的处理。</p><h1 id="3747" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">桌子</h1><p id="ff67" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">嗯，我们快到了！我们已经讨论了<em class="kc">链条</em>、<em class="kc">规则</em>和<em class="kc">政策</em>。现在终于到了学习桌子的时候了。毕竟这个工具叫ip <strong class="jf ki">表</strong>。</p><p id="5719" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kf jq jr js kg ju jv jw kh jy jz ka hb bi translated">实际上，在上面的所有例子中，我们都隐式地使用了一个名为<code class="du lj lk ll lm b">filter</code>的表。我不确定一个<em class="kc">表</em>的官方定义，但是我总是把一个表称为一个逻辑分组和链的隔离。正如我们已经知道的，有一个管理数据包过滤的链表。但是，如果我们要修改一些包，还有另外一个表，叫做<em class="kc"> mangle </em>。能够在转发阶段过滤数据包是绝对合理的要求。然而，在那个阶段修改包也是可以的。因此，<em class="kc">过滤器</em>和<em class="kc">轧车</em>工作台都将有前进链。然而，这些链是完全独立的。</p><p id="f162" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kf jq jr js kg ju jv jw kh jy jz ka hb bi translated">不同版本的内核支持的表的数量会有所不同，但最突出的表通常都在这里:</p><pre class="ky kz la lb fd ln lm lo lp aw lq bi"><span id="1c6f" class="lr ig hi lm b fi ls lt l lu lv">filter:<br/>    This is the default table (if no -t option is passed). <br/>    It contains the built-in chains INPUT (for packets destined <br/>    to local sockets), FORWARD (for packets being routed through <br/>    the box), and OUTPUT (for locally-generated packets).</span><span id="e70a" class="lr ig hi lm b fi lw lt l lu lv">nat: <br/>    This table is consulted when a packet that creates a new<br/>    connection is encountered. It consists of three built-ins: <br/>    PREROUTING (for altering packets as soon as they come in), <br/>    OUTPUT (for altering locally-generated packets before routing),<br/>    and POSTROUTING (for altering packets as they are about to go <br/>    out). IPv6 NAT support is available since kernel 3.7.</span><span id="a519" class="lr ig hi lm b fi lw lt l lu lv">mangle: <br/>    This table is used for specialized packet alteration. Until <br/>    kernel 2.4.17 it had two built-in chains: PREROUTING (for <br/>    altering incoming packets before routing) and OUTPUT (for <br/>    altering locally-generated packets before routing). Since <br/>    kernel 2.4.18, three other built-in chains are also supported:<br/>    INPUT (for packets coming into the box itself), FORWARD (for <br/>    altering packets being routed through the box), and POSTROUTING <br/>    (for altering packets as they are about to go out).</span><span id="4d9a" class="lr ig hi lm b fi lw lt l lu lv">raw:<br/>    This table is used mainly for configuring exemptions from <br/>    connection tracking in combination with the NOTRACK target. It <br/>    registers at the netfilter hooks with higher priority and is <br/>    thus called before ip_conntrack, or any other IP tables. It <br/>    provides the following built-in chains: PREROUTING (for packets <br/>    arriving via any network interface) OUTPUT (for packets <br/>    generated by local processes).</span></pre><p id="102c" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kf jq jr js kg ju jv jw kh jy jz ka hb bi translated">这里真正有趣的是桌子之间链条的碰撞。如果<em class="kc">过滤，一个数据包会发生什么？输入</em>链有一个掉落目标，但<em class="kc">损坏。输入</em>链有一个接受目标，两者都在肯定规则内？哪个链优先级更高？我们试着去看看吧！</p><p id="337b" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kf jq jr js kg ju jv jw kh jy jz ka hb bi translated">为此，我们需要将日志目标添加到所有表的所有链中，并进行以下实验:</p><figure class="ky kz la lb fd lc er es paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="er es lx"><img src="../Images/1c82bee6845a70adb093537463e74f72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*XYbnCEU8v5dmVGDR.png"/></div></div></figure><p id="73bd" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kf jq jr js kg ju jv jw kh jy jz ka hb bi translated">我们需要同一流上的客户机和路由器网络栈的日志，以便对表和链之间的关系有一个全面的了解。为此，我们将通过使用<a class="ae kb" href="https://en.wikipedia.org/wiki/Linux_namespaces#Network_(net)" rel="noopener ugc nofollow" target="_blank">网络名称空间</a>特性在一台Linux主机上模拟2台机器。实验的主要部分是记录IP数据包。长期以来，非根命名空间的日志目标被禁用，以防止潜在的主机拒绝来自隔离进程的服务。幸运的是，从Linux内核4.11开始，有一种方法可以通过向<code class="du lj lk ll lm b">/proc/sys/net/netfilter/nf_log_all_netns</code>发送一个非零值来启用名称空间的netfilter日志。<strong class="jf ki">但是生产上不要这样！</strong></p><p id="c161" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kf jq jr js kg ju jv jw kh jy jz ka hb bi translated">首先，让我们创建一个网络名称空间:</p><pre class="ky kz la lb fd ln lm lo lp aw lq bi"><span id="39b8" class="lr ig hi lm b fi ls lt l lu lv"><em class="kc"># run on host:<br/></em>$ unshare -r --net bash</span><span id="5034" class="lr ig hi lm b fi lw lt l lu lv"><em class="kc"># namespace (same terminal session):</em><br/>$ echo $$ 2979<em class="kc">  # remember this PID</em></span></pre><p id="0b8c" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kf jq jr js kg ju jv jw kh jy jz ka hb bi translated">在第二个终端中，我们需要配置主机:</p><pre class="ky kz la lb fd ln lm lo lp aw lq bi"><span id="9c41" class="lr ig hi lm b fi ls lt l lu lv"><em class="kc"># run on host:</em></span><span id="b09f" class="lr ig hi lm b fi lw lt l lu lv">$ sudo -i</span><span id="3934" class="lr ig hi lm b fi lw lt l lu lv"><em class="kc"># create a veth interface</em><br/>$ ip link add vGUEST type veth peer name vHOST</span><span id="154c" class="lr ig hi lm b fi lw lt l lu lv"><em class="kc"># move one of its peers to network namespace</em><br/>$ ip link set vGUEST netns 2979  # PID from above</span><span id="8c06" class="lr ig hi lm b fi lw lt l lu lv"><em class="kc"># create linux bridge</em><br/>$ ip link add br0 type bridge</span><span id="7f8f" class="lr ig hi lm b fi lw lt l lu lv"><em class="kc"># wire vHOST to br0</em><br/>$ ip link set vHOST master br0</span><span id="6512" class="lr ig hi lm b fi lw lt l lu lv"><em class="kc"># set IP addresses and bring devices up</em><br/>$ ip addr add 172.16.0.1/16 dev br0<br/>$ ip link set br0 up $ ip link set vHOST up</span><span id="0e7a" class="lr ig hi lm b fi lw lt l lu lv"><em class="kc"># turn the host into a virtual router</em><br/>$ iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE<br/>$ echo 1 &gt; /proc/sys/net/ipv4/ip_forward</span><span id="e097" class="lr ig hi lm b fi lw lt l lu lv"><em class="kc"># and don't forget to enable netfilter logs in namespaces</em><br/>$ echo 1 &gt; /proc/sys/net/netfilter/nf_log_all_netns</span></pre><p id="1cf0" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kf jq jr js kg ju jv jw kh jy jz ka hb bi translated">现在完成名称空间端的网络接口设置:</p><pre class="ky kz la lb fd ln lm lo lp aw lq bi"><span id="bcb2" class="lr ig hi lm b fi ls lt l lu lv"><em class="kc"># run in network namespace:</em></span><span id="4cfe" class="lr ig hi lm b fi lw lt l lu lv"><em class="kc"># bring devices up</em><br/>$ ip link set lo up<br/>$ ip link set vGUEST up</span><span id="5e7d" class="lr ig hi lm b fi lw lt l lu lv"><em class="kc"># configure IP address</em><br/>$ ip addr add 172.16.0.2/16 dev vGUEST</span><span id="9185" class="lr ig hi lm b fi lw lt l lu lv"><em class="kc"># set default route via br0</em><br/>$ ip route add default via 172.16.0.1</span></pre><p id="00cc" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kf jq jr js kg ju jv jw kh jy jz ka hb bi translated">签出并更新命名空间中的iptables规则:</p><pre class="ky kz la lb fd ln lm lo lp aw lq bi"><span id="7e6e" class="lr ig hi lm b fi ls lt l lu lv"><em class="kc"># run in network namespace:</em></span><span id="ee92" class="lr ig hi lm b fi lw lt l lu lv">$ iptables -S -t filter<br/>-P INPUT ACCEPT<br/>-P FORWARD ACCEPT<br/>-P OUTPUT ACCEPT</span><span id="47f6" class="lr ig hi lm b fi lw lt l lu lv">$ iptables -S -t nat<br/>-P PREROUTING ACCEPT<br/>-P INPUT ACCEPT<br/>-P OUTPUT ACCEPT<br/>-P POSTROUTING ACCEPT</span><span id="d8a0" class="lr ig hi lm b fi lw lt l lu lv">$ iptables -S -t mangle<br/>-P PREROUTING ACCEPT<br/>-P INPUT ACCEPT<br/>-P FORWARD ACCEPT<br/>-P OUTPUT ACCEPT<br/>-P POSTROUTING ACCEPT</span><span id="b4a8" class="lr ig hi lm b fi lw lt l lu lv">$ iptables -S -t raw<br/>-P PREROUTING ACCEPT<br/>-P OUTPUT ACCEPT</span><span id="10bc" class="lr ig hi lm b fi lw lt l lu lv">$ iptables -t filter -A INPUT \<br/>    -j LOG --log-prefix "NETNS_FILTER_INPUT "<br/>$ iptables -t filter -A FORWARD \<br/>    -j LOG --log-prefix "NETNS_FILTER_FORWARD "<br/>$ iptables -t filter -A OUTPUT \<br/>    -j LOG --log-prefix "NETNS_FILTER_OUTPUT "</span><span id="866b" class="lr ig hi lm b fi lw lt l lu lv">$ iptables -t nat -A PREROUTING \<br/>    -j LOG --log-prefix "NETNS_NAT_PREROUTE "<br/>$ iptables -t nat -A INPUT \<br/>    -j LOG --log-prefix "NETNS_NAT_INPUT "<br/>$ iptables -t nat -A OUTPUT \<br/>    -j LOG --log-prefix "NETNS_NAT_OUTPUT "<br/>$ iptables -t nat -A POSTROUTING \<br/>    -j LOG --log-prefix "NETNS_NAT_POSTROUTE "</span><span id="3670" class="lr ig hi lm b fi lw lt l lu lv">$ iptables -t mangle -A PREROUTING \<br/>    -j LOG --log-prefix "NETNS_MANGLE_PREROUTE "<br/>$ iptables -t mangle -A INPUT \<br/>    -j LOG --log-prefix "NETNS_MANGLE_INPUT "<br/>$ iptables -t mangle -A FORWARD \<br/>    -j LOG --log-prefix "NETNS_MANGLE_FORWARD "<br/>$ iptables -t mangle -A OUTPUT \<br/>    -j LOG --log-prefix "NETNS_MANGLE_OUTPUT "<br/>$ iptables -t mangle -A POSTROUTING \<br/>    -j LOG --log-prefix "NETNS_MANGLE_POSTROUTE "</span><span id="9654" class="lr ig hi lm b fi lw lt l lu lv">$ iptables -t raw -A PREROUTING \<br/>    -j LOG --log-prefix "NETNS_RAW_PREROUTE "<br/>$ iptables -t raw -A OUTPUT \<br/>    -j LOG --log-prefix "NETNS_RAW_OUTPUT "</span></pre><p id="e768" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kf jq jr js kg ju jv jw kh jy jz ka hb bi translated">请注意，主机上的iptables规则不受名称空间设置的影响:</p><pre class="ky kz la lb fd ln lm lo lp aw lq bi"><span id="cf14" class="lr ig hi lm b fi ls lt l lu lv"># run on host:</span><span id="6723" class="lr ig hi lm b fi lw lt l lu lv">$ iptables -S -t filter<br/>-P INPUT ACCEPT<br/>-P FORWARD ACCEPT<br/>-P OUTPUT ACCEPT</span><span id="7914" class="lr ig hi lm b fi lw lt l lu lv">$ iptables -S -t nat<br/>-P PREROUTING ACCEPT<br/>-P INPUT ACCEPT<br/>-P OUTPUT ACCEPT<br/>-P POSTROUTING ACCEPT<br/>-A POSTROUTING -o eth0 -j MASQUERADE</span><span id="d663" class="lr ig hi lm b fi lw lt l lu lv">$ iptables -S -t mangle<br/>-P PREROUTING ACCEPT<br/>-P INPUT ACCEPT<br/>-P FORWARD ACCEPT<br/>-P OUTPUT ACCEPT<br/>-P POSTROUTING ACCEPT</span><span id="e60d" class="lr ig hi lm b fi lw lt l lu lv">$ iptables -S -t raw<br/>-P PREROUTING ACCEPT<br/>-P OUTPUT ACCEPT</span></pre><p id="ada4" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kf jq jr js kg ju jv jw kh jy jz ka hb bi translated">更新主机上的iptables规则:</p><pre class="ky kz la lb fd ln lm lo lp aw lq bi"><span id="b06e" class="lr ig hi lm b fi ls lt l lu lv"><em class="kc"># run on host:</em></span><span id="605f" class="lr ig hi lm b fi lw lt l lu lv">$ iptables -t filter -A INPUT \<br/>    -j LOG --log-prefix "HOST_FILTER_INPUT "<br/>$ iptables -t filter -A FORWARD \<br/>    -j LOG --log-prefix "HOST_FILTER_FORWARD "<br/>$ iptables -t filter -A OUTPUT \<br/>    -j LOG --log-prefix "HOST_FILTER_OUTPUT "</span><span id="0fe7" class="lr ig hi lm b fi lw lt l lu lv">$ iptables -t nat -A PREROUTING \<br/>    -j LOG --log-prefix "HOST_NAT_PREROUTE "<br/>$ iptables -t nat -A INPUT \<br/>    -j LOG --log-prefix "HOST_NAT_INPUT "<br/>$ iptables -t nat -A OUTPUT \<br/>    -j LOG --log-prefix "HOST_NAT_OUTPUT "<br/>$ iptables -t nat -A POSTROUTING \<br/>    -j LOG --log-prefix "HOST_NAT_POSTROUTE "</span><span id="dd1a" class="lr ig hi lm b fi lw lt l lu lv">$ iptables -t mangle -A PREROUTING \<br/>    -j LOG --log-prefix "HOST_MANGLE_PREROUTE "<br/>$ iptables -t mangle -A INPUT \<br/>    -j LOG --log-prefix "HOST_MANGLE_INPUT "<br/>$ iptables -t mangle -A FORWARD \<br/>    -j LOG --log-prefix "HOST_MANGLE_FORWARD "<br/>$ iptables -t mangle -A OUTPUT \<br/>    -j LOG --log-prefix "HOST_MANGLE_OUTPUT "<br/>$ iptables -t mangle -A POSTROUTING \<br/>    -j LOG --log-prefix "HOST_MANGLE_POSTROUTE "</span><span id="a80e" class="lr ig hi lm b fi lw lt l lu lv">$ iptables -t raw -A PREROUTING \<br/>    -j LOG --log-prefix "HOST_RAW_PREROUTE "<br/>$ iptables -t raw -A OUTPUT \<br/>    -j LOG --log-prefix "HOST_RAW_OUTPUT "</span></pre><p id="b83d" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kf jq jr js kg ju jv jw kh jy jz ka hb bi translated">最后从名称空间ping <em class="kc">8.8.8.8</em>，同时在主机上ping<code class="du lj lk ll lm b">tailf</code>内核消息:</p><pre class="ky kz la lb fd ln lm lo lp aw lq bi"><span id="24cf" class="lr ig hi lm b fi ls lt l lu lv"><em class="kc"># run in network namespace:</em><br/>$ ping 8.8.8.8</span><span id="6031" class="lr ig hi lm b fi lw lt l lu lv"><em class="kc"># run on host:</em><br/>$ tail -f /var/log/messages</span></pre><p id="6021" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kf jq jr js kg ju jv jw kh jy jz ka hb bi translated">现在，如果我们开始ping一个外部地址，比如<em class="kc">8.8.8.8</em>，我们可以注意到netfilter日志中出现了一个有趣的模式:</p><pre class="ky kz la lb fd ln lm lo lp aw lq bi"><span id="4e26" class="lr ig hi lm b fi ls lt l lu lv">Jun 21 13:25:19 localhost kernel: NETNS_RAW_OUTPUT IN= OUT=vGUEST SRC=172.16.0.2 DST=8.8.8.8 LEN=84 TOS=0x00 PREC=0x00 TTL=64 ID=2089 DF PROTO=ICMP TYPE=8 CODE=0 ID=3197 SEQ=34<br/>Jun 21 13:25:19 localhost kernel: NETNS_MANGLE_OUTPUT IN= OUT=vGUEST SRC=172.16.0.2 DST=8.8.8.8 LEN=84 TOS=0x00 PREC=0x00 TTL=64 ID=2089 DF PROTO=ICMP TYPE=8 CODE=0 ID=3197 SEQ=34<br/>Jun 21 13:25:19 localhost kernel: NETNS_FILTER_OUTPUT IN= OUT=vGUEST SRC=172.16.0.2 DST=8.8.8.8 LEN=84 TOS=0x00 PREC=0x00 TTL=64 ID=2089 DF PROTO=ICMP TYPE=8 CODE=0 ID=3197 SEQ=34<br/>Jun 21 13:25:19 localhost kernel: NETNS_MANGLE_POSTROUTE IN= OUT=vGUEST SRC=172.16.0.2 DST=8.8.8.8 LEN=84 TOS=0x00 PREC=0x00 TTL=64 ID=2089 DF PROTO=ICMP TYPE=8 CODE=0 ID=3197 SEQ=34<br/>Jun 21 13:25:19 localhost kernel: HOST_RAW_PREROUTE IN=br0 OUT= MAC=c2:96:cf:97:f4:12:c2:31:a8:8b:d7:f8:08:00 SRC=172.16.0.2 DST=8.8.8.8 LEN=84 TOS=0x00 PREC=0x00 TTL=64 ID=2089 DF PROTO=ICMP TYPE=8 CODE=0 ID=3197 SEQ=34<br/>Jun 21 13:25:19 localhost kernel: HOST_MANGLE_PREROUTE IN=br0 OUT= MAC=c2:96:cf:97:f4:12:c2:31:a8:8b:d7:f8:08:00 SRC=172.16.0.2 DST=8.8.8.8 LEN=84 TOS=0x00 PREC=0x00 TTL=64 ID=2089 DF PROTO=ICMP TYPE=8 CODE=0 ID=3197 SEQ=34<br/>Jun 21 13:25:19 localhost kernel: HOST_MANGLE_FORWARD IN=br0 OUT=eth0 MAC=c2:96:cf:97:f4:12:c2:31:a8:8b:d7:f8:08:00 SRC=172.16.0.2 DST=8.8.8.8 LEN=84 TOS=0x00 PREC=0x00 TTL=63 ID=2089 DF PROTO=ICMP TYPE=8 CODE=0 ID=3197 SEQ=34<br/>Jun 21 13:25:19 localhost kernel: HOST_FILTER_FORWARD IN=br0 OUT=eth0 MAC=c2:96:cf:97:f4:12:c2:31:a8:8b:d7:f8:08:00 SRC=172.16.0.2 DST=8.8.8.8 LEN=84 TOS=0x00 PREC=0x00 TTL=63 ID=2089 DF PROTO=ICMP TYPE=8 CODE=0 ID=3197 SEQ=34<br/>Jun 21 13:25:19 localhost kernel: HOST_MANGLE_POSTROUTE IN= OUT=eth0 SRC=172.16.0.2 DST=8.8.8.8 LEN=84 TOS=0x00 PREC=0x00 TTL=63 ID=2089 DF PROTO=ICMP TYPE=8 CODE=0 ID=3197 SEQ=34<br/>Jun 21 13:25:19 localhost kernel: HOST_RAW_PREROUTE IN=eth0 OUT= MAC=52:54:00:26:10:60:52:54:00:12:35:02:08:00 SRC=8.8.8.8 DST=10.0.2.15 LEN=84 TOS=0x00 PREC=0x00 TTL=62 ID=17376 DF PROTO=ICMP TYPE=0 CODE=0 ID=3197 SEQ=34<br/>Jun 21 13:25:19 localhost kernel: HOST_MANGLE_PREROUTE IN=eth0 OUT= MAC=52:54:00:26:10:60:52:54:00:12:35:02:08:00 SRC=8.8.8.8 DST=10.0.2.15 LEN=84 TOS=0x00 PREC=0x00 TTL=62 ID=17376 DF PROTO=ICMP TYPE=0 CODE=0 ID=3197 SEQ=34<br/>Jun 21 13:25:19 localhost kernel: HOST_MANGLE_FORWARD IN=eth0 OUT=br0 MAC=52:54:00:26:10:60:52:54:00:12:35:02:08:00 SRC=8.8.8.8 DST=172.16.0.2 LEN=84 TOS=0x00 PREC=0x00 TTL=61 ID=17376 DF PROTO=ICMP TYPE=0 CODE=0 ID=3197 SEQ=34<br/>Jun 21 13:25:19 localhost kernel: HOST_FILTER_FORWARD IN=eth0 OUT=br0 MAC=52:54:00:26:10:60:52:54:00:12:35:02:08:00 SRC=8.8.8.8 DST=172.16.0.2 LEN=84 TOS=0x00 PREC=0x00 TTL=61 ID=17376 DF PROTO=ICMP TYPE=0 CODE=0 ID=3197 SEQ=34<br/>Jun 21 13:25:19 localhost kernel: HOST_MANGLE_POSTROUTE IN= OUT=br0 SRC=8.8.8.8 DST=172.16.0.2 LEN=84 TOS=0x00 PREC=0x00 TTL=61 ID=17376 DF PROTO=ICMP TYPE=0 CODE=0 ID=3197 SEQ=34<br/>Jun 21 13:25:19 localhost kernel: NETNS_RAW_PREROUTE IN=vGUEST OUT= MAC=c2:31:a8:8b:d7:f8:c2:96:cf:97:f4:12:08:00 SRC=8.8.8.8 DST=172.16.0.2 LEN=84 TOS=0x00 PREC=0x00 TTL=61 ID=17376 DF PROTO=ICMP TYPE=0 CODE=0 ID=3197 SEQ=34<br/>Jun 21 13:25:19 localhost kernel: NETNS_MANGLE_PREROUTE IN=vGUEST OUT= MAC=c2:31:a8:8b:d7:f8:c2:96:cf:97:f4:12:08:00 SRC=8.8.8.8 DST=172.16.0.2 LEN=84 TOS=0x00 PREC=0x00 TTL=61 ID=17376 DF PROTO=ICMP TYPE=0 CODE=0 ID=3197 SEQ=34<br/>Jun 21 13:25:19 localhost kernel: NETNS_MANGLE_INPUT IN=vGUEST OUT= MAC=c2:31:a8:8b:d7:f8:c2:96:cf:97:f4:12:08:00 SRC=8.8.8.8 DST=172.16.0.2 LEN=84 TOS=0x00 PREC=0x00 TTL=61 ID=17376 DF PROTO=ICMP TYPE=0 CODE=0 ID=3197 SEQ=34<br/>Jun 21 13:25:19 localhost kernel: NETNS_FILTER_INPUT IN=vGUEST OUT= MAC=c2:31:a8:8b:d7:f8:c2:96:cf:97:f4:12:08:00 SRC=8.8.8.8 DST=172.16.0.2 LEN=84 TOS=0x00 PREC=0x00 TTL=61 ID=17376 DF PROTO=ICMP TYPE=0 CODE=0 ID=3197 SEQ=34</span></pre><p id="898b" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kf jq jr js kg ju jv jw kh jy jz ka hb bi translated">日志非常冗长，但是请尽量只关注日志前缀。模式如下:</p><pre class="ky kz la lb fd ln lm lo lp aw lq bi"><span id="752c" class="lr ig hi lm b fi ls lt l lu lv">NETNS_RAW_OUTPUT<br/>NETNS_MANGLE_OUTPUT<br/>NETNS_FILTER_OUTPUT<br/>NETNS_MANGLE_POSTROUTE</span><span id="b91c" class="lr ig hi lm b fi lw lt l lu lv">HOST_RAW_PREROUTE<br/>HOST_MANGLE_PREROUTE<br/>HOST_MANGLE_FORWARD<br/>HOST_FILTER_FORWARD<br/>HOST_MANGLE_POSTROUTE<br/>HOST_RAW_PREROUTE<br/>HOST_MANGLE_PREROUTE<br/>HOST_MANGLE_FORWARD<br/>HOST_FILTER_FORWARD<br/>HOST_MANGLE_POSTROUTE</span><span id="9bec" class="lr ig hi lm b fi lw lt l lu lv">NETNS_RAW_PREROUTE<br/>NETNS_MANGLE_PREROUTE<br/>NETNS_MANGLE_INPUT<br/>NETNS_FILTER_INPUT</span></pre><p id="2aea" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kf jq jr js kg ju jv jw kh jy jz ka hb bi translated">由此，我们可以大致了解链的优先顺序。请注意，虽然我们示例中的名称空间的行为类似于普通客户机通过其默认路由向互联网发送请求，但是主机充当路由器的角色:</p><figure class="ky kz la lb fd lc er es paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="er es lx"><img src="../Images/f8d632fb0b561c4150a622560270933d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*V9GDB7iY5E5qlmvM.png"/></div></div><figcaption class="ly lz et er es ma mb bd b be z dx"><em class="mc">Chains precedence on client.</em></figcaption></figure><figure class="ky kz la lb fd lc er es paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="er es lx"><img src="../Images/7af3cee962fcdfd99ff32739d551fc5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*yNj9I6HpjM-s_ug1.png"/></div></div><figcaption class="ly lz et er es ma mb bd b be z dx"><em class="mc">Chains precedence on router.</em></figcaption></figure><h1 id="67fc" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">结论</h1><p id="dd51" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">看起来iptables似乎是一项古老的技术。花时间学有意义吗？但看看Docker或Kubernetes——蓬勃发展的前沿产品。两者都大量使用iptables来设置和管理它们的网络层！不要被愚弄，如果不学习诸如netfilter、iptables、IPVS这样的基础知识，就不可能大规模地开发或操作现代集群管理工具。</p><p id="46b8" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kf jq jr js kg ju jv jw kh jy jz ka hb bi translated">制造代码，而不是战争！</p><p id="9952" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kf jq jr js kg ju jv jw kh jy jz ka hb bi translated"><em class="kc">原载于2019年6月21日</em><a class="ae kb" href="https://iximiuz.com/en/posts/laymans-iptables-101/?utm_medium=medium&amp;utm_source=crosspost" rel="noopener ugc nofollow" target="_blank"><em class="kc">【https://iximiuz.com】</em></a><em class="kc">。</em></p></div></div>    
</body>
</html>