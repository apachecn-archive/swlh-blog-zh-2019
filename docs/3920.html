<html>
<head>
<title>Service Mesh concept explained in plain English</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用简单的英语解释服务网格概念</h1>
<blockquote>原文：<a href="https://medium.com/swlh/service-mesh-explained-in-plain-english-8e5505f74ead?source=collection_archive---------5-----------------------#2019-05-26">https://medium.com/swlh/service-mesh-explained-in-plain-english-8e5505f74ead?source=collection_archive---------5-----------------------#2019-05-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="5332" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您听说过“服务网格”这个术语，但仍然很难理解它是什么，并且承认它可能已经太晚了，那么这篇文章就是为您准备的。</p><p id="8fb6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你从谷歌搜索“什么是服务网格”开始，希望很高，第一个结果告诉你这是一个可编程的基础设施，它很可能连接服务。如果这种谷歌搜索的努力没有帮助，仍然有“很好…但是什么是服务网格？”你脑海中的问题——继续读下去。</p><p id="81f7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">本文旨在用通用且相对简单的术语解释“服务网格”的概念，它是什么以及它试图解决什么样的问题，而不回顾具体的实现。</p></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><h1 id="00a1" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">理解问题才能理解解决方案</h1><p id="985e" class="pw-post-body-paragraph if ig hi ih b ii ki ik il im kj io ip iq kk is it iu kl iw ix iy km ja jb jc hb bi translated">要理解什么是服务网格，您需要理解它正在解决什么问题。它始于一个关于独石和微服务的故事。</p><p id="c8a3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">传统上，应用程序是单一的，这意味着它是一个程序，作为一个二进制文件构建，作为一个进程运行。</p><figure class="ko kp kq kr fd ks er es paragraph-image"><div class="er es kn"><img src="../Images/95c1dbd2b6ced9326288b36b5df0fa28.png" data-original-src="https://miro.medium.com/v2/resize:fit:746/format:webp/1*Kz4gIWNpGg0CWWB3rHSxTw.png"/></div><figcaption class="kv kw et er es kx ky bd b be z dx">Monolith application is what you think of as “normal application.”</figcaption></figure><p id="0880" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">独石很简单，但它们也有自己的挑战，仅举几个例子:</p><ul class=""><li id="8d1c" class="kz la hi ih b ii ij im in iq lb iu lc iy ld jc le lf lg lh bi translated"><strong class="ih li">难以衡量。</strong>如果您的应用程序的任何单个组件需要扩展，您需要扩展整个应用程序。</li><li id="677e" class="kz la hi ih b ii lj im lk iq ll iu lm iy ln jc le lf lg lh bi translated"><strong class="ih li">难以释放。</strong>因为monolith中的一切都是紧密耦合的，所以您在应用程序中所做的任何更改都会影响代码的其他部分。将这个乘以试图同时进行变更的许多团队，得到你的版本发布地狱。</li><li id="b784" class="kz la hi ih b ii lj im lk iq ll iu lm iy ln jc le lf lg lh bi translated"><strong class="ih li">技术灵活性降低。尝试新技术(比如一门新语言)，而不把整个代码库移植到它上面，通常是有问题的。</strong></li><li id="6db7" class="kz la hi ih b ii lj im lk iq ll iu lm iy ln jc le lf lg lh bi translated"><strong class="ih li">对团队动态的影响。</strong>最后但同样重要的是，当你只有一个大的可交付成果时，就很难划分责任边界、分配角色和开发团队。</li></ul><p id="6e8b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这些缺点只有在达到特定规模时才会成为问题。对于许多用例来说，monolith是一个正确而合理的选择。然而，你开始缩放，它不再是你的选择。怎么办？嗯，当然，让我们把事情…分解一下。</p><h1 id="9557" class="jk jl hi bd jm jn lo jp jq jr lp jt ju jv lq jx jy jz lr kb kc kd ls kf kg kh bi translated">微服务拯救世界</h1><p id="1378" class="pw-post-body-paragraph if ig hi ih b ii ki ik il im kj io ip iq kk is it iu kl iw ix iy km ja jb jc hb bi translated">人们在称之为“微服务”变得流行之前就已经在构建这种服务了，这个行业喜欢用花哨的术语来炒作它们。“微服务”是一种软件设计模式，它倾向于将应用程序分解成独立的、相互解耦的组件。解耦意味着它们有自己的代码库，作为独立的程序运行，但通过某种通信接口相互连接。这个接口通常是网络。</p><p id="ee1a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当你有一个monolith时，它由几个逻辑模块组成:像前端/UI、后端逻辑、数据库或其他存储。</p><figure class="ko kp kq kr fd ks er es paragraph-image"><div class="er es kn"><img src="../Images/9739d416c0e5f523e5435a88bc46000e.png" data-original-src="https://miro.medium.com/v2/resize:fit:746/format:webp/1*-TuSvDAQEUd2MyOQE0xoog.png"/></div><figcaption class="kv kw et er es kx ky bd b be z dx">Monolith consists of several logical components A, B, C, D.</figcaption></figure><p id="ecaf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了将它变成“微服务”，我们将每个逻辑组件变成一个独立开发和部署的程序。每个这样的应用程序都通过网络与其他应用程序交互，形成相同的整体连贯视图，就好像从用户的角度看什么都没有改变。当它运行时，我们将把这样的程序称为“微服务”。在实践中，术语“微服务”和“服务”是可以互换的，“微”试图强调这种服务是更广泛的应用或服务中相对较小的一部分。</p><blockquote class="lt"><p id="b2b7" class="lu lv hi hj lw lx ly lz ma mb mc jc dx translated">实际上，术语“微服务”和“服务”是可以互换的。</p></blockquote><figure class="me mf mg mh mi ks er es paragraph-image"><div class="er es md"><img src="../Images/13108daffc9f8b7a45f361b350599af6.png" data-original-src="https://miro.medium.com/v2/resize:fit:888/format:webp/1*OTMbHSWHEMDYlBk94lt_ow.png"/></div><figcaption class="kv kw et er es kx ky bd b be z dx">Monolith becoming “Microservices,” services A, B, C, D interoperate over the network now.</figcaption></figure><p id="a300" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦你转向这种设计模式，整个世界的可能性就展现出来了:</p><ul class=""><li id="d2f2" class="kz la hi ih b ii ij im in iq lb iu lc iy ld jc le lf lg lh bi translated">您可以独立地扩展每个服务。</li><li id="a97c" class="kz la hi ih b ii lj im lk iq ll iu lm iy ln jc le lf lg lh bi translated">您可以分离每个服务的发布周期。</li><li id="77ee" class="kz la hi ih b ii lj im lk iq ll iu lm iy ln jc le lf lg lh bi translated">您可以使用自己选择的技术自由编写每个服务，只要它们之间使用相同的通信接口。</li><li id="4c8d" class="kz la hi ih b ii lj im lk iq ll iu lm iy ln jc le lf lg lh bi translated">您可以围绕独立的服务构建您的组织结构，能够分配清晰的所有权、角色和职责。</li></ul><p id="8b68" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">到目前为止，一切顺利，但我们也遇到了麻烦，以实现规模和弹性，对吗？这就是为什么我们不想运行服务A、B、C、D的单个实例(如果其中一个停止运行，如果服务需要更多容量怎么办？)，我们想要很多。我们剥离了Apache Mesos、Kubernetes或Nomad之类的东西，以大规模运行这些服务的许多副本。</p><figure class="ko kp kq kr fd ks er es paragraph-image"><div class="er es mj"><img src="../Images/0ec85fff701b2b6ef27e770f050903c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:924/format:webp/1*p0K_oJflKnssNfm9GdmSNg.png"/></div><figcaption class="kv kw et er es kx ky bd b be z dx">Multiple copies of services help to achieve resilience and scalability.</figcaption></figure><h2 id="f762" class="mk jl hi bd jm ml mm mn jq mo mp mq ju iq mr ms jy iu mt mu kc iy mv mw kg mx bi translated">微服务是容器吗？</h2><p id="bc43" class="pw-post-body-paragraph if ig hi ih b ii ki ik il im kj io ip iq kk is it iu kl iw ix iy km ja jb jc hb bi translated">让我们解决常见的误解。经常听到有人把“微服务”和“容器”混淆。事实是，它们是正交的概念。不需要容器才有微服务，也不需要微服务来使用容器。容器是打包服务的一种方式。这是一个选择，可以同样适用于(或不适用于)单片和微服务。</p><blockquote class="lt"><p id="67ba" class="lu lv hi hj lw lx ly lz ma mb mc jc dx translated">你不需要容器来拥有微服务，也不需要微服务来使用容器。</p></blockquote><p id="84bd" class="pw-post-body-paragraph if ig hi ih b ii my ik il im mz io ip iq na is it iu nb iw ix iy nc ja jb jc hb bi translated">我将把这个想法留给您，在本文的其余部分，微服务将是它们的样子——独立程序，容器化或不容器化。</p><h1 id="4d78" class="jk jl hi bd jm jn lo jp jq jr lp jt ju jv lq jx jy jz lr kb kc kd ls kf kg kh bi translated">独石问题已经不复存在。微服务问题万岁！</h1><p id="4e8e" class="pw-post-body-paragraph if ig hi ih b ii ki ik il im kj io ip iq kk is it iu kl iw ix iy km ja jb jc hb bi translated">恭喜你，你摆脱了monoliths的缺点，获得了一类全新的微服务问题。</p><figure class="ko kp kq kr fd ks er es paragraph-image"><div class="er es mj"><img src="../Images/910a3a89da4aa23782039962a94d1e92.png" data-original-src="https://miro.medium.com/v2/resize:fit:924/format:webp/1*nmJc5ZT39VD0rXlwFH7VjA.png"/></div><figcaption class="kv kw et er es kx ky bd b be z dx">Microservices are coming with their challenges.</figcaption></figure><p id="2154" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，不是部署一个大的二进制文件，而是有N个较小的二进制文件在运行，它们有自己的生命周期，根据需要在许多不同的服务器上调度和终止，同时相互通信。</p><p id="8bae" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">实际上，你得到了一个<strong class="ih li">服务网</strong>(提示，提示)和以下全新的问题要解决:</p><ul class=""><li id="1039" class="kz la hi ih b ii ij im in iq lb iu lc iy ld jc le lf lg lh bi translated"><strong class="ih li">服务发现</strong>。服务A需要与B通话，C需要与D通话，等等。由于每个服务都可以在任何地方进行调度，并且可以在服务器之间来回迁移，那么服务A如何知道应该连接哪个服务器来与服务B进行对话呢？它需要在建立连接之前发现服务的确切位置。</li><li id="a558" class="kz la hi ih b ii lj im lk iq ll iu lm iy ln jc le lf lg lh bi translated"><strong class="ih li">交通管理</strong>。也许您在两个不同的数据中心运行服务D的实例，您希望服务C在数据中心1使用服务D，并且仅在第一个服务不可用时才在数据中心2使用相同的服务。</li><li id="cfef" class="kz la hi ih b ii lj im lk iq ll iu lm iy ln jc le lf lg lh bi translated"><strong class="ih li">安全&amp;策略管理。</strong>您希望控制谁以及如何与服务c对话。网络级访问控制现在还不够，因为同一服务可能有不同的地址，这些地址可能属于不同的网络。您还希望确保服务之间的所有通信都是加密的。</li><li id="5792" class="kz la hi ih b ii lj im lk iq ll iu lm iy ln jc le lf lg lh bi translated"><strong class="ih li">可观测性</strong>。当您必须监控比单个二进制文件多得多的内容时，这是一个很好的监控词。您希望了解(观察)您的服务、连接和故障的状态，并能够跟踪和排除特定问题。随着服务和互连数量的增加，可观察性变得越来越难。</li></ul><p id="9c42" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以将这些问题的解决方案卸载给服务，为它们配备这个额外的、特定于基础设施的逻辑。但是，这意味着以下情况:</p><ul class=""><li id="41ab" class="kz la hi ih b ii ij im in iq lb iu lc iy ld jc le lf lg lh bi translated">应用范围将远远超出其业务需求。您的开发人员希望从事应用程序还是基础设施方面的工作？</li><li id="098e" class="kz la hi ih b ii lj im lk iq ll iu lm iy ln jc le lf lg lh bi translated">您需要为您使用的每个技术堆栈重新实现这个逻辑(拥有微服务架构可能意味着不止一个)。</li></ul><p id="0411" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最好将这个问题的解决方案外包到它的发源地—基础设施。您需要一些软件堆栈，这将使您的部署现代化，以允许您的服务相互发现、控制流量和策略，并提供可观察性，最好不修改服务本身。<strong class="ih li">这种基础设施解决方案被称为“服务网格”</strong></p><p id="a62c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">棘手的部分在于术语过载，“服务网格”既是“许多服务的许多实例相互通信的部署”，也是针对服务网格带来的问题的“基础设施解决方案”。</p><p id="712a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我希望这有助于你建立正确的心智模型来理解“服务网格”所解决的问题的根源以及它是什么。<a class="ae nd" rel="noopener" href="/@aburnos/service-mesh-architectural-patterns-5dfa0ad96e38">在下一篇文章</a>中，我将回顾如何实现“服务网格”的传统方法，以及每种方法的优缺点。</p></div></div>    
</body>
</html>