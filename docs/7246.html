<html>
<head>
<title/>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1/>
<blockquote>原文：<a href="https://medium.com/swlh/your-first-blood-in-the-timetable-school-challenge-1b33efe95f0a?source=collection_archive---------60-----------------------#2019-06-29">https://medium.com/swlh/your-first-blood-in-the-timetable-school-challenge-1b33efe95f0a?source=collection_archive---------60-----------------------#2019-06-29</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/d1a848a765872283636568e17af2a509.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M8uUKou_LaP_ZsIsYm9V3g.png"/></div></div></figure><p id="0663" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated">从计算机科学家的角度来看，考虑到关于这个问题的学术文献很少，时间表是可以给出更多<strong class="hu iq">war</strong>的结构。</p><p id="2087" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated">这就是我在<strong class="hu iq">媒体</strong>上发表这篇文章和许多其他文章的原因。在<a class="ae ir" href="https://en.wikipedia.org/wiki/Operations_management" rel="noopener ugc nofollow" target="_blank">运营管理</a>中有大量的技术，只是与客户略有不同，需要非常具体的实现。</p><p id="0c78" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated">这个帖子的目的是建立一个学校的时间表，同时，自动评估它，如果必要的话，应用一个搜索机制。</p><p id="1828" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated">在我的上一篇文章中，我展示了我是如何建议创建时间表的:</p><div class="hh hi ez fb hj is"><a rel="noopener follow" target="_blank" href="/swlh/a-dinamic-time-allocation-a1603e094341"><div class="it ab dw"><div class="iu ab iv cl cj iw"><h2 class="ix b fi z dy iy ea eb iz ed ef ja bi translated">动态时间分配</h2><div class="jb l"><h3 class="bd b fi z dy iy ea eb iz ed ef dx translated">满足需求的一些简单想法</h3></div><div class="jc l"><p class="bd b fp z dy iy ea eb iz ed ef dx translated">medium.com</p></div></div><div class="jd l"><div class="je l jf jg jh jd ji hp is"/></div></div></a></div><h2 id="274a" class="jj jk ht bd jl jm jn jo jp jq jr js jt id ju jv jw ih jx jy jz il ka kb kc kd bi translated">创建时间表的步骤</h2><ol class=""><li id="7274" class="ke kf ht hu b hv kg hz kh id ki ih kj il kk ip kl km kn ko bi translated">设定每门课程一周的课时数。</li><li id="c8ae" class="ke kf ht hu b hv kp hz kq id kr ih ks il kt ip kl km kn ko bi translated">将一周的时间分配到课程的专门模块中。</li><li id="5b01" class="ke kf ht hu b hv kp hz kq id kr ih ks il kt ip kl km kn ko bi translated">将每节课的课时设定为一周的课时。</li><li id="3125" class="ke kf ht hu b hv kp hz kq id kr ih ks il kt ip kl km kn ko bi translated"><strong class="hu iq">根据模块的需求时间分配</strong>每班的供应时间。</li><li id="e3d0" class="ke kf ht hu b hv kp hz kq id kr ih ks il kt ip kl km kn ko bi translated">设定每个老师一周的课时。</li><li id="5f1e" class="ke kf ht hu b hv kp hz kq id kr ih ks il kt ip kl km kn ko bi translated"><strong class="hu iq">根据模块的需求时间分配</strong>每位教师的供应时间。</li><li id="a772" class="ke kf ht hu b hv kp hz kq id kr ih ks il kt ip kl km kn ko bi translated"><strong class="hu iq"> <em class="ku">构建</em> </strong>一个<strong class="hu iq">时间表</strong>考虑到同一个模块或老师更喜欢在连续的时间内被分配作业。</li></ol><p id="25e3" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated">在这篇文章中，我将向你展示如何从<em class="ku">教师</em>和<em class="ku">教室</em>中分配的<em class="ku">模块</em>小时数中<strong class="hu iq">构建一个时间表</strong>。这个简单的学校时间表没有增加一些与高中时间表相关的额外问题，但是我想你会喜欢这个代码的。</p><h1 id="4af2" class="kv jk ht bd jl kw kx ky jp kz la lb jt lc ld le jw lf lg lh jz li lj lk kc ll bi translated">目标</h1><p id="5e04" class="pw-post-body-paragraph hr hs ht hu b hv kg hx hy hz kh ib ic id lm if ig ih ln ij ik il lo in io ip hb bi translated">为了理解我们将要实现的目标，我将展示最终结果，然后解释它是如何实现的。事实上，你可以在这篇文章的末尾找到两篇文章完整代码的链接。</p><p id="154d" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated">想象一下，我们必须制定一份时间表，让三名教师每周工作<strong class="hu iq"> 10 </strong>、<strong class="hu iq"> 12 </strong>和<strong class="hu iq"> 10 </strong>个小时。我们有四间教室，每间每周可以用8个小时。我们有两门课程:第一门有两个模块，每周12小时和5小时。第二个另外两个模块每周有<strong class="hu iq"> 4 </strong>和<strong class="hu iq"> 11 </strong>小时。所以，这个例子可以这样介绍:</p><pre class="lp lq lr ls fd lt lu lv lw aw lx bi"><span id="863c" class="jj jk ht lu b fi ly lz l ma mb">def test(seed = 0):<br/>    TM = case([10,12,10],  [12, 5, 4, 11], seed, oneProvider = True)<br/>    CM = case([8,8,8,8],  [12, 5, 4, 11], seed, oneProvider = True)<br/>    L = genTupleHours (CM, TM, 3)<br/>    merge(L, seed)<br/>    courses = [0, 0, 1, 1]<br/>    TT, correctness = fillDayAndHour(L, 6, 5, courses)<br/>    return TT, courses, correctness, qualityStats(plainItemsTT(TT))</span></pre><p id="c46b" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated">一些澄清:</p><ul class=""><li id="85c1" class="ke kf ht hu b hv hw hz ia id mc ih md il me ip mf km kn ko bi translated"><em class="ku"> seed </em>是一个<strong class="hu iq"> int </strong>，我们用它来索引每一个不同的时间表。</li><li id="64c7" class="ke kf ht hu b hv kp hz kq id kr ih ks il kt ip mf km kn ko bi translated"><em class="ku"> case </em>是一个生成课时分配的函数(<strong class="hu iq"> TM </strong>带模块的老师，<strong class="hu iq"> CM </strong>带模块的教室)，我在上一篇帖子中解释过。</li><li id="c5b8" class="ke kf ht hu b hv kp hz kq id kr ih ks il kt ip mf km kn ko bi translated">merge 是一个函数，它合并一个列表来生成一个不同的有效结果，我在上一篇文章中也解释过。</li><li id="72fb" class="ke kf ht hu b hv kp hz kq id kr ih ks il kt ip mf km kn ko bi translated"><em class="ku"> genTupleHours、fillDayAndHour、plainItemsTT </em>和<em class="ku"> qualityStats </em>将在本帖中解释。</li></ul><p id="031b" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated">如果您测试了代码:</p><pre class="lp lq lr ls fd lt lu lv lw aw lx bi"><span id="0ac3" class="jj jk ht lu b fi ly lz l ma mb">&gt;&gt;&gt; TT, courses, correctness, Q = test(554252)<br/>&gt;&gt;&gt; correctness<br/>True</span></pre><p id="1e8c" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated">我们看到<em class="ku">种子</em> <strong class="hu iq"> 5542252 </strong>(随机选择)是正确的，所以如果我们想看<em class="ku">第一个</em>课程的时间表:</p><pre class="lp lq lr ls fd lt lu lv lw aw lx bi"><span id="8d30" class="jj jk ht lu b fi ly lz l ma mb">&gt;&gt;&gt; timeTableCourse(TT, courses, 0)<br/>           0          1          2          3     4     5<br/>0  (1, 0, 0)  (3, 0, 0)  (1, 0, 1)  (3, 0, 2)  None  None<br/>1  (1, 0, 0)  (3, 0, 0)  (2, 1, 2)  (3, 0, 0)  None  None<br/>2  (1, 0, 0)  (3, 0, 0)  (2, 1, 2)       None  None  None<br/>3  (3, 0, 0)  (3, 0, 0)  (2, 1, 2)       None  None  None<br/>4  (3, 0, 0)  (1, 1, 2)  (2, 1, 2)       None  None  None</span></pre><p id="188e" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated">一周六天五小时，呈现的是(<em class="ku">课堂</em>，<em class="ku">模块</em>，<em class="ku">老师</em>)。</p><p id="8029" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated">如果你想看第三个老师的时间表，你应该输入:</p><pre class="lp lq lr ls fd lt lu lv lw aw lx bi"><span id="a765" class="jj jk ht lu b fi ly lz l ma mb">&gt;&gt;&gt; timeTableTeacher(TT, 2)<br/>        0       1       2       3     4     5<br/>0  (2, 2)    None  (2, 2)  (3, 0)  None  None<br/>1  (2, 2)    None  (2, 1)    None  None  None<br/>2  (2, 2)    None  (2, 1)    None  None  None<br/>3    None    None  (2, 1)    None  None  None<br/>4    None  (1, 1)  (2, 1)    None  None  None</span></pre><p id="22b4" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated">在这种情况下，呈现的是(<em class="ku">教室</em>，<em class="ku">模块</em>)。</p><p id="9b9c" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated">因此，有了这第一个想法，我将向你展示如何获得这些结果…</p><h1 id="82ba" class="kv jk ht bd jl kw kx ky jp kz la lb jt lc ld le jw lf lg lh jz li lj lk kc ll bi translated">履行</h1><p id="aa2d" class="pw-post-body-paragraph hr hs ht hu b hv kg hx hy hz kh ib ic id lm if ig ih ln ij ik il lo in io ip hb bi translated">执行<strong class="hu iq">时间表</strong>的方式与人工<em class="ku">流程</em>相同，没有大的复杂性。也就是说，这段代码的出发点是，要么你有足够的资源，要么你会在种子中找到给出成功结果所必需的智慧。</p><p id="2d15" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated">所以，如果分配的问题更复杂，我推荐这个经过测试的<a class="ae ir" rel="noopener" href="/swlh/the-boolean-satisfiability-problem-solved-48ceb5550115">帖子</a>。或者，也许你正在寻找基于<a class="ae ir" rel="noopener" href="/swlh/quadratic-assignment-problem-solved-247338a6aa40">行业</a>的其他类型的复杂时间表。如果时间表是基于解决一个简单的运动竞赛，我推荐访问这个<a class="ae ir" rel="noopener" href="/datadriveninvestor/a-charitable-championship-f230f20c917f">帖子</a>。</p><p id="983c" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated">所以，我们的出发点是:我们在两个<strong class="hu iq">数据帧</strong>中分配了<em class="ku">教师</em>和<em class="ku">教室</em>之间每个<em class="ku">模块</em>所需的<em class="ku">小时数</em>。这个<strong class="hu iq">计划哲学</strong>中的第一件事是分段完成每天的所有小时，直到达到一定的小时数。</p><pre class="lp lq lr ls fd lt lu lv lw aw lx bi"><span id="9c50" class="jj jk ht lu b fi ly lz l ma mb">&gt;&gt;&gt; TM = case([10,12,10],  [12, 5, 4, 11], 0, oneProvider = True)<br/>&gt;&gt;&gt; CM = case([8,8,8,8],  [12, 5, 4, 11], 0, oneProvider = True)<br/>&gt;&gt;&gt; genTupleHours (CM, TM, 3)<br/>[(1, 3, 0, 1), (1, 3, 0, 3), (3, 1, 1, 1), (3, 0, 2, 1), (2, 0, 2, 3), (1, 3, 0, 3), (0, 3, 1, 1), (0, 3, 0, 3), (1, 2, 1, 1), (0, 2, 1, 3), (3, 1, 1, 3), (0, 1, 1, 1), (3, 0, 2, 3), (2, 0, 2, 3), (2, 0, 1, 2)]</span></pre><p id="d84b" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated">名单将第一个加入:(<em class="ku">课堂</em>、<em class="ku">模块</em>、<em class="ku">老师</em>、连续<em class="ku">课时</em>)</p><h2 id="cc59" class="jj jk ht bd jl jm jn jo jp jq jr js jt id ju jv jw ih jx jy jz il ka kb kc kd bi translated">genTupleHours函数</h2><p id="6c8a" class="pw-post-body-paragraph hr hs ht hu b hv kg hx hy hz kh ib ic id lm if ig ih ln ij ik il lo in io ip hb bi translated">该功能的目标是考虑到分配了相同的<em class="ku">模块</em>，加入<em class="ku">教师</em>和<em class="ku">教室</em>之间的课时分配。</p><p id="11c6" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated">如果我们有两张这样的桌子:</p><pre class="lp lq lr ls fd lt lu lv lw aw lx bi"><span id="65d7" class="jj jk ht lu b fi ly lz l ma mb">&gt;&gt;&gt; TM<br/>Allocation: Rows Demands, Columns Supplies:<br/>    0  1   2<br/>0   0  2  10<br/>1   0  5   0<br/>2   0  4   0<br/>3  10  1   0<br/>&gt;&gt;&gt; CM<br/>Allocation: Rows Demands, Columns Supplies:<br/>   0  1  2  3<br/>0  0  0  8  4<br/>1  1  0  0  4<br/>2  3  1  0  0<br/>3  4  7  0  0</span></pre><p id="23a4" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated">考虑到最大小时数的分段，我们可以按行将它们连接起来。</p><p id="c695" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated">实现可能是这样的:</p><pre class="lp lq lr ls fd lt lu lv lw aw lx bi"><span id="69f2" class="jj jk ht lu b fi ly lz l ma mb">def genTupleHours(CM, TM, hoursModule, seed = 0):<br/>    dfMC = CM.T.transpose()<br/>    dfMT = TM.T.transpose()<br/>    hoursToSupply = list(dfMT.sum())<br/>    result = []<br/>    while sum(hoursToSupply)&gt;0:<br/>        for module in dfMC.columns:<br/>            for classroom in dfMC.index:<br/>                if hoursToSupply[module] == 0:<br/>                    break<br/>                if dfMC[module][classroom] == 0:<br/>                    continue<br/>                for teacher in dfMT.index:<br/>                    if hoursToSupply[module] == 0:<br/>                        break<br/>                    if dfMT[module][teacher] == 0:<br/>                        continue<br/>                    hours = min(dfMC[module][classroom],<br/>                                dfMT[module][teacher],<br/>                                hoursModule)<br/>                    hoursToSupply[module] -= hours<br/>                    dfMC[module][classroom] -= hours<br/>                    dfMT[module][teacher] -= hours<br/>                    if result:<br/>                        result.insert(seed % len(result),<br/>                                  (classroom,<br/>                                   module,<br/>                                   teacher,<br/>                                   hours))<br/>                    else:<br/>                        result = [ (classroom,<br/>                                   module,<br/>                                   teacher,<br/>                                   hours)]<br/>    return result</span></pre><ul class=""><li id="e449" class="ke kf ht hu b hv hw hz ia id mc ih md il me ip mf km kn ko bi translated">注意，我们做的第一件事是<em class="ku">转置</em>T2数据帧，并删除其中的数据。因此，在未来的实现中，你可以考虑他们是否能以<em class="ku">转置</em>的方式变得更好。</li><li id="1312" class="ke kf ht hu b hv kp hz kq id kr ih ks il kt ip mf km kn ko bi translated">在最后几行中，<em class="ku">种子</em>用于合并不同的结果，以组织供应时间。这就是我们在这个函数中获得不同有效案例的方法。</li></ul><p id="0afc" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated">在考虑到结果不会尽善尽美之后，有时我们希望连续太多的时间在同一个主题上可能是不好的……，<em class="ku">或多或少</em>在这里这个概念是被阻止的。</p><h2 id="2fc0" class="jj jk ht bd jl jm jn jo jp jq jr js jt id ju jv jw ih jx jy jz il ka kb kc kd bi translated">fillDayAndHour函数</h2><p id="6746" class="pw-post-body-paragraph hr hs ht hu b hv kg hx hy hz kh ib ic id lm if ig ih ln ij ik il lo in io ip hb bi translated">在知道顺序中连续小时的片段之后，现在我们必须在时间表本身中分配它们，以防止两种冲突:</p><ul class=""><li id="7b7f" class="ke kf ht hu b hv hw hz ia id mc ih md il me ip mf km kn ko bi translated">同一<em class="ku">课程</em>的两个<em class="ku">模块</em>不能在同一<strong class="hu iq">时间</strong>内分配到两个<strong class="hu iq">地点</strong> ( <em class="ku">教室</em>)。</li><li id="1e92" class="ke kf ht hu b hv kp hz kq id kr ih ks il kt ip mf km kn ko bi translated">同一个<em class="ku">老师</em>不能在同一个<strong class="hu iq">时间</strong>分配在两个<strong class="hu iq">地点</strong> ( <em class="ku">教室</em>)。</li></ul><pre class="lp lq lr ls fd lt lu lv lw aw lx bi"><span id="2d08" class="jj jk ht lu b fi ly lz l ma mb">def fillDayAndHour(L, days, hoursADay, course):<br/>    'L = [(classroom, module, teacher, hours)]'<br/>    'course = {module: id}'<br/>    'Same day and hour different teacher and different module'</span><span id="51f3" class="jj jk ht lu b fi mg lz l ma mb">    def overlapped (day, hour, hours, module, teacher):<br/>        for H in range(hours):<br/>            if (hour + H) in TT[day].keys():<br/>                for moduleH, teacherH \<br/>                    in TT[day][hour + H].values():<br/>                        if course[module] == course[moduleH] \<br/>                           or teacher == teacherH:<br/>                            return True<br/>        return False<br/>        <br/>    TT = {}<br/>    for day in range(days):<br/>        TT[day] = {X: {} for X in range(hoursADay)}<br/>        for hour in range(hoursADay):<br/>            toSupplyLater = []<br/>            while L:<br/>                (classroom, module, teacher, hours) = L.pop()<br/>                if overlapped(day, hour, hours, module, teacher):<br/>                    toSupplyLater.append((classroom,<br/>                                          module,<br/>                                          teacher,<br/>                                          hours))<br/>                else:<br/>                    for H in range(hour, hoursADay):<br/>                        if hours&gt;0:<br/>                            TT[day][H][classroom] = (module,teacher)<br/>                            hours -= 1<br/>                        else:<br/>                            break<br/>                    if hours &gt; 0:<br/>                        toSupplyLater.append((classroom,<br/>                                              module,<br/>                                              teacher,<br/>                                              hours))<br/>            L = toSupplyLater<br/>    return TT, L ==[]</span></pre><p id="e05a" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated">一些考虑，</p><ul class=""><li id="1220" class="ke kf ht hu b hv hw hz ia id mc ih md il me ip mf km kn ko bi translated">这里我们使用课程<strong class="hu iq">列表</strong> / <strong class="hu iq">字典</strong>来查找每个<em class="ku">模块</em>的id <em class="ku">课程</em>。</li><li id="319e" class="ke kf ht hu b hv kp hz kq id kr ih ks il kt ip mf km kn ko bi translated">正如在<em class="ku"> genTupleHours </em>函数中所做的那样，我们可以包含一个<em class="ku">种子</em>，以便在将列表<em class="ku">中的元组重新放置到供应商</em>时合并位置。恕我直言，我认为没有必要。</li><li id="d2dd" class="ke kf ht hu b hv kp hz kq id kr ih ks il kt ip mf km kn ko bi translated">结果<strong class="hu iq"> TT </strong>就是一本字典里的地图，上面有所有的信息，有数据:<em class="ku">天</em> → <em class="ku">小时</em> → ( <em class="ku">教室</em>、<em class="ku">模块</em>、<em class="ku">老师</em>、<em class="ku">小时</em>)</li><li id="23a7" class="ke kf ht hu b hv kp hz kq id kr ih ks il kt ip mf km kn ko bi translated">如果结束循环，按顺序完成<em class="ku">天</em>和<em class="ku">小时</em>在这个<em class="ku">调度原则</em>中的一天，我们仍然有一些元组来提供结果<strong class="hu iq"> TT </strong>将不<em class="ku">正确</em>。</li></ul><h2 id="54e1" class="jj jk ht bd jl jm jn jo jp jq jr js jt id ju jv jw ih jx jy jz il ka kb kc kd bi translated">plainItemsTT函数</h2><p id="431c" class="pw-post-body-paragraph hr hs ht hu b hv kg hx hy hz kh ib ic id lm if ig ih ln ij ik il lo in io ip hb bi translated">这是一个非常计划的函数:它的目标是将从<em class="ku"> fillDayAndHourFunction </em>返回的字典转换为元组列表，就像在<strong class="hu iq">表格式</strong>中一样。</p><pre class="lp lq lr ls fd lt lu lv lw aw lx bi"><span id="82ac" class="jj jk ht lu b fi ly lz l ma mb">&gt;&gt;&gt; TT<br/>{0: {0: {1: (0, 0), 2: (2, 2)}, 1: {1: (0, 0), 2: (2, 2)}, 2: {1: (0, 0), 2: (2, 2)}, 3: {3: (0, 0), 0: (3, 1)}, 4: {3: (0, 0), 0: (3, 1)}}, 1: {0: {3: (0, 0), 0: (3, 1)}, 1: {3: (0, 0), 0: (3, 1)}, 2: {3: (0, 0), 0: (3, 1)}, 3: {3: (0, 0), 0: (3, 1)}, 4: {1: (1, 2), 0: (3, 1)}}, 2: {0: {1: (0, 1), 2: (2, 2)}, 1: {2: (1, 2), 0: (3, 1)}, 2: {2: (1, 2), 1: (3, 1)}, 3: {2: (1, 2), 1: (3, 1)}, 4: {1: (3, 1), 2: (1, 2)}}, 3: {0: {3: (0, 2)}, 1: {3: (0, 0)}, 2: {}, 3: {}, 4: {}}, 4: {0: {}, 1: {}, 2: {}, 3: {}, 4: {}}, 5: {0: {}, 1: {}, 2: {}, 3: {}, 4: {}}}<br/>&gt;&gt;&gt; plainItemsTT(TT)<br/>[(0, 0, 1, 0, 0), (0, 0, 2, 2, 2), (0, 1, 1, 0, 0), (0, 1, 2, 2, 2), (0, 2, 1, 0, 0), (0, 2, 2, 2, 2), (0, 3, 3, 0, 0), (0, 3, 0, 3, 1), (0, 4, 3, 0, 0), (0, 4, 0, 3, 1), (1, 0, 3, 0, 0), (1, 0, 0, 3, 1), (1, 1, 3, 0, 0), (1, 1, 0, 3, 1), (1, 2, 3, 0, 0), (1, 2, 0, 3, 1), (1, 3, 3, 0, 0), (1, 3, 0, 3, 1), (1, 4, 1, 1, 2), (1, 4, 0, 3, 1), (2, 0, 1, 0, 1), (2, 0, 2, 2, 2), (2, 1, 2, 1, 2), (2, 1, 0, 3, 1), (2, 2, 2, 1, 2), (2, 2, 1, 3, 1), (2, 3, 2, 1, 2), (2, 3, 1, 3, 1), (2, 4, 1, 3, 1), (2, 4, 2, 1, 2), (3, 0, 3, 0, 2), (3, 1, 3, 0, 0)]</span></pre><p id="8796" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated">琐碎的代码可以包含在下一个函数中，但是考虑到用<strong class="hu iq">时间表</strong>来管理可能会很有趣，下面是:</p><pre class="lp lq lr ls fd lt lu lv lw aw lx bi"><span id="89ba" class="jj jk ht lu b fi ly lz l ma mb">def plainItemsTT(TT):<br/>    tuples = []<br/>    for day in TT.keys():<br/>        for hour in TT[day].keys():<br/>            for classroom in TT[day][hour].keys():<br/>                tuples.append((day, hour, classroom) \<br/>                              + TT[day][hour][classroom])<br/>    return tuples</span></pre><h2 id="82ad" class="jj jk ht bd jl jm jn jo jp jq jr js jt id ju jv jw ih jx jy jz il ka kb kc kd bi translated">问题的关键:qualityStats函数</h2><p id="c5be" class="pw-post-body-paragraph hr hs ht hu b hv kg hx hy hz kh ib ic id lm if ig ih ln ij ik il lo in io ip hb bi translated"><em class="ku"> qualityStats </em>函数用于知道选择哪个<em class="ku">种子</em>。因此，这一点非常重要。考虑到重要的是客户的特征，这里我只提出四个数据:</p><ul class=""><li id="71c7" class="ke kf ht hu b hv hw hz ia id mc ih md il me ip mf km kn ko bi translated">每个模块的课程需要多少小时(与平均值成比例)。</li><li id="395a" class="ke kf ht hu b hv kp hz kq id kr ih ks il kt ip mf km kn ko bi translated">差异模块小时数是如何分布的(与偏差成比例)。</li><li id="75d8" class="ke kf ht hu b hv kp hz kq id kr ih ks il kt ip mf km kn ko bi translated">给每个老师上课需要多少小时(与平均水平成比例)。</li><li id="8ed9" class="ke kf ht hu b hv kp hz kq id kr ih ks il kt ip mf km kn ko bi translated">教师课时差异是如何分布的(与偏差成比例)。</li></ul><p id="e3e1" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated">在一些公司，工人工作的第一个小时和最后一个小时与业务无关——但与公务员完全无关……但考虑到一个工人被分配了很好的小时数，而其他人必须工作太多小时……我们可以考虑四个<strong class="hu iq">损失成本</strong>来考虑。</p><p id="7ed9" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated">并且为了计算它，我们将使用在这个<a class="ae ir" href="https://hackingandslacking.com/using-hierarchical-indexes-with-pandas-38057cf1d7e" rel="noopener ugc nofollow" target="_blank">帖子</a>中解释的<strong class="hu iq">熊猫多德星</strong>。</p><pre class="lp lq lr ls fd lt lu lv lw aw lx bi"><span id="c7a8" class="jj jk ht lu b fi ly lz l ma mb">def qualityStats(plainTT):<br/>    TT = DataFrame(plainTT,<br/>                   columns = ['Day', 'Hour',<br/>                              'Class', 'Module', 'Teacher'])<br/>    TT.set_index(['Teacher', 'Day', 'Module', 'Class'],<br/>                 inplace = True)<br/>    LostT, LostM = 0, 0<br/>    LmaxT, LminT, LmaxM, LminM = 0, 24, 0, 24<br/>    for teacher in TT.index.levels[<br/>                TT.index.names.index('Teacher')]:<br/>        Z = int((TT.xs(teacher, level='Teacher').groupby(<br/>                    level="Day").max() \<br/>                       - TT.xs(teacher, level='Teacher').groupby(<br/>                           level="Day").min()).sum())<br/>        LmaxT = max(LmaxT, Z)<br/>        LminT = min(LminT, Z)<br/>        LostT += Z<br/>    for module in TT.index.levels[<br/>                TT.index.names.index('Module')]:<br/>        Z = int((TT.xs(<br/>            module, level='Module').groupby(level="Day").max() \<br/>                       - TT.xs(<br/>                               module, level='Module').groupby(<br/>                                   level="Day").min()).sum())<br/>        LmaxM = max(LmaxM, Z)<br/>        LminM = min(LminM, Z)<br/>        LostM +=Z<br/>    return LostM, LmaxM - LminM,  LostT, LmaxT - LminT</span></pre><ul class=""><li id="5968" class="ke kf ht hu b hv hw hz ia id mc ih md il me ip mf km kn ko bi translated">注意，我们创建了一个<strong class="hu iq"> DataFrame </strong>以一种不推荐的方式索引数据:我们用不是<strong class="hu iq">唯一键</strong>的列进行索引。原因是为了快速获得agregate ( <em class="ku">最大</em>和<em class="ku">最小</em>)结果。</li></ul><p id="f741" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated">我们可以测试不同的尝试来得到一些结果…</p><pre class="lp lq lr ls fd lt lu lv lw aw lx bi"><span id="da19" class="jj jk ht lu b fi ly lz l ma mb">&gt;&gt;&gt; test(554252)[-1]<br/>(21, 6, 22, 3)<br/>&gt;&gt;&gt; test(353)[-1]<br/>(20, 6, 21, 2)</span></pre><p id="4847" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated">公司的最佳政策是什么？</p><h2 id="2f7d" class="jj jk ht bd jl jm jn jo jp jq jr js jt id ju jv jw ih jx jy jz il ka kb kc kd bi translated">显示结果:时间表教师和时间表课程功能</h2><p id="38f5" class="pw-post-body-paragraph hr hs ht hu b hv kg hx hy hz kh ib ic id lm if ig ih ln ij ik il lo in io ip hb bi translated">在接受一个<em class="ku">种子</em>后，现在我们可以在一个<strong class="hu iq">数据帧</strong>或一个<strong class="hu iq">列表</strong>中显示那个<strong class="hu iq">时间表</strong>:</p><pre class="lp lq lr ls fd lt lu lv lw aw lx bi"><span id="2782" class="jj jk ht lu b fi ly lz l ma mb">&gt;&gt;&gt; timeTableTeacher(test(353)[0], teacher = 1)<br/>        0       1       2       3     4     5<br/>0    None  (2, 3)  (0, 3)  (1, 0)  None  None<br/>1    None  (0, 3)  (0, 3)    None  None  None<br/>2    None  (0, 3)  (0, 3)    None  None  None<br/>3  (2, 3)  (0, 3)  (0, 3)    None  None  None<br/>4  (2, 3)  (0, 3)    None    None  None  None</span></pre><p id="6c13" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated">这些实现是:</p><pre class="lp lq lr ls fd lt lu lv lw aw lx bi"><span id="c27c" class="jj jk ht lu b fi ly lz l ma mb">def timeTableTeacher(TT, teacher, inDataframe = True):<br/>    'Day x Hour --&gt; Classroom x Module'<br/>    R = [None] * len(TT)<br/>    for day in TT.keys():<br/>        R[day]=[None] * len(TT[day])<br/>        for hour in TT[day].keys():<br/>            data = [(classroom,<br/>                     TT[day][hour][classroom][0]) \<br/>                        for classroom in TT[day][hour].keys() \<br/>                 if TT[day][hour][classroom][1] == teacher]<br/>            if len(data)&gt;1:<br/>                raise Exception #Fatal error  double Teacher<br/>            elif len(data)==1:<br/>                R[day][hour] = data[0]<br/>    return R if not inDataframe else DataFrame(R).transpose()</span><span id="22e2" class="jj jk ht lu b fi mg lz l ma mb">def timeTableCourse(TT, courses, course, inDataframe = True):<br/>    'Day x Hour --&gt; Classroom x Module x Teacher'<br/>    R = [None] * len(TT)<br/>    for day in TT.keys():<br/>        R[day]=[None] * len(TT[day])<br/>        for hour in TT[day].keys():<br/>            data = [(classroom,<br/>                     TT[day][hour][classroom][0],<br/>                     TT[day][hour][classroom][1])\<br/>                    for classroom in TT[day][hour].keys() \<br/>                         if courses[TT[day][hour][classroom][0]] \<br/>                            == course]<br/>            if len(data)&gt;1:<br/>                raise Exception #Fatal error double course<br/>            elif len(data)==1:<br/>                R[day][hour] = data[0]<br/>    return R if not inDataframe else DataFrame(R).transpose()</span></pre><ul class=""><li id="eb16" class="ke kf ht hu b hv hw hz ia id mc ih md il me ip mf km kn ko bi translated">考虑到在一门<em class="ku">课程</em>中有两个<em class="ku">模块</em>重叠或者一个不好的<em class="ku">老师</em>分配，我包括了两个<strong class="hu iq">致命错误</strong>永远不会被提出(bug)。</li></ul><h1 id="5290" class="kv jk ht bd jl kw kx ky jp kz la lb jt lc ld le jw lf lg lh jz li lj lk kc ll bi translated">结论</h1><p id="ce34" class="pw-post-body-paragraph hr hs ht hu b hv kg hx hy hz kh ib ic id lm if ig ih ln ij ik il lo in io ip hb bi translated">你可以在<a class="ae ir" href="https://archive.org/download/QuadraticAssingmentProblem" rel="noopener ugc nofollow" target="_blank"> allocation.py </a>中找到这个代码。</p><p id="7ae1" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated">对于那些停下来研究代码的人，我可以告诉你，吱嘎作响的门挂得最久。也许这不是一个确定的代码，我们仍然应该玩微妙，但一天一个苹果远离医生。因为想要得到果实的人必须爬树，所以在这里我将完成我的作品。</p></div></div>    
</body>
</html>