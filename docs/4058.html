<html>
<head>
<title>Java Multithreading</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java多线程</h1>
<blockquote>原文：<a href="https://medium.com/swlh/java-multithreading-b8dd4771a902#2019-05-28">https://medium.com/swlh/java-multithreading-b8dd4771a902#2019-05-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/9ca3cca6cdc891920296148d08ce96a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:838/format:webp/1*twrUVGU1vKL-JLhhd1NiOA.png"/></div></figure><p id="6181" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">同时执行几个程序的能力叫做<strong class="io jk">多任务</strong>。用系统的术语来说叫做多线程。这里，主程序被分成两个或多个子程序(进程),这些子程序可以同时并行执行。</p><p id="4f79" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io jk">例子:</strong></p><ul class=""><li id="985b" class="jl jm hi io b ip iq it iu ix jn jb jo jf jp jj jq jr js jt bi translated">多个客户访问服务器的铁路客票预订系统。</li><li id="d202" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">在I/O阻塞时执行一些执行。</li><li id="6379" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">游戏是线程化的很好的例子。你可以在游戏中使用多个物体，比如汽车、摩托车、动物、人等等。所有这些对象都只是运行游戏应用程序的线程。</li><li id="6145" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">多个帐户持有人在服务器上同时访问他们的帐户。当您插入ATM卡时，它会启动一个线程来执行您的操作。</li><li id="43be" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">一边听音乐一边输入MS Word文档。</li></ul><h1 id="620f" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">什么是线程？</h1><p id="d649" class="pw-post-body-paragraph im in hi io b ip kx ir is it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj hb bi translated">线程类似于只有一个控制流的程序。每个程序至少有一个线程，线程有开始、主体和结束。它按顺序执行命令。因此多线程意味着并行执行多个命令。特别的是Java支持多线程。</p><p id="06d0" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">因此，Java使我们能够在开发程序时使用多种控制流。每个控制流(线程)与其他控制流并行运行。包含多个控制流的程序称为<strong class="io jk">多线程程序</strong>。</p><p id="c85b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">让我们假设程序有如下线程</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="c0eb" class="ll ka hi lh b fi lm ln l lo lp">Main Thread <br/>Thread A <br/>Thread B<br/>Thread C </span></pre><p id="51ba" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在首先启动<strong class="io jk">主线程</strong>。然后<strong class="io jk">线程A、B和C </strong>并发运行，共同共享资源。由于Java中的线程是主应用程序的子程序，并且共享相同的内存空间，所以它们被称为<strong class="io jk">轻量级线程。</strong></p><p id="c2a3" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io jk">重要提示:记住线程并行运行并不意味着它们同时运行。所有线程都运行在单个处理器上，并且在线程之间共享执行。Java编译器处理线程之间的控制切换。</strong></p><h2 id="fba2" class="ll ka hi bd kb lq lr ls kf lt lu lv kj ix lw lx kn jb ly lz kr jf ma mb kv mc bi translated">线程的生命周期</h2><p id="562d" class="pw-post-body-paragraph im in hi io b ip kx ir is it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj hb bi translated">在线程的生命周期中，它可以进入许多状态。</p><ul class=""><li id="5524" class="jl jm hi io b ip iq it iu ix jn jb jo jf jp jj jq jr js jt bi translated"><strong class="io jk">新生状态</strong> —当我们创建一个线程对象时，线程就诞生了，并处于新生状态。</li><li id="30c6" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated"><strong class="io jk">可运行状态</strong> —线程准备执行，等待处理器的可用性。</li><li id="e82e" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated"><strong class="io jk">运行状态</strong> —处理器已经给出了执行时间。</li><li id="ae2f" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated"><strong class="io jk">阻塞状态</strong> —线程被阻止进入可运行状态和运行状态。当线程被挂起、休眠或等待以满足某些要求时，就会发生这种情况。</li><li id="db40" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated"><strong class="io jk">死状态</strong> —正在运行的线程结束了自己的生命周期，完成了run方法的执行。</li></ul><h1 id="8bef" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">线程异常</h1><p id="2e5f" class="pw-post-body-paragraph im in hi io b ip kx ir is it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj hb bi translated">Sleep()方法应该包含在try块中，后面跟一个catch块。这很重要，因为sleep方法抛出了一个应该被捕获的异常。如果我们没有捕捉到异常，程序将无法编译。</p><p id="b261" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">每当我们试图调用一个线程在给定状态下无法处理的方法时，Java都会抛出一个名为<a class="ae md" href="https://stackoverflow.com/questions/7315941/java-lang-illegalthreadstateexception" rel="noopener ugc nofollow" target="_blank"><strong class="io jk">IllegalThreadStateException</strong></a>的异常。</p><p id="6007" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io jk">例子:</strong> Sleeping方法无法处理resume()方法，因为睡眠线程无法接收任何指令。</p><h1 id="974a" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated"><strong class="ak">如何创建线程？</strong></h1><p id="fddd" class="pw-post-body-paragraph im in hi io b ip kx ir is it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj hb bi translated">创建线程有两种方法:</p><ol class=""><li id="70f3" class="jl jm hi io b ip iq it iu ix jn jb jo jf jp jj me jr js jt bi translated">通过扩展线程类</li><li id="ff42" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj me jr js jt bi translated">通过实现Runnable接口。</li></ol><p id="76fb" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">可以根据我们创建的类的需求来使用这种方法。</p><h2 id="2712" class="ll ka hi bd kb lq lr ls kf lt lu lv kj ix lw lx kn jb ly lz kr jf ma mb kv mc bi translated">1.通过扩展线程类</h2><p id="b3c2" class="pw-post-body-paragraph im in hi io b ip kx ir is it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj hb bi translated">Thread类提供了创建和执行线程操作的构造函数和方法。Thread类扩展Object类，实现Runnable接口。</p><h2 id="4dbe" class="ll ka hi bd kb lq lr ls kf lt lu lv kj ix lw lx kn jb ly lz kr jf ma mb kv mc bi translated">步骤:</h2><ul class=""><li id="d92e" class="jl jm hi io b ip kx it ky ix mf jb mg jf mh jj jq jr js jt bi translated">将该类声明为扩展Thread类。</li><li id="34af" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">实现run方法。</li><li id="0e9d" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">创建线程对象并调用Start方法。</li></ul><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="7224" class="ll ka hi lh b fi lm ln l lo lp">package threadtutorial;</span><span id="4697" class="ll ka hi lh b fi mi ln l lo lp">/**<br/> *<br/> * <a class="ae md" href="http://twitter.com/author" rel="noopener ugc nofollow" target="_blank">@author</a> Kasun Dissanayake<br/> */</span><span id="52c9" class="ll ka hi lh b fi mi ln l lo lp">class Multi extends Thread{<br/>    <a class="ae md" href="http://twitter.com/Override" rel="noopener ugc nofollow" target="_blank">@Override</a><br/>    public void run(){<br/>//your code here<br/>        System.out.println("thread is running...");<br/>    }<br/>}<br/>public class ThreadTutorial {</span><span id="f118" class="ll ka hi lh b fi mi ln l lo lp">public static void main(String[] args) {<br/>        Multi t1 = new Multi();  <br/>        t1.start();</span><span id="59db" class="ll ka hi lh b fi mi ln l lo lp">}<br/>    <br/>}</span></pre><p id="57d6" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这里<strong class="io jk"><em class="mj">Multi t1 = new Multi()；</em> </strong>语句创建对象。将运行此对象的线程尚未运行。该线程处于新生状态。</p><p id="4851" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在<strong class="io jk"><em class="mj">t1 . start()；</em> </strong>语句引导线程移动到可运行状态。然后Java解释器将通过调用这个<strong class="io jk"> <em class="mj"> run() </em> </strong>方法<strong class="io jk"> <em class="mj">来调度线程运行。</em> </strong>现在线程处于<strong class="io jk">运行</strong>状态。</p><p id="e2c6" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">运行这段代码，你会得到这样的结果。</p><figure class="lc ld le lf fd ij er es paragraph-image"><div class="er es mk"><img src="../Images/3fd9d4bd5f2db0f9d19dac779fd0b7bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:702/format:webp/1*NgtHPw5_rl4ez7xZ9puPeg.png"/></div></figure><h1 id="d9d7" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">如何停止一个线程？</h1><p id="ca39" class="pw-post-body-paragraph im in hi io b ip kx ir is it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj hb bi translated">每当我们想停止一个线程的运行状态，我们应该调用它的stop()方法。它会将线程的<strong class="io jk">运行状态</strong>移动到<strong class="io jk">死状态</strong>。</p><p id="0862" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">当线程到达其方法的结尾时，它将自动进入dead状态。</p><p id="352d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io jk">例如:</strong></p><p id="6e78" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">一个包含显示数字1到10的线程的程序。如果数量达到5，则停止线程。</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="dd93" class="ll ka hi lh b fi lm ln l lo lp">package threadtutorial;</span><span id="2f1b" class="ll ka hi lh b fi mi ln l lo lp">/**<br/> *<br/> * <a class="ae md" href="http://twitter.com/author" rel="noopener ugc nofollow" target="_blank">@author</a> Kasun Dissanayake<br/> */</span><span id="bf47" class="ll ka hi lh b fi mi ln l lo lp">class Test extends Thread{<br/>    public void run(){<br/>        for (int i = 0; i &lt; 10; i++) {<br/>            if(i == 5){<br/>                stop();<br/>            }<br/>            System.out.println(i);<br/>        }<br/>    }<br/>}</span><span id="b465" class="ll ka hi lh b fi mi ln l lo lp">public class ThreadTutorial {</span><span id="4567" class="ll ka hi lh b fi mi ln l lo lp">public static void main(String[] args) {</span><span id="ac02" class="ll ka hi lh b fi mi ln l lo lp">Test test = new Test();<br/>        test.start();</span><span id="ed92" class="ll ka hi lh b fi mi ln l lo lp">}    <br/>}</span></pre><h1 id="f64b" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">如何阻塞一个线程？</h1><p id="91ff" class="pw-post-body-paragraph im in hi io b ip kx ir is it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj hb bi translated">线程可以被暂时挂起或阻止进入可运行和随后运行状态，</p><ul class=""><li id="5655" class="jl jm hi io b ip iq it iu ix jn jb jo jf jp jj jq jr js jt bi translated">睡眠()；—线程在指定的时间间隔后启动，除非它被中断。</li><li id="4b1c" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">挂起()；—此方法将线程置于挂起状态，并且可以使用resume()方法恢复。</li><li id="909a" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">wait()；—使当前线程等待，直到另一个线程调用notify()。</li><li id="7e6e" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">notify()；—唤醒正在该对象的监视器上等待的单个线程。</li><li id="998c" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">resume()；—此方法恢复使用suspend()方法挂起的线程。</li><li id="5c61" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">stop()；—此方法完全停止线程。</li></ul><h2 id="3d15" class="ll ka hi bd kb lq lr ls kf lt lu lv kj ix lw lx kn jb ly lz kr jf ma mb kv mc bi translated">等待()和睡眠()的区别</h2><p id="9780" class="pw-post-body-paragraph im in hi io b ip kx ir is it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj hb bi translated"><strong class="io jk"><em class="mj">【wait()】</em>是一个用于线程同步的实例方法。</strong>它可以在任何对象上被调用，因为它是在<em class="mj"> java.lang. Object、</em>上定义的，但是<strong class="io jk">它只能从同步块</strong>中被调用。它释放对象上的锁，以便另一个线程可以加入并获得锁。另一方面，<em class="mj"> Thread.sleep() </em>是一个静态方法，可以从任何上下文中调用。<strong class="io jk"> <em class="mj"> Thread.sleep() </em>暂停当前线程，不释放任何锁。</strong></p><p id="3d58" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">当我们使用<em class="mj"> sleep() </em>方法时，线程在指定的时间间隔后启动，除非它被中断。</p><p id="bf31" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">对于<em class="mj"> wait() </em>，唤醒过程稍微复杂一点。我们可以通过在被等待的监视器上调用<em class="mj"> notify() </em>或<em class="mj"> notifyAll() </em>方法来唤醒线程。</p><p id="09d9" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">当您想要唤醒所有处于等待状态的线程时，请使用<em class="mj"> notifyAll() </em>而不是<em class="mj"> notify() </em>。类似于<em class="mj"> wait() </em>方法本身，<em class="mj"> notify() </em>和<em class="mj"> notifyAll() </em>必须从同步的上下文中调用。</p><p id="ad99" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io jk">例如:</strong></p><p id="3a42" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">用线程写一个程序来显示数字1到10。如果该数字等于5，则线程休眠5000毫秒。(在这里，Sleep()方法应该包含在try块中，后跟catch块。)</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="2da9" class="ll ka hi lh b fi lm ln l lo lp">package threadtutorial;</span><span id="d6c0" class="ll ka hi lh b fi mi ln l lo lp">/**<br/> *<br/> * <a class="ae md" href="http://twitter.com/author" rel="noopener ugc nofollow" target="_blank">@author</a> Kasun Dissanayake<br/> */</span><span id="d7bb" class="ll ka hi lh b fi mi ln l lo lp">class Test extends Thread{<br/>    public void run(){<br/>        for (int i = 0; i &lt; 10; i++) {<br/>            if(i == 5){<br/>                try {<br/>                    Thread.sleep(5000);<br/>                } catch (InterruptedException e) {<br/>                    e.printStackTrace();<br/>                }<br/>            }<br/>            System.out.println(i);<br/>        }<br/>    }<br/>}</span><span id="9c18" class="ll ka hi lh b fi mi ln l lo lp">public class ThreadTutorial {</span><span id="69ae" class="ll ka hi lh b fi mi ln l lo lp">public static void main(String[] args) {</span><span id="fa7e" class="ll ka hi lh b fi mi ln l lo lp">Test test = new Test();<br/>        test.start();</span><span id="6e34" class="ll ka hi lh b fi mi ln l lo lp">}    <br/>}</span></pre><h1 id="da6e" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">线程优先级</h1><p id="6aa9" class="pw-post-body-paragraph im in hi io b ip kx ir is it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj hb bi translated">在Java中，我们可以给一个线程分配一个优先级，这个优先级会影响线程在运行时间表中的顺序。具有相同优先级的线程具有相同的优先级(这由Java调度程序完成),它们以先到先服务的方式共享处理器。</p><p id="ab42" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们可以使用<strong class="io jk"> setpriority() </strong>方法设置线程的优先级，如下所示。</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="e120" class="ll ka hi lh b fi lm ln l lo lp">Threadname.setpriority(int number);</span></pre><p id="53e3" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">该数字是一个整数值(1 -10之间的值)，是线程的优先级。</p><p id="fc7d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">线程类定义了几个优先级常量。</p><ul class=""><li id="b439" class="jl jm hi io b ip iq it iu ix jn jb jo jf jp jj jq jr js jt bi translated"><strong class="io jk">最小优先级</strong> = 1</li><li id="0750" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated"><strong class="io jk">最大优先级</strong> = 10</li></ul><p id="2da2" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">默认设置为<strong class="io jk">定额_优先级</strong>。这等于数值<strong class="io jk"> 5 </strong>。</p><h2 id="08ce" class="ll ka hi bd kb lq lr ls kf lt lu lv kj ix lw lx kn jb ly lz kr jf ma mb kv mc bi translated">练习:</h2><p id="4fd7" class="pw-post-body-paragraph im in hi io b ip kx ir is it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj hb bi translated">一种包括A类和B类的程序。A类用一个线程显示数字1-10，B类用一个线程显示数字10 -1。优先级为<strong class="io jk">A类线程—最大，B类线程—最小</strong></p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="5c4e" class="ll ka hi lh b fi lm ln l lo lp">package threadtutorial;</span><span id="c908" class="ll ka hi lh b fi mi ln l lo lp">/**<br/> *<br/> * <a class="ae md" href="http://twitter.com/author" rel="noopener ugc nofollow" target="_blank">@author</a> Kasun Dissanayake<br/> */</span><span id="a07d" class="ll ka hi lh b fi mi ln l lo lp">class A extends Thread{<br/>    public void run(){<br/>        System.out.println("Class A method...");<br/>        for (int i = 0; i &lt; 10; i++) {<br/>            System.out.println(i);<br/>        }<br/>    }<br/>}</span><span id="98d7" class="ll ka hi lh b fi mi ln l lo lp">class B extends Thread{<br/>    public void run(){<br/>        System.out.println("Class B method...");<br/>        for (int i = 10; i &gt; 0; i--) {<br/>            System.out.println(i);<br/>        }<br/>    }<br/>}<br/>public class ThreadTutorial {</span><span id="2224" class="ll ka hi lh b fi mi ln l lo lp">public static void main(String[] args) {<br/>        A a = new A();<br/>        B b = new B();<br/>        <br/>        a.setPriority(Thread.MAX_PRIORITY);<br/>        b.setPriority(Thread.MIN_PRIORITY);<br/>        <br/>        a.start();<br/>        b.start();</span><span id="d899" class="ll ka hi lh b fi mi ln l lo lp">}<br/>    <br/>}</span></pre><p id="43fb" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">执行代码。然后你会得到一个这样的结果。</p><figure class="lc ld le lf fd ij er es paragraph-image"><div class="er es ml"><img src="../Images/a0e9fef622a2e39e98e760556ed4aba9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1292/format:webp/1*jzdN0vW0ov9dbg-P6_mPLQ.png"/></div></figure><h1 id="d8c5" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">同步</h1><p id="7482" class="pw-post-body-paragraph im in hi io b ip kx ir is it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj hb bi translated">在运行中，方法线程试图使用一些位于运行方法内部和外部的资源。如果两个线程试图访问同一个资源，可能会出现问题。然后Java给了我们一种技术来克服这个问题，叫做<strong class="io jk">同步</strong>。这里我们可以用一种同步的方法来实现<strong class="io jk">同步</strong>机制<strong class="io jk">。</strong></p><p id="f332" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">同步主要用于</p><ol class=""><li id="eee7" class="jl jm hi io b ip iq it iu ix jn jb jo jf jp jj me jr js jt bi translated">以防止螺纹干涉。</li><li id="c92d" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj me jr js jt bi translated">以防止一致性问题。</li></ol><p id="7ed9" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">当我们将一个方法声明为synchronized时，Java会创建一个监视器，并将它交给第一个被调用的线程。其他线程不能访问该同步代码段。</p><p id="3c69" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">示例:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="c788" class="ll ka hi lh b fi lm ln l lo lp">//example of java synchronized method  <br/>class Table{  <br/> synchronized void printTable(int n){//synchronized method  <br/>   for(int i=1;i&lt;=5;i++){  <br/>     System.out.println(n*i);  <br/>     try{  <br/>      Thread.sleep(400);  <br/>     }catch(Exception e){System.out.println(e);}  <br/>   }  <br/>  <br/> }  <br/>}  <br/>  <br/>class MyThread1 extends Thread{  <br/>    Table t;  <br/>    MyThread1(Table t){  <br/>        this.t=t;  <br/>    }  <br/>    public void run(){  <br/>        t.printTable(5);  <br/>    }  <br/>  <br/>}</span><span id="9936" class="ll ka hi lh b fi mi ln l lo lp">class MyThread2 extends Thread{  <br/>    Table t;  <br/>    MyThread2(Table t){  <br/>        this.t=t;  <br/>    }  <br/>    public void run(){  <br/>        t.printTable(100);  <br/>    }  <br/>}  <br/>  <br/>public class Example6{  <br/>    public static void main(String args[]){  <br/>        Table obj = new Table();//only one object  <br/>        MyThread1 t1=new MyThread1(obj);  <br/>        MyThread2 t2=new MyThread2(obj);  <br/>        t1.start();  <br/>        t2.start();  <br/>    }  <br/>}</span></pre><p id="b022" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">执行代码，你会得到这样一个结果。</p><figure class="lc ld le lf fd ij er es paragraph-image"><div class="er es mm"><img src="../Images/16eecc5ce2163febd7a0b06d05328a11.png" data-original-src="https://miro.medium.com/v2/resize:fit:994/format:webp/1*J79WdWo9hqAK-Buxpon1xQ.png"/></div></figure><p id="7b81" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这里，MyThread1调用一个同步方法，它自动获取该对象的锁，并在线程完成任务时释放它。</p><p id="4c06" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">然后调用并执行第二个线程MyThread2。</p><h2 id="50eb" class="ll ka hi bd kb lq lr ls kf lt lu lv kj ix lw lx kn jb ly lz kr jf ma mb kv mc bi translated">2.通过实现可运行的接口</h2><p id="8e0e" class="pw-post-body-paragraph im in hi io b ip kx ir is it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj hb bi translated">runnable接口声明了在我们的程序中实现线程所需的run()方法。</p><h2 id="9431" class="ll ka hi bd kb lq lr ls kf lt lu lv kj ix lw lx kn jb ly lz kr jf ma mb kv mc bi translated">步骤:</h2><ul class=""><li id="0c4e" class="jl jm hi io b ip kx it ky ix mf jb mg jf mh jj jq jr js jt bi translated">将该类声明为实现Runnable接口。</li><li id="91ad" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">实现run方法</li><li id="c29d" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">通过定义从这个runnable类实例化的对象作为线程的目标来创建线程</li><li id="a01d" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">调用线程的start()方法来运行线程</li></ul><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="7832" class="ll ka hi lh b fi lm ln l lo lp">package threadtutorial;</span><span id="2ac6" class="ll ka hi lh b fi mi ln l lo lp">/**<br/> *<br/> * <a class="ae md" href="http://twitter.com/author" rel="noopener ugc nofollow" target="_blank">@author</a> Kasun Dissanayake<br/> */</span><span id="fca7" class="ll ka hi lh b fi mi ln l lo lp">class Test implements Runnable{<br/>    public void run(){<br/>        for (int i = 0; i &lt; 10; i++) {<br/>            System.out.println(i);<br/>        }<br/>    }<br/>}</span><span id="1852" class="ll ka hi lh b fi mi ln l lo lp">public class ThreadTutorial {</span><span id="d855" class="ll ka hi lh b fi mi ln l lo lp">public static void main(String[] args) {</span><span id="127a" class="ll ka hi lh b fi mi ln l lo lp">Test test = new Test();<br/>        Thread thread = new Thread(test);<br/>        thread.start();</span><span id="9892" class="ll ka hi lh b fi mi ln l lo lp">}    <br/>}</span></pre><p id="c9c0" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">和往常一样，你可以在GitHub 上查看本文提供的例子。</p><p id="882e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">谢谢大家！</p></div></div>    
</body>
</html>