<html>
<head>
<title>Securing Hazelcast (tcp) traffic with Stunnel</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Stunnel保护Hazelcast (tcp)流量</h1>
<blockquote>原文：<a href="https://medium.com/swlh/securing-hazelcast-tcp-traffic-with-stunnel-ff2b4b93158a#2019-06-11">https://medium.com/swlh/securing-hazelcast-tcp-traffic-with-stunnel-ff2b4b93158a#2019-06-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="5c9a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Hazelcast是一个分布式内存数据网格，它允许在集群环境中的节点之间均匀地共享数据。Hazelcast的开源版本不支持传输中的加密，甚至不支持缓存级别的加密。因此，为了保护Hazelcast集群中的流量，我们需要通过更改一些代码来扩展它，这可能并不总是一个选项。</p><p id="91ec" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，还有另一种方法可以通过使用stunnel来保护传输。正如官方文档所述，“Stunnel是一个代理，旨在为现有的客户端和服务器添加TLS加密功能，而无需对程序代码进行任何更改”。在我们的情况下，这听起来是一个完美的选择，并允许我们将加密从我们的Hazelcast应用程序中分离出来。</p><p id="e9b6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下图说明了如何使用stunnel在双节点集群上使用相互TLS身份验证来启用传输加密。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/0f13965644e42e2311d96c8882639537.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*UCnb-G_t_O_xKnzD.png"/></div></div></figure><p id="7895" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如图所示，我们需要执行以下操作来设置它:</p><ol class=""><li id="3eec" class="jp jq hi ih b ii ij im in iq jr iu js iy jt jc ju jv jw jx bi translated">创建一个证书来加密传输。</li><li id="3f44" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">在每个节点上设置两个隧道(入站和出站)。</li><li id="5723" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">使用iptables将出站流量重定向到本地stunnel。</li></ol><blockquote class="kd ke kf"><p id="e9ec" class="if ig kg ih b ii ij ik il im in io ip kh ir is it ki iv iw ix kj iz ja jb jc hb bi translated"><strong class="ih kk"> <em class="hi">注意:</em> </strong> <em class="hi">在本例中，Hazelcast设置了tcp-ip，并禁用了多播。这个方法可以用在云环境中，比如</em> <strong class="ih kk"> <em class="hi"> AWS </em> </strong> <em class="hi">，不允许多点传送。</em></p><p id="f343" class="if ig kg ih b ii ij ik il im in io ip kh ir is it ki iv iw ix kj iz ja jb jc hb bi translated"><em class="hi">还要确保安全组(或防火墙)允许给定端口上的入站和出站流量。</em></p></blockquote><h2 id="1d8e" class="kl km hi bd kn ko kp kq kr ks kt ku kv iq kw kx ky iu kz la lb iy lc ld le lf bi translated">创建证书</h2><p id="29f8" class="pw-post-body-paragraph if ig hi ih b ii lg ik il im lh io ip iq li is it iu lj iw ix iy lk ja jb jc hb bi translated">让我们首先创建一个用于加密的自签名证书。下面是创建根ca和证书的命令。</p><pre class="je jf jg jh fd ll lm ln lo aw lp bi"><span id="94aa" class="kl km hi lm b fi lq lr l ls lt"># Create a root CA<br/>openssl req -new -x509 -sha256 -days 365 -key ca.key -out ca.crt</span><span id="279c" class="kl km hi lm b fi lu lr l ls lt"># Create a rsa key file<br/>openssl genrsa -out server.key 4096</span><span id="9d47" class="kl km hi lm b fi lu lr l ls lt">#Create a certificate request<br/>openssl req -new -key server.key -sha256 -out server.csr</span><span id="3f82" class="kl km hi lm b fi lu lr l ls lt"># Create the cert<br/>openssl x509 -req -days 365 -sha256 -in server.csr -CA ca.crt -CAkey ca.key -set_serial 1 -out server.crt</span></pre><p id="12d7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="kg">(可选)</em>以下是为相互认证(MTLS/MASSL)创建客户端证书的步骤。</p><pre class="je jf jg jh fd ll lm ln lo aw lp bi"><span id="00f0" class="kl km hi lm b fi lq lr l ls lt"># Create key<br/>openssl genrsa -out client.key 4096</span><span id="c4dd" class="kl km hi lm b fi lu lr l ls lt"># Create a client csr<br/>openssl req -new -key client.key -out client.csr</span><span id="b712" class="kl km hi lm b fi lu lr l ls lt"># Create the client cert signed by the same root CA<br/>openssl x509 -req -days 365 -sha256 -in client.csr -CA ca.crt -CAkey ca.key -set_serial 2 -out client.crt</span></pre><p id="d5a1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">将两个节点上的证书文件复制到<em class="kg"> /opt/certs </em>下。</p><h2 id="401c" class="kl km hi bd kn ko kp kq kr ks kt ku kv iq kw kx ky iu kz la lb iy lc ld le lf bi translated">设置stunnel</h2><p id="6703" class="pw-post-body-paragraph if ig hi ih b ii lg ik il im lh io ip iq li is it iu lj iw ix iy lk ja jb jc hb bi translated">Stunnel在几乎所有的linux发行版中都有，下面的命令可以用来在Centos上安装它。</p><pre class="je jf jg jh fd ll lm ln lo aw lp bi"><span id="3bb5" class="kl km hi lm b fi lq lr l ls lt">sudo yum install stunnel</span></pre><p id="05ca" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们在每个节点上创建两个配置文件，让我们在<em class="kg"> /etc/stunnel </em>中将它们分别称为<em class="kg"> hc-client.conf </em>(用于出站流量)和<em class="kg"> hc-server.conf </em>(用于入站流量)。</p><blockquote class="kd ke kf"><p id="d235" class="if ig kg ih b ii ij ik il im in io ip kh ir is it ki iv iw ix kj iz ja jb jc hb bi translated">以下示例假设<strong class="ih kk">相互TLS认证</strong>，但是可以通过从hc-client.conf文件中删除客户端证书和密钥，以及从hc-server.conf文件中删除客户端验证来禁用该认证。</p></blockquote><p id="2436" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih kk"> hc-client.conf </strong></p><pre class="je jf jg jh fd ll lm ln lo aw lp bi"><span id="a7cd" class="kl km hi lm b fi lq lr l ls lt">[hazelcast-out]<br/>client = yes<br/>accept = 9001<br/>connect = &lt;remote-node-ip&gt;:9000<br/>verify = 3<br/>CAfile = /opt/certs/ca.crt<br/>cert = /opt/certs/client.crt<br/>key = /opt/certs/client.key</span></pre><p id="0c82" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">客户端的上述配置将从端口9001上的<em class="kg">本地</em> Hazelcast节点接收流量，并通过加密隧道将其代理到端口9000上侦听的<em class="kg">远程</em>节点。</p><p id="2e62" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih kk"> hc-server.conf </strong></p><pre class="je jf jg jh fd ll lm ln lo aw lp bi"><span id="79ef" class="kl km hi lm b fi lq lr l ls lt">[hazelcast-in]<br/>accept = 9000<br/>connect = &lt;local-nodeip&gt;:5701<br/>verify = 2<br/>CAfile = /opt/certs/ca.crt<br/>cert = /opt/certs/server.crt<br/>key = /opt/cert/server.key</span></pre><p id="f583" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">服务器端配置将在端口9000上接收来自<em class="kg">远程</em>客户端节点的TLS流量，并在<em class="kg">卸载</em> TLS加密后，将其重定向到在端口5701上运行的<em class="kg">本地</em> Hazelcast实例。</p><p id="f94a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">stunnel和Hazelcast之间的所有通信都将被加密。</p><p id="d895" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是我们如何在两个节点上使用上述配置文件运行stunnel:</p><pre class="je jf jg jh fd ll lm ln lo aw lp bi"><span id="93f5" class="kl km hi lm b fi lq lr l ls lt">sudo stunnel /etc/stunnel/hz-client.conf<br/>sudo stunnel /etc/stunnel/hz-server.conf</span></pre><h2 id="3b42" class="kl km hi bd kn ko kp kq kr ks kt ku kv iq kw kx ky iu kz la lb iy lc ld le lf bi translated">将出站流量从本地Hazelcast实例重定向到stunnel</h2><p id="4b43" class="pw-post-body-paragraph if ig hi ih b ii lg ik il im lh io ip iq li is it iu lj iw ix iy lk ja jb jc hb bi translated">既然隧道已经设置好了，我们需要将外出的Hazelcast流量重定向到stunnel，以便它可以通过TLS加密通道。为此，我们将在两个节点上使用<strong class="ih kk"> iptables </strong>设置以下路由规则。</p><pre class="je jf jg jh fd ll lm ln lo aw lp bi"><span id="7bc2" class="kl km hi lm b fi lq lr l ls lt">sudo iptables -t nat -A OUTPUT -p tcp \<br/> -d &lt;remote-node-ip&gt; --dport 5701 -j DNAT --to-destination localhost:9001</span></pre><p id="6c70" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦设置了路由规则，出站Hazelcast流量将流经加密隧道。</p><h2 id="7f11" class="kl km hi bd kn ko kp kq kr ks kt ku kv iq kw kx ky iu kz la lb iy lc ld le lf bi translated">结论</h2><p id="c489" class="pw-post-body-paragraph if ig hi ih b ii lg ik il im lh io ip iq li is it iu lj iw ix iy lk ja jb jc hb bi translated">上面的帖子解释了如何通过TLS加密隧道引导未加密的流量(入站和出站),将传输加密与Hazelcast应用程序分离。这种方法可用于加密应用程序之间的TCP流量，而不仅仅是Hazelcast。</p></div></div>    
</body>
</html>