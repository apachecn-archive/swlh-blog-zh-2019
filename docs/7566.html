<html>
<head>
<title>Many ways to use Destructuring in Modern JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在现代JavaScript中使用析构的许多方法</h1>
<blockquote>原文：<a href="https://medium.com/swlh/many-ways-of-using-destructuring-in-modern-javascript-92c6767646bc?source=collection_archive---------3-----------------------#2019-07-04">https://medium.com/swlh/many-ways-of-using-destructuring-in-modern-javascript-92c6767646bc?source=collection_archive---------3-----------------------#2019-07-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/a108b677dbff3091440f31b1ea8dde87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w_xhRsHB9bkoQxFAI8KKSA.jpeg"/></div></div></figure><p id="7064" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">毫无疑问，析构是我最喜欢的JavaScript语言特性之一。它的主要目的是<em class="jo">同时改进你的代码</em>和<em class="jo">简化它</em>。</p><h1 id="8380" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">那么，什么是解构？</h1><p id="6ea2" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">根据定义，析构允许您将一个或多个属性从一个对象中提取到一个单独的变量中，但是范围会超出这个范围。析构也可以用于数组。它可以用在循环中，函数中，交换变量等等。<br/>在这篇文章中，我将向你介绍使用这个强大功能的许多方法。</p></div><div class="ab cl ks kt gp ku" role="separator"><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx"/></div><div class="hb hc hd he hf"><p id="7a9c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们首先创建一个简单的<em class="jo">用户</em>对象。</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="8a4c" class="li jq hi le b fi lj lk l ll lm">const user = { <br/>  fullName: 'Sam Fisher',<br/>  age: 62,<br/>  job: 'spy'<br/>}</span></pre><p id="6eab" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在析构之前，如果我们想创建一个变量并赋予它一个属性，我们会这样做，</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="9dce" class="li jq hi le b fi lj lk l ll lm">const name = user.fullName;<br/>console.log(name) // 'Sam Fisher';</span></pre><p id="a673" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">其中变量<em class="jo">名称</em>指的是我们的<em class="jo">用户</em>对象的<em class="jo">全名</em>属性。现在让我们来看一下使用析构特性的同一个例子:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="1fb1" class="li jq hi le b fi lj lk l ll lm">const { fullName } = user;<br/>console.log(fullName) // 'Sam Fisher';</span></pre><p id="2633" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这种情况下，变量<em class="jo"> fullName </em>不仅引用了<em class="jo"> fullName </em>属性，而且仅共享相同的名称。换句话说，当我们说</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="a019" class="li jq hi le b fi lj lk l ll lm">const { fullName } = user;</span></pre><p id="89c4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">JavaScript在名为<em class="jo">全名</em>的<em class="jo">用户</em>对象中寻找一个属性，并将其赋给一个名为<em class="jo">全名</em>的变量。很整洁对吗？现在让我们提取多个属性并比较结果。</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="e314" class="li jq hi le b fi lj lk l ll lm"><strong class="le ln">// Old way:<br/></strong>const fullName = user.fullName;<br/>const age = user.age;<br/>const job = user.job;<br/>console.log(fullName, age, job); // 'Sam Fisher' 62 'spy'</span><span id="3d11" class="li jq hi le b fi lo lk l ll lm"><strong class="le ln">// Destructuring way:<br/></strong>const { fullName, age, job } = user;<br/>console.log(fullName, age, job); // 'Sam Fisher' 62 'spy'</span></pre><p id="fb85" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以清楚地看到，使用析构我们简化了代码，用一行代码替换了三行代码！</p><blockquote class="lp lq lr"><p id="bff4" class="iq ir jo is b it iu iv iw ix iy iz ja ls jc jd je lt jg jh ji lu jk jl jm jn hb bi translated">请记住，你对你析构的属性所做的任何改变只会影响你创建的变量，而对象内部的属性将保持不变。</p></blockquote></div><div class="ab cl ks kt gp ku" role="separator"><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx"/></div><div class="hb hc hd he hf"><p id="e238" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们也可以这样做</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="d9bf" class="li jq hi le b fi lj lk l ll lm">const { age, job, fullName } = user;</span></pre><p id="c7b8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">并且输出将保持不变:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="869f" class="li jq hi le b fi lj lk l ll lm">console.log(fullName, age, job); // 'Sam Fisher' 62 'spy'</span></pre><p id="c125" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当处理对象时，属性的顺序并不重要。重要的是，我们要匹配要提取的每个属性的确切名称。</p><p id="91f4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">也就是说，析构不仅可以用于将变量记录到控制台。因为我们提取的每个属性都是一个变量，就像任何其他属性一样，它可以像任何其他属性一样使用:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="2fab" class="li jq hi le b fi lj lk l ll lm">const { age } = user;<br/>if ( age &lt; 100 ) {<br/>  return 'Hello';<br/>}<br/>return 'World';</span></pre><p id="83f8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是如果物业名称太长或者我们只是不喜欢这个名称呢？我们能做点什么吗？是的，我们可以做到这一点，</p><h2 id="e819" class="li jq hi bd jr lv lw lx jv ly lz ma jz jb mb mc kd jf md me kh jj mf mg kl mh bi translated">别名</h2><p id="0b64" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">当您从对象中提取属性时，您可以给它一个别名，然后使用别名来引用该属性。</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="206c" class="li jq hi le b fi lj lk l ll lm">const { fullName: fn } = user;</span></pre><p id="4df2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">从这里开始，每当我们想要使用<em class="jo">全名</em>属性时，我们将使用<em class="jo"> fn </em>别名。</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="6ac3" class="li jq hi le b fi lj lk l ll lm">console.log(fn); // 'Sam Fisher'</span></pre><h2 id="ae0f" class="li jq hi bd jr lv lw lx jv ly lz ma jz jb mb mc kd jf md me kh jj mf mg kl mh bi translated">默认值</h2><p id="c832" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">当析构属性时，我们可以将<strong class="is ln">默认值</strong>添加到<em class="jo">未定义的属性</em>中。请考虑这个例子:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="ae17" class="li jq hi le b fi lj lk l ll lm">const user = {<br/>  name: undefined<br/>}</span></pre><p id="2828" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">很明显，如果我们记录<em class="jo">用户名</em>，输出将是<em class="jo">未定义的</em>。在这种情况下，我们可以为name属性设置一个默认值。</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="5e36" class="li jq hi le b fi lj lk l ll lm">const { name = 'Sam' } = user;<br/>console.log(name); // Sam</span></pre><p id="f249" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我们知道了这是如何工作的，我们可以将这个逻辑应用于所有没有被定义的属性。</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="481c" class="li jq hi le b fi lj lk l ll lm">const user = {<br/>  name: 'Sam',<br/>  lastName: 'Fisher'  <br/>}</span><span id="2dfb" class="li jq hi le b fi lo lk l ll lm">const { name, lastName, job = 'spy' } = user;</span></pre><p id="92fd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们给了我们的<em class="jo">用户</em>对象两个属性，<em class="jo">名</em>和<em class="jo">姓</em>，但是<em class="jo">作业</em>属性不是<em class="jo">用户</em>对象的一部分，因此它是<em class="jo">未定义的</em>。这意味着<strong class="is ln">默认值</strong>背后的逻辑可以应用于此。</p><blockquote class="lp lq lr"><p id="c9f4" class="iq ir jo is b it iu iv iw ix iy iz ja ls jc jd je lt jg jh ji lu jk jl jm jn hb bi translated">在一条语句中，我们可以从用户对象中取出属性，放入它们自己的变量中，创建一个新变量<strong class="is ln"> <em class="hi"> job </em> </strong>，并为其赋值。</p></blockquote><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="86a7" class="li jq hi le b fi lj lk l ll lm">console.log(name, lastName, job); // 'Sam' 'Fisher' 'spy'</span></pre><figure class="kz la lb lc fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mi"><img src="../Images/859ab3225fe60959cd000ef6ba6edbb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DvtU2FhDiudozjqs395fLQ.jpeg"/></div></div></figure><h1 id="b4e7" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">命名出口</h1><p id="baa7" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">如果你曾经使用过Angular、React或任何其他JavaScript框架，毫无疑问你会遇到一个名为Export 的<strong class="is ln">。就像析构一个对象一样，使用<em class="jo"> import </em>关键字我们可以选择我们想要包含的模块导出:</strong></p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="b0a8" class="li jq hi le b fi lj lk l ll lm">import React, { Component } from 'React';</span></pre><p id="bb9e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里我们将React导入到我们的项目中，但是我们也从React导入组件到它自己的名为Component的变量中。从现在开始，每当我们想要创建一个新的组件时，我们扩展component，而不添加React前缀:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="bcdc" class="li jq hi le b fi lj lk l ll lm"><strong class="le ln">// Old way<br/></strong>import React from 'React';<br/>class MyComponent extends React.Component{}</span><span id="6e78" class="li jq hi le b fi lo lk l ll lm"><strong class="le ln">// New way<br/></strong>import React, { Component } from 'React';<br/>class MyComponent extends Component{}</span></pre><p id="89d9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">同样的原则适用于我们导入的任何其他包，例如:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="e659" class="li jq hi le b fi lj lk l ll lm">import { isEmail, isCreditCard } from 'validator';</span></pre><p id="43c5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里我们只导入我们想要的函数，然后独立使用这些函数:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="44f0" class="li jq hi le b fi lj lk l ll lm">console.log(isEmail('my@email.com')); // true</span></pre><figure class="kz la lb lc fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mi"><img src="../Images/af8f5ebbc7898d5be6a72c7ebaa80cce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gb6wUEEKFDx7KF2vVCT7Fg.jpeg"/></div></div></figure><h1 id="72c1" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">解构数组</h1><p id="5270" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">如前所述，在JavaScript中我们也可以析构数组。概念几乎是相同的，但只是这一次我们使用了方括号和元素的顺序<strong class="is ln">问题</strong>。<br/>让我们创建一个基本数组:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="bbdc" class="li jq hi le b fi lj lk l ll lm">const numbers = [ 10, 20, 30 ];</span><span id="f507" class="li jq hi le b fi lo lk l ll lm">// We can assign each element to a variable<br/>const a = numbers[0];<br/>const b = numbers[1];<br/>const c = numbers[2];</span><span id="b217" class="li jq hi le b fi lo lk l ll lm">console.log(a); // 10<br/>console.log(b); // 20<br/>console.log(c); // 30</span></pre><p id="a3b8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">和之前的对象一样，使用析构，我们可以从数组中取出元素，并立即将它们存储到变量中。</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="a1ed" class="li jq hi le b fi lj lk l ll lm">const numbers = [ 10, 20, 30 ];<br/>const [ a ] = numbers;</span><span id="ac6a" class="li jq hi le b fi lo lk l ll lm">console.log(a); // 10</span></pre><p id="e600" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">通过用方括号将变量括起来，我们创建了一个类似数组的元素，其中变量<em class="jo"> a </em>被放置为第0个索引，并引用numbers数组中的第<strong class="is ln">个</strong>元素。<br/>我们添加的每个新变量都将引用数组中的下一个元素:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="6b20" class="li jq hi le b fi lj lk l ll lm">const numbers = [ 10, 20, 30 ];<br/>const [ a, b, c ] = numbers;</span><span id="d389" class="li jq hi le b fi lo lk l ll lm">console.log(a); // 10<br/>console.log(b); // 20<br/>console.log(c); // 30</span></pre></div><div class="ab cl ks kt gp ku" role="separator"><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx"/></div><div class="hb hc hd he hf"><p id="dca1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们也可以使用逗号来跳过元素:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="c8cb" class="li jq hi le b fi lj lk l ll lm">const numbers = [ 10, 20, 30 ];<br/>const [ a, , b] = numbers;</span></pre><p id="c304" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">变量<em class="jo"> a </em>是数字数组的第一个元素，但是<em class="jo"> b </em>是第二个<strong class="is ln">而不是第三个</strong><strong class="is ln"/>。<em class="jo"> b </em>是第三个元素。中间的逗号代表被<em class="jo">跳过的</em>元素。因此:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="330d" class="li jq hi le b fi lj lk l ll lm">console.log(a); // 10<br/>console.log(b); // 30</span></pre></div><div class="ab cl ks kt gp ku" role="separator"><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx"/></div><div class="hb hc hd he hf"><p id="f0aa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用<strong class="is ln">展开</strong> / <strong class="is ln">剩余</strong>操作符"<strong class="is ln"> … </strong>"我们可以将数组中剩余的<em class="jo">元素</em>作为目标:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="1059" class="li jq hi le b fi lj lk l ll lm">const numbers = [ 10, 20, 30 ];<br/>const [ a, ...b ] = numbers;</span></pre><p id="627c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">变量<em class="jo"> a </em>将再次成为第一个元素。变量<em class="jo"> b </em>有一个<strong class="is ln"> rest </strong>操作符前缀，这意味着b是一个填充了numbers数组中剩余元素的数组。</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="9f42" class="li jq hi le b fi lj lk l ll lm">console.log(a); // 10<br/>console.log(b); // [ 20, 30 ];</span></pre><p id="b818" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">请记住，为了让这个操作生效，<strong class="is ln"> rest </strong>操作符只能赋给我们正在析构的变量中的最后一个元素。</p><p id="ec6c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is ln">默认值</strong></p><p id="5823" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">与对象非常相似，我们可以给所有<em class="jo">未定义的</em>数组元素默认值。</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="c54e" class="li jq hi le b fi lj lk l ll lm">const arr = [ undefined, undefined, 3 ];<br/>const [ first = 1, second = 2, third ] = arr;</span><span id="0929" class="li jq hi le b fi lo lk l ll lm">console.log(first); // 1<br/>console.log(second); // 2<br/>console.log(third); // 3</span></pre><p id="9aba" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这同样适用于不属于数组的元素:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="4322" class="li jq hi le b fi lj lk l ll lm">const nums = [ 1, 2, 3 ];<br/>const [ a, b, c, d = 5 ] = nums;</span><span id="a028" class="li jq hi le b fi lo lk l ll lm">console.log(a); // 1<br/>console.log(b); // 2<br/>console.log(c); // 3<br/>console.log(d); // 5</span></pre><p id="6c12" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">变量<em class="jo"> d </em>不是<em class="jo"> nums </em>数组的一部分，因此它的值是<em class="jo">未定义的</em>，我们可以再次应用<strong class="is ln">默认值</strong>背后的逻辑，创建一个新变量并为其赋值(在本例中为5)。</p><p id="68cd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一个未能析构数组的特性是<strong class="is ln">别名</strong>。这并不奇怪，因为从数组中提取元素时，我们可以随意命名变量。</p><figure class="kz la lb lc fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mi"><img src="../Images/aae35c5807cd844a4978a7500af75544.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mT8hlErx3nhz0dRKnxYRPQ.jpeg"/></div></div></figure><h1 id="49ea" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">析构函数参数</h1><p id="155e" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">曾经遇到过需要传递给函数的一长串参数的问题吗？我们不再多说，因为这是一个游戏规则的改变者。</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="b608" class="li jq hi le b fi lj lk l ll lm">// <strong class="le ln">Old way</strong><br/>const username = 'SamFisher';<br/>const email ='sam.fisher@thirdechelon.com';<br/>const password ='UqFkD8kCpW';<br/>const age = 62;<br/>const job = 'spy';</span><span id="c9ab" class="li jq hi le b fi lo lk l ll lm">funky(username, email, password, age, job);</span><span id="2f70" class="li jq hi le b fi lo lk l ll lm">// <strong class="le ln">New way</strong><br/>const user = {<br/>  username: 'SamFisher',<br/>  email: 'sam.fisher@thirdechelon.com',<br/>  password: 'UqFkD8kCpW',<br/>  age: 62,<br/>  job: 'spy'<br/>};</span><span id="39c2" class="li jq hi le b fi lo lk l ll lm">funky(user);</span><span id="9454" class="li jq hi le b fi lo lk l ll lm">// <strong class="le ln">Alternative</strong><br/>funky(<strong class="le ln">{</strong> <br/>  username: 'SamFisher',<br/>  email: 'sam.fisher@thirdechelon.com' ,<br/>  password: 'UqFkD8kCpW',<br/>  age: 62,<br/>  job: 'spy'<br/><strong class="le ln">}</strong>);</span></pre><p id="f4f9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们不是将一长串属性传递给函数，而是创建一个包含这些属性的对象，然后将该对象作为参数传递给函数。然后我们只拉出<strong class="is ln">我们想要使用的</strong>属性。</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="9855" class="li jq hi le b fi lj lk l ll lm">// <strong class="le ln">Old way</strong><br/>function funky(username, email, password, age, job) {<br/>  console.log(email, password);<br/>}</span><span id="cb4a" class="li jq hi le b fi lo lk l ll lm">// <strong class="le ln">New way</strong><br/>function funky(<strong class="le ln">{</strong> email: e, password: pw <strong class="le ln">}</strong>) {<br/>  console.log(e, pw);<br/>}</span></pre><p id="a04f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如上所述，JavaScript在我们作为参数传递的对象中寻找属性<em class="jo"> email </em>和<em class="jo">密码</em>，所以顺序<strong class="is ln">也无关紧要</strong>。添加别名只是进一步简化了事情。</p></div><div class="ab cl ks kt gp ku" role="separator"><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx"/></div><div class="hb hc hd he hf"><p id="a0f3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个概念也适用于数组。这个想法是将一个数组传递给我们正在调用的函数，然后只提取我们想要的元素。让我们先看看在析构之前这是如何处理的:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="5671" class="li jq hi le b fi lj lk l ll lm">const people = ['Batman', 'Superman', 'Arrow'];</span><span id="46c5" class="li jq hi le b fi lo lk l ll lm">function getPerson( arrayOfPeople ) {<br/>  console.log(arrayOfPeople[0]); // 'Batman'<br/>  console.log(arrayOfPeople[1]); // 'Superman'<br/>  console.log(arrayOfPeople[2]); // 'Arrow'<br/>}</span><span id="99de" class="li jq hi le b fi lo lk l ll lm">getPerson(people);</span></pre><p id="6317" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如前所述，析构使我们能够更有效地操纵数据，这就是我们如何将它应用到前面的例子中:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="860d" class="li jq hi le b fi lj lk l ll lm">const people = ['Batman', 'Superman', 'Arrow'];</span><span id="ec31" class="li jq hi le b fi lo lk l ll lm">function getPerson( [ a, b, c ] ) {<br/>  console.log(a); // 'Batman'<br/>  console.log(b); // 'Superman'<br/>  console.log(c); // 'Arrow'<br/>}</span><span id="e12f" class="li jq hi le b fi lo lk l ll lm">getPerson(people);</span></pre><p id="0218" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">数组参数中的每个元素都代表该索引处的<em class="jo"> people </em>数组中的一个元素。我们可以再次使用<strong class="is ln"> rest </strong>操作符来定位数组的其余部分:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="db8c" class="li jq hi le b fi lj lk l ll lm">function getPerson( [ a, <strong class="le ln">...</strong>b ] ) {<br/>  console.log(a); // 'Batman'<br/>  console.log(b); // [ 'Superman', 'Arrow' ]<br/>}</span><span id="8de6" class="li jq hi le b fi lo lk l ll lm">getPerson(people);</span></pre><figure class="kz la lb lc fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mi"><img src="../Images/2e51b54f54f43bf6e93408206cc604a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*txGPUjBKboX6uj9ciL2j2A.jpeg"/></div></div></figure><h1 id="04fc" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">析构返回语句</h1><p id="c87a" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">就像函数参数一样，我们可以析构函数返回的值。这可以应用于返回对象或数组的函数。<br/> <strong class="is ln">情况1 </strong>:函数返回一个对象</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="f07b" class="li jq hi le b fi lj lk l ll lm">function getUserDetails() {<br/>  return { name: 'Sam Fisher', age: 62, job: 'spy' }<br/>}<br/>const { name } = getUserDetails();</span><span id="56b7" class="li jq hi le b fi lo lk l ll lm">console.log(name); // 'Sam Fisher'</span></pre><p id="bede" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is ln">情况2 </strong>:函数返回一个数组</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="ea3f" class="li jq hi le b fi lj lk l ll lm">function getAvengers() {<br/>  return ['Ironman', 'Captain America', 'Thor', 'Hulk']<br/>}</span><span id="d91b" class="li jq hi le b fi lo lk l ll lm">const [ a, , , b ] = getAvengers();</span><span id="9fc8" class="li jq hi le b fi lo lk l ll lm">// Notice that I created two commas in the middle. This means that I'm skipping both Captain America and Thor</span><span id="1c9f" class="li jq hi le b fi lo lk l ll lm">console.log(a); // 'Ironman'<br/>console.log(b); // 'Hulk'</span></pre><p id="d753" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">就这么简单。</p><figure class="kz la lb lc fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mi"><img src="../Images/449b6aa5cedad418b35a0c8cd6df2dee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sbECxjDKCu8WfMDPcc88fg.jpeg"/></div></div></figure><h1 id="83e5" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">循环内部的析构</h1><p id="4f7b" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">到目前为止，我们已经看到了析构的许多用途，但是我们还没有触及的一个主题是循环。让我们首先创建一个数组，然后使用<em class="jo"> for of </em>循环来迭代该数组。</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="b4d7" class="li jq hi le b fi lj lk l ll lm">const numbers = [ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ] ];</span><span id="1b39" class="li jq hi le b fi lo lk l ll lm">for (let num of numbers) {<br/>  console.log(num);<br/>}<br/>// [ 1, 2, 3 ]<br/>// [ 4, 5, 6 ]<br/>// [ 7, 8, 9 ]</span></pre><p id="6b8f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于<em class="jo"> numbers </em>数组中的每个内部数组，我们打印该数组的迭代。现在让我们应用析构并从每次迭代中取出元素。然后我们得到这样的结果:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="a2d2" class="li jq hi le b fi lj lk l ll lm">const numbers = [ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ] ];</span><span id="5b08" class="li jq hi le b fi lo lk l ll lm">for (let [ a, b, c ] of numbers) {<br/>  console.log(a, b, c);<br/>}<br/>// 1 2 3<br/>// 4 5 6<br/>// 7 8 9</span></pre><p id="6903" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">很酷吧？<br/>这里是另一个结合<strong class="is ln">默认值</strong>的例子。</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="66c3" class="li jq hi le b fi lj lk l ll lm">const simpsons = [<br/>  { name: 'Homer', age: 36 },<br/>  { name: 'Marge', age: 34},<br/>  { name: 'Bart' },<br/>  { name: 'Lisa', age: 7 },<br/>  { name: 'Maggie' }<br/>];</span></pre><p id="8ec3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">很明显，有些对象没有<em class="jo">年龄</em>属性。我们可以遍历所有对象，而不是为每个没有<em class="jo">年龄</em>属性的用户返回undefined，我们可以给这些用户一个<em class="jo">年龄</em>，默认值为0。</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="9d2a" class="li jq hi le b fi lj lk l ll lm">for (let { name, age = 0 } of simpsons ) {<br/>  console.log(name, age);<br/>}</span><span id="80e1" class="li jq hi le b fi lo lk l ll lm">// 'Homer' 36<br/>// 'Marge' 34<br/>// 'Bart' 0<br/>// 'Lisa' 7<br/>// 'Maggie' 0</span></pre><figure class="kz la lb lc fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mi"><img src="../Images/f045e551fafd842b1bd78bf5e9fce28b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZY4iSIjigVxm5QgN1cmQUw.jpeg"/></div></div></figure><h1 id="a5cb" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">析构嵌套对象和数组</h1><p id="a474" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">析构简化了我们编写JavaScript的方式，但这并不意味着析构就意味着简单的用途。</p></div><div class="ab cl ks kt gp ku" role="separator"><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx"/></div><div class="hb hc hd he hf"><p id="0178" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is ln">解构嵌套对象</strong></p><p id="6ec6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">考虑一下这个假的气象API数据:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="3d53" class="li jq hi le b fi lj lk l ll lm">const weatherData = {<br/>  city: 'London',<br/>  temperature: {<br/>    minimum: 10,<br/>    expected: 30,<br/>    current: 25<br/>  }<br/>}</span></pre><p id="a331" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">考虑构建一个天气应用程序，并使用以前的API向用户呈现当前温度。你可以写下<br/><em class="jo">weather data . temperature . current</em>，但是你可以应用析构。</p><p id="4bfb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们一步一步解开这个API数据。<br/>我们首先拉出一个<em class="jo">温度</em>对象，并将其分配给其父对象<em class="jo">天气数据</em>:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="05ae" class="li jq hi le b fi lj lk l ll lm">const { temperature } = weatherData;</span></pre><p id="44af" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后，在这两个属性之间放置另一个属性或一组我们希望取出的属性，并用另一对花括号将它们括起来。<br/>然后我们得到看起来像这样的东西，</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="670c" class="li jq hi le b fi lj lk l ll lm">const { temperature: { current } } = weatherData;</span></pre><p id="a217" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">其中<em class="jo">当前</em>是<em class="jo">温度</em>对象的属性，<em class="jo">温度</em>是<em class="jo">天气数据</em>对象的属性。现在我们已经创建了一个名为<em class="jo"> current </em>的变量，我们可以随心所欲地使用它。</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="a0fe" class="li jq hi le b fi lj lk l ll lm">console.log(current); // output: 25</span></pre><p id="0842" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们也可以在这里使用一个<strong class="is ln">别名</strong>。</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="4e86" class="li jq hi le b fi lj lk l ll lm">const { temperature: { current: c, expected: e } } = weatherData;<br/>console.log(c); // output: 25<br/>console.log(e); output: 30</span></pre><p id="2c55" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果属性有一个<em class="jo">未定义的</em>值，我们可以给它一个<strong class="is ln">缺省值</strong>或者如果它甚至不存在于我们的对象中，我们可以像一个析构变量一样创建它，</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="9387" class="li jq hi le b fi lj lk l ll lm">const { temperature: { likelyNot: LN = 9999 } } = weatherData;<br/>console.log(LN); // output: 9999</span></pre><p id="a181" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">其中<em class="jo"> LN </em>是<em class="jo"> likelyNot </em>的别名。</p><p id="f683" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">同样的概念可以应用于嵌套更深的对象。</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="14f3" class="li jq hi le b fi lj lk l ll lm">const weatherData = {<br/>  city: 'London',<br/>  temperatureCelsius: {<br/>    minimum: 10,<br/>    expected: 30,<br/>    current: 25<br/>  },<br/>  temperatureFahrenheit: {<br/>    minimum: 50,<br/>    expected: 86,<br/>    current: 77<br/>  }<br/>}</span></pre><p id="9881" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在让我们从两个物体上获得当前温度。</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="c26f" class="li jq hi le b fi lj lk l ll lm">oonst { <br/>  temperatureCelsius: { current: currentC },<br/>  temperatureFahrenheit: { current: currentF }<br/>} = weatherData;</span><span id="d32b" class="li jq hi le b fi lo lk l ll lm">console.log(currentC); // output: 25<br/>console.log(currentF); // output: 77</span></pre><p id="f724" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">请注意，我在这里使用别名是为了避免两个不同的温度变量同名的冲突。</p></div><div class="ab cl ks kt gp ku" role="separator"><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx"/></div><div class="hb hc hd he hf"><p id="ca4d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is ln">析构嵌套数组</strong></p><p id="f94b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">嵌套数组在JavaScript中很常见，使用现代JavaScript已经大大简化了对它们的处理。<br/>把这个英雄阵列算一算:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="fb12" class="li jq hi le b fi lj lk l ll lm">const heroes = [<br/> [ 'Spiderman', 'Iron Man', 'Captain America' ],<br/> ['Batman', 'Superman', 'Wonder Woman']<br/>]</span></pre><p id="b4cc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们将<em class="jo">漫威</em>和<em class="jo"> DC </em>英雄提取到两个独立的数组中:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="1dc8" class="li jq hi le b fi lj lk l ll lm">const [ marvel, dc ] = heroes;</span><span id="0de1" class="li jq hi le b fi lo lk l ll lm">console.log(marvel); <br/>// output: [ 'Spiderman', 'Iron Man', 'Captain America' ]</span><span id="c897" class="li jq hi le b fi lo lk l ll lm">console.log(dc); <br/>// output: ['Batman', 'Superman', 'Wonder Woman']</span></pre><p id="065b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在让我们把这个例子向前推进一步，在我们的<em class="jo"> heroes </em>数组中添加另一个数组。在我们的内部数组中，我们将定义一个属性，在这种情况下，它将引用第一个内部数组的第一个元素。</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="cbd2" class="li jq hi le b fi lj lk l ll lm">const [ [ spider ] ] = heroes;<br/>console.log(spider); // output: 'Spiderman'</span></pre><p id="e407" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">就像之前我们可以用逗号来跳过数组元素一样。让我们从第一个数组中提取最后一个元素。</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="cf45" class="li jq hi le b fi lj lk l ll lm">const [ [ , , captain ] ] = heroes<br/>console.log(captain); // output: 'Captain America'</span></pre><p id="2584" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果我们在我们的外部(<em class="jo">英雄</em>)数组中添加另一个内部数组，用逗号与第一个内部数组(<em class="jo">漫威</em>)隔开，它将引用一个<em class="jo"> DC英雄</em>的数组。从那里我们可以从<em class="jo"> DC </em>阵列中抽取一个或多个英雄。</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="368f" class="li jq hi le b fi lj lk l ll lm">const [ [ , , captain ], [ bat ] ] = heroes<br/>console.log(captain); // output: 'Captain America'<br/>console.log(bat); // output: 'Batman'</span></pre><p id="0b81" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">解构嵌套数组的另一种方法是使用ES9 <a class="ae mj" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/flat" rel="noopener ugc nofollow" target="_blank"> <strong class="is ln"> Array.flat() </strong> </a>函数，其目的是<em class="jo">将嵌套数组平坦化</em>为普通数组。</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="734d" class="li jq hi le b fi lj lk l ll lm">const flatten = heroes.flat();<br/>console.log(flatten);<br/>// output: [ 'Spiderman', 'Iron Man', 'Captain America', 'Batman', 'Superman', 'Wonder Woman']</span></pre><p id="0d88" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后我们可以像选择普通队伍一样选择我们的英雄:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="9739" class="li jq hi le b fi lj lk l ll lm">const [ spider, , captain, bat] = flatten;</span><span id="124f" class="li jq hi le b fi lo lk l ll lm">console.log(spider); // output: 'Spiderman'<br/>console.log(captain); // output: 'Captain America'<br/>console.log(bat); // output: 'Batman'</span></pre></div><div class="ab cl ks kt gp ku" role="separator"><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx"/></div><div class="hb hc hd he hf"><p id="a3bc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is ln">析构嵌套函数参数</strong></p><p id="2122" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">假设我们想要处理一个HTML元素的变化事件，并且我们想要获取一个我们输入的值。</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="975b" class="li jq hi le b fi lj lk l ll lm">&lt;input type="text" onchange="handleChange(event)"/&gt;</span></pre><p id="001b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用嵌套析构，我们可以从一个<em class="jo">事件</em>对象中提取一个<em class="jo">目标</em>对象，然后从目标中提取一个<em class="jo">值</em>属性:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="e9a9" class="li jq hi le b fi lj lk l ll lm"><strong class="le ln"># 1</strong><br/>function handleChange(event) {<br/>  const { value } = event.target;<br/>  console.log(value);<br/>}</span><span id="8e13" class="li jq hi le b fi lo lk l ll lm"><strong class="le ln"># 2</strong><br/>function handleChange({ target }) {<br/>  const { value } = target;<br/>  console.log(value);<br/>}</span><span id="8391" class="li jq hi le b fi lo lk l ll lm"><strong class="le ln"># 3</strong><br/>function handleChange({ target: { value } }) {<br/>  console.log(value);<br/>}</span></pre><p id="e140" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">嵌套数组也是如此。</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="9e63" class="li jq hi le b fi lj lk l ll lm">const nestedArray = [ [ 'A', 'B', 'C' ], [ 'D', 'E', 'F' ] ];<br/>handleNestedArray(nestedArray);</span><span id="c4b4" class="li jq hi le b fi lo lk l ll lm"><strong class="le ln"># 1</strong><br/>function handleNestedArray(full) {<br/>console.log(full); // output: [ ['A', 'B', 'C'], ['D', 'E', 'F'] ]<br/>}</span><span id="1da2" class="li jq hi le b fi lo lk l ll lm"><strong class="le ln"># 2</strong><br/>function handleNestedArray([ firstArray ]) {<br/>console.log(firstArray); // output: ['A', 'B', 'C']<br/>}</span><span id="02f2" class="li jq hi le b fi lo lk l ll lm"><strong class="le ln"># 3</strong><br/>function handleNestedArray([ [], [ , letterE ] ]) {<br/>console.log(letterE); // output: 'E'<br/>}</span></pre></div><div class="ab cl ks kt gp ku" role="separator"><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx"/></div><div class="hb hc hd he hf"><p id="3702" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is ln">析构嵌套返回语句</strong></p><p id="9dbd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你正在处理一个返回嵌套数组或对象的函数，你可以利用析构只提取你需要的属性。</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="8207" class="li jq hi le b fi lj lk l ll lm">function handleObject() { <br/>  return { target: { value: 'Hello' } };<br/>}</span><span id="099b" class="li jq hi le b fi lo lk l ll lm"><strong class="le ln"># 1</strong><br/>const result = handleObject();<br/>console.log(result); // output: { target: { value: 'Hello' } }</span><span id="c18c" class="li jq hi le b fi lo lk l ll lm"><strong class="le ln"># 2</strong><br/>const { target } = handleObject();<br/>console.log(target); // output: { value: 'Hello' }</span><span id="a0f7" class="li jq hi le b fi lo lk l ll lm"><strong class="le ln"># 3</strong><br/>const { target: { value } } = handleObject();<br/>console.log(value); // output: 'Hello'</span></pre><p id="7105" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这也适用于数组。</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="c71a" class="li jq hi le b fi lj lk l ll lm">function handleArray() {<br/>  return [ [ 1, 2], [3, 4] ];<br/>}</span><span id="032a" class="li jq hi le b fi lo lk l ll lm"><strong class="le ln"># 1</strong><br/>const fullArray = handleArray();<br/>console.log(fullArray); // output: [ [ 1, 2], [3, 4] ]</span><span id="2967" class="li jq hi le b fi lo lk l ll lm"><strong class="le ln"># 2</strong><br/>const [ first ] = handleArray();<br/>console.log(first); // output: [1, 2]</span><span id="28d7" class="li jq hi le b fi lo lk l ll lm"><strong class="le ln"># 3</strong><br/>const [ [ one, two ] ] = handleArray();<br/>console.log(one, two); // output: 1, 2</span></pre><figure class="kz la lb lc fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mi"><img src="../Images/498cf0f5bbaf9bbe9179bd0c71c5ecd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ABqOPCKxAK2kxBXia5m_SQ.jpeg"/></div></div></figure><h1 id="470a" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">用析构交换变量</h1><p id="bc07" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">使用析构赋值，我们可以做到这一点，交换变量！然而，这个<strong class="is ln">并不仅限于</strong>数字。我们可以交换任何类型，两个字符串，两个数组，两个对象，等等。在某些情况下，我们甚至可以交换不同类型的变量。</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="dce8" class="li jq hi le b fi lj lk l ll lm"><strong class="le ln">// Let's declare two variables<br/></strong>let hero = 'Mario';<br/>let villain = 'Bowser';<br/>console.log(hero, villain); <strong class="le ln">// 'Mario' 'Bowser'</strong></span><span id="380b" class="li jq hi le b fi lo lk l ll lm"><strong class="le ln">// Now let's swap them<br/></strong>[ hero, villain ] = [ villain, hero ];</span><span id="6a97" class="li jq hi le b fi lo lk l ll lm">console.log(hero, villain); <strong class="le ln">// 'Bowser' 'Mario'</strong></span></pre><p id="a2d8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们将两个变量都放在方括号中，并给它们分配另一对包装的变量，只是第二次交换位置。这导致变量转换值，突然布瑟成为英雄，马里奥成为恶棍！</p><h1 id="0762" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">日常使用中的破坏</h1><p id="0a80" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">当我写代码时，我倾向于尽可能使用析构。<br/>你知道你可以析构一个<em class="jo"> console.log </em>吗？</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="068d" class="li jq hi le b fi lj lk l ll lm">const { log, warn, error } = console;</span><span id="d658" class="li jq hi le b fi lo lk l ll lm">log('Hello World!'); <strong class="le ln">// equivalent to console.log('...');</strong><br/>warn('Watch out!'); <strong class="le ln">// console.warn('...');</strong><br/>error('Something went wrong!'); <strong class="le ln">// console.error('...');</strong></span></pre><p id="1661" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因为console是一个对象，所以你可以像对其他对象一样析构它的属性。<br/>但是你也可以析构<strong class="is ln"> HTML元素</strong>的属性。</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="9e43" class="li jq hi le b fi lj lk l ll lm">const { value } = document.querySelector('input');</span></pre><p id="3c8a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这样，从输入中提取一个<em class="jo">值</em>属性就容易多了，就像从按钮中提取一个禁用的属性一样。</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="6349" class="li jq hi le b fi lj lk l ll lm">const { disabled } = document.querySelector('button');</span></pre><p id="929a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这同样适用于所有其他属性。</p></div><div class="ab cl ks kt gp ku" role="separator"><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx"/></div><div class="hb hc hd he hf"><h1 id="25e2" class="jp jq hi bd jr js mk ju jv jw ml jy jz ka mm kc kd ke mn kg kh ki mo kk kl km bi translated">包扎</h1><p id="be6f" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">我希望您在阅读这篇文章时感到愉快，并对现代JavaScript的这一惊人特性有所了解。如果你有兴趣了解更多，有一个<a class="ae mj" href="https://gist.github.com/mikaelbr/9900818" rel="noopener ugc nofollow" target="_blank"> <strong class="is ln">要点</strong> </a>充满了这些例子，作者是<a class="mp mq ge" href="https://medium.com/u/d2e9832e3bd5?source=post_page-----92c6767646bc--------------------------------" rel="noopener" target="_blank"> Mikael Brevik </a>，如果你有任何问题，请在下面的评论中告诉我。</p></div></div>    
</body>
</html>