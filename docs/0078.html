<html>
<head>
<title>Software Development Principles</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">软件开发原则</h1>
<blockquote>原文：<a href="https://medium.com/swlh/software-development-principles-9af2563d16d6?source=collection_archive---------19-----------------------#2019-01-04">https://medium.com/swlh/software-development-principles-9af2563d16d6?source=collection_archive---------19-----------------------#2019-01-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="0117" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每当我着手一个项目时，我总是喜欢定义一套基本的指导原则。随着项目的发展，这些原则可以并且应该经常被重新审视，以确保最初愿景的基本原则不会丢失。</p><p id="61ba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面的原则是基本的分块和处理，有助于加强软件组件或系统的结构。不幸的是，有很多很多的项目在没有正确执行基本原则的情况下进行。如果你没有一套软件的核心原则，这些应该是一个很好的起点。</p><h1 id="c722" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated"><strong class="ak">单独关注</strong></h1><p id="1ce5" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">任何一个组件都不应该“做得太多”。始终注意将大组件重构为小组件的机会。这样做将增强模块化，并为重用提供新的机会。</p><p id="2824" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih kh">为什么？<br/> </strong>灵活性！通过将软件组件化，无论是在代码级别还是网络服务级别，都可以更容易地重构体系结构，以适应不断变化的需求。</p><h1 id="ef7f" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated"><strong class="ak">使用网络分离组件</strong></h1><p id="d0bf" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">SOA和微服务架构风格都是关于将大型流程分解成较小的流程，并使用网络基础设施将它们连接在一起。使用网络分割组件通常会增加灵活性、可靠性和可扩展性。</p><p id="faaf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih kh">为什么？<br/> </strong>该原则旨在将架构推向组件的网络分段，而不是在单个进程空间中运行组件。一般来说，在网络中分布应用程序组件增加了弹性，因为计算节点会出现故障，但集群是永久的。虽然网络分段设计会增加成本，通常是在性能和复杂性方面，但分布式应用程序增加的弹性通常是值得投资的。</p><h1 id="63a2" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">不要在本地保存状态</h1><p id="3443" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">维护流程中的状态通常会将交互绑定到该特定流程。这使得该流程很特别，当该流程失败时，就像流程一样，整个会话或工作流可能会中断。</p><p id="d00b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih kh">为什么？<br/> </strong>这一原则再次指导我们的设计减少对单个计算节点的依赖。应用程序状态应该存在于集群中，并且在可行的情况下应该保存在共享磁盘上。这进一步增加了应用程序的弹性，甚至在灯熄灭的时候！</p><h1 id="7a27" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">异步通信</h1><p id="1ed8" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">基于消息和事件驱动的系统通常具有高度的可伸缩性和健壮性。在长时间运行的事务中，同步通信会消耗资源，导致接口阻塞和无响应。同步通信还会创建脆弱的系统，这些系统往往无法承受部分故障。</p><p id="6e77" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih kh">为什么？<br/> </strong>流程运行的时间越长，越有可能失败。如果组件A调用组件B，而组件B又调用组件C，那么您需要等待C完成。如果A不一定需要等待C完成，你就占用了资源，增加了失败的几率。如果A不是绝对需要等待B或C(这是经常发生的情况)，那么让A一调用B就完成，同步通信应该是例外而不是规则！</p><h1 id="7e4e" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">安全第一</h1><p id="457a" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">保护分布式系统是困难的，尤其是当安全性没有融入核心体系结构时。尽早建立安全的设计模式，并重用这些模式来确保组件始终安全。</p><p id="610c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih kh">为什么？因为你永远不能相信任何人或任何事。不幸的是，人性使然，当你的软件发布时，总会有人试图破坏它。每一行代码都是一个潜在的漏洞，只有系统化的安全性才能给你一个保护客户安全的机会。你应该总是想办法黑掉你的软件，因为你可以肯定别人也在黑你！</strong></p><h1 id="57be" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">总是记录一切</h1><p id="47c4" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">分布式系统很复杂，如果没有足够的信息和背景，故障排除是不可能的。所有组件都应该允许轻松启用详细的跟踪日志记录，并将其发送到集中的日志服务。</p><p id="55ad" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih kh">为什么？<br/> </strong>因为我们都在故障排除方面花了足够多的时间，知道在受控环境中重现问题通常是不可能的。生产中的质量记录为故障排除人员提供了一些非常需要的信息，以帮助诊断或至少隔离问题产生的时间、地点和方式。记录再多也不为过，但是在故障排除过程中，更多的记录几乎总是有帮助的。</p><h1 id="0d2e" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">优雅地失败</h1><p id="07d9" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">承诺花时间处理、记录和响应错误情况。用户和操作人员的体验对成功的产品至关重要。</p><p id="9783" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih kh">为什么？<br/> </strong>软件自然有比成功条件更多的失败模式。应用程序中的每一个进程都在走钢丝，通常结果是最好的，但往往不是。考虑和处理故障模式与成功的逻辑一样重要。未处理的异常是严重的错误，它会扰乱最终用户的体验，并对应用程序的感知造成严重影响。对你的客户来说，一个讨厌的bug往往比一千个伟大的特性更有意义。</p><h1 id="7234" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">自我描述</h1><p id="20be" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">所有接口都应该是自文档化的。明智地使用文档生成工具，如Swagger、JavaDoc、JSDoc等。应该在项目开始时就准备好。</p><p id="902e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih kh">为什么？<br/> </strong>把一个Word文档和半成品的过期API文档交给别人是完全不能接受的。如果你有一个你希望其他人使用的API，特别是你的直接团队之外的人，它需要是自文档化的。只有你认为你的API是直观的，其他人都需要说明！</p><h1 id="2c38" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">首先尝试无服务器</h1><p id="80f1" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">服务器是一种负担和责任。除非绝对不能，否则您应该始终通过利用托管云服务来消除服务器。如果你不能无服务器，那就容器化。如果你不能容器化，使用虚拟机。如果你不能使用虚拟机，你真的需要在安装服务器之前好好想想。</p><p id="9e03" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih kh">为什么？<br/> </strong>因为操作服务器很难，你会失败。您的代码足够复杂，无需增加操作系统的复杂性即可支持。将这种负担完全委托给其他人，并构建您的应用程序来适应并生存在一个远高于服务器和操作系统的虚拟空间中。</p><h1 id="c775" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">从代码构建基础设施</h1><p id="2fae" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">所有基础设施供应和配置都应使用代码。永远不要手工构建任何东西，总是编写代码。</p><p id="0f99" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih kh">为什么？手工制作东西可能很有趣，也会让个人感到满意，但这绝不是扩大业务规模的方法。您的基础设施应该编写成代码，这将允许它被一致地供应、取消供应、重新供应和修改。它还将允许除您之外的其他人轻松理解和管理基础架构。</strong></p><h1 id="bfe4" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">你的经历可能不一样</h1><p id="4e66" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">你可能已经注意到上面的原则已经用“经常”和“一般”这样的词修饰过了。这是因为，当然，不是每个规则都适用于每个场景。其实这些都不是规则，是指导原则。当情况需要时，可以随意忽略它们，但至少应该考虑它们，并且忽略的决定应该是经过深思熟虑的。</p><figure class="kj kk kl km fd kn er es paragraph-image"><div class="er es ki"><img src="../Images/b7f9681135840115196a814d8264accb.png" data-original-src="https://miro.medium.com/v2/resize:fit:730/format:webp/1*4bzwE0rB81aDcaNSyRlOww.jpeg"/></div></figure></div></div>    
</body>
</html>