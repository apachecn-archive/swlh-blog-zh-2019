<html>
<head>
<title>Understanding Component Lifecycle in ReactJS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解ReactJS中的组件生命周期</h1>
<blockquote>原文：<a href="https://medium.com/swlh/understanding-component-lifecycle-in-reactjs-ed35d76dab2e?source=collection_archive---------5-----------------------#2019-06-15">https://medium.com/swlh/understanding-component-lifecycle-in-reactjs-ed35d76dab2e?source=collection_archive---------5-----------------------#2019-06-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/faced30ea3ad85c3cc1156f828c2661f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ej01y7K8vueJG1O9m__k1w.jpeg"/></div></div></figure><div class=""/><p id="dce5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您在React应用程序中看到的一切都是组件或组件的一部分。在React中，组件被设计成遵循生命的自然循环。他们出生(创造)，成长(更新)，最后死亡(删除)。这被称为<strong class="is jo">组件生命周期</strong>。</p><p id="ef10" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于组件生命周期的每个阶段，React提供对某些内置事件/方法的访问，这些事件/方法被称为<strong class="is jo">生命周期挂钩</strong>或<strong class="is jo">生命周期方法</strong>。这些方法使您有机会控制和操作组件如何对应用程序中的变化做出反应。</p><p id="9bd1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们来看看组件生命周期中的每个阶段:</p><h2 id="4894" class="jp jq ht bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj bi translated">预安装(初始化)</h2><p id="18f8" class="pw-post-body-paragraph iq ir ht is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hb bi translated">组件是一个JS类。像任何类一样，它有一个<code class="du kp kq kr ks b">constructor</code>函数，调用它来设置东西。它通常设置状态和道具。</p><h2 id="499d" class="jp jq ht bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj bi translated">增加</h2><p id="d4fb" class="pw-post-body-paragraph iq ir ht is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hb bi translated">初始化完成后，组件的一个实例被创建并挂载到DOM上。使用其初始状态，组件第一次呈现在页面上。在这个阶段，我们有两种可用的生命周期方法:<code class="du kp kq kr ks b">componentWillMount</code>和<code class="du kp kq kr ks b">componentDidMount</code>。</p><p id="6e42" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在<code class="du kp kq kr ks b">constructor</code>被调用之后，<code class="du kp kq kr ks b">componentWillMount</code>在 <code class="du kp kq kr ks b">render</code>之前被调用，并且在一个生命周期中被调用一次。这种方法用得不多——甚至<a class="ae ku" href="https://reactjs.org/docs/react-component.html#componentwillmount" rel="noopener ugc nofollow" target="_blank">的React文档</a>提到你在这里可以做的任何事情都最好用<code class="du kp kq kr ks b">constructor</code>或<code class="du kp kq kr ks b">componentDidMount</code>方法来完成。</p><p id="d972" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果您试图在这个方法中使用<code class="du kp kq kr ks b">this.setState</code>进行任何API调用或数据更改，DOM中不会发生任何事情(没有更新),因为在render方法之前调用了<code class="du kp kq kr ks b">componentWillMount</code>。</p><p id="c905" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du kp kq kr ks b">componentDidMount</code>是在之后被称为<em class="kt">的<code class="du kp kq kr ks b">render</code>方法。和<code class="du kp kq kr ks b">componentWillMount</code>一样，一个生命周期调用一次。因为render方法已经被调用，所以我们可以访问DOM。您可以使用该方法来设置任何长期运行的流程或异步流程，例如获取和更新数据。</em></p><h2 id="93bd" class="jp jq ht bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj bi translated">更新</h2><p id="4928" class="pw-post-body-paragraph iq ir ht is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hb bi translated">每当组件的状态和属性从React组件内部或通过api或后端发生变化时，组件就会通过在页面上重新呈现来更新。状态和属性的变化取决于用户与组件的交互或者是否有新数据传入。</p><p id="3d63" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">此阶段可用的生命周期方法有:</p><p id="dff2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">1.<code class="du kp kq kr ks b">componentWillReceiveProps</code>:当父元素传递给组件的属性发生变化时，这个方法被调用。</p><p id="9453" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">2.<code class="du kp kq kr ks b">shouldComponentUpdate</code>:这个方法在组件将要重新呈现之前被调用。它决定组件是否应该更新。默认情况下，它返回true。你可以通过使用<code class="du kp kq kr ks b">nextProps</code>和<code class="du kp kq kr ks b">nextState</code>参数来比较新旧道具和状态，如果道具和/或状态的变化不影响显示给用户的内容，可以避免不必要的重新渲染。</p><p id="ab4d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">3.<code class="du kp kq kr ks b">componentWillUpdate</code>:这个方法在<code class="du kp kq kr ks b">shouldComponentUpdate</code>完成之后，新组件渲染之前被调用。使用此方法的一些示例包括:如果您在重新渲染之前以及在道具和/或状态更新之后需要执行任何计算，或者如果您需要更新与第三方库的集成。像<code class="du kp kq kr ks b">shouldComponentUpdate</code>一样，它也接收像<code class="du kp kq kr ks b">nextProps</code>和<code class="du kp kq kr ks b">nextState</code>这样的参数。</p><p id="39e7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">4.<code class="du kp kq kr ks b">componentDidUpdate</code>:这个方法在组件重新渲染后被调用。您将可以使用<code class="du kp kq kr ks b">prevProp</code>和<code class="du kp kq kr ks b">prevState</code>访问以前的属性和状态，以及当前的属性和状态，并且您可以使用此方法更新任何第三方库，如果它们由于重新渲染而需要更新的话。</p><h2 id="4dd0" class="jp jq ht bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj bi translated">卸载</h2><p id="801d" class="pw-post-body-paragraph iq ir ht is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hb bi translated">这是组件生命周期的最后一个阶段。在卸载阶段，组件将从页面中删除。这个阶段唯一的生命周期方法是<code class="du kp kq kr ks b">componentWillUnmount</code>，它在组件被删除之前被调用。用于清除在<code class="du kp kq kr ks b">componentDidMount</code>中设置的任何内容。例如，删除<code class="du kp kq kr ks b">componentDidMount</code>中定义的任何定时器。</p><h2 id="76e2" class="jp jq ht bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj bi translated">贬低生命周期挂钩</h2><p id="b192" class="pw-post-body-paragraph iq ir ht is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hb bi translated">React团队已经决定在React 17中弃用一些生命周期方法。ReactJS团队最近的一篇博客文章揭示了组件生命周期方法的未来。</p><p id="9a40" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">三种生命周期方法<code class="du kp kq kr ks b">componentWillMount</code>、<code class="du kp kq kr ks b">componentWillRecieveProps</code>、<code class="du kp kq kr ks b">componentWillUpdate</code>即将被弃用。然而，它们并没有完全消失，因为你可以将它们与<code class="du kp kq kr ks b">UNSAFE_componentWillMount</code>、<code class="du kp kq kr ks b">UNSAFE_componentWillRecieveProps</code>、<code class="du kp kq kr ks b">UNSAFE_componentWillUpdate</code>一起使用。</p><p id="e4aa" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is jo">它们为什么不安全？</strong></p><p id="921f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最初的生命周期模型并不打算用于即将到来的一些特性，比如异步呈现。随着异步渲染的引入，这些生命周期方法中的一些在使用时会变得不安全。</p><p id="d820" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">例如，异步渲染会导致<code class="du kp kq kr ks b">componentWillMount</code>触发组件树的多重渲染。这使得它不安全。</p><h2 id="af94" class="jp jq ht bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj bi translated">摘要</h2><p id="7f0f" class="pw-post-body-paragraph iq ir ht is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hb bi translated">了解组件的生命周期将使您能够在创建、更新或销毁组件时执行某些操作。不是每个方法都需要在你构建的每个组件中使用。使用它们的好处是有机会首先决定组件是否应该更新，并相应地对props或状态变化做出反应。</p><p id="2259" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">感谢阅读！</p><h2 id="2b87" class="jp jq ht bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj bi translated">参考</h2><div class="hh hi ez fb hj kv"><a href="https://reactjs.org/docs/react-component.html" rel="noopener  ugc nofollow" target="_blank"><div class="kw ab dw"><div class="kx ab ky cl cj kz"><h2 class="hu b fi z dy la ea eb lb ed ef hs bi translated">做出反应。成分-反应</h2><div class="lc l"><h3 class="bd b fi z dy la ea eb lb ed ef dx translated">该页面包含React组件类定义的详细API参考。它假设您熟悉…</h3></div><div class="ld l"><p class="bd b fp z dy la ea eb lb ed ef dx translated">reactjs.org</p></div></div><div class="le l"><div class="lf l lg lh li le lj hp kv"/></div></div></a></div><div class="hh hi ez fb hj kv"><a href="https://www.freecodecamp.org/news/how-to-understand-a-components-lifecycle-methods-in-reactjs-e1a609840630/" rel="noopener  ugc nofollow" target="_blank"><div class="kw ab dw"><div class="kx ab ky cl cj kz"><h2 class="hu b fi z dy la ea eb lb ed ef hs bi translated">如何理解ReactJS中组件的生命周期方法</h2><div class="lc l"><h3 class="bd b fi z dy la ea eb lb ed ef dx translated">在本文中，我们将探讨ReactJS的生命周期方法。但是，在做出反应之前…</h3></div><div class="ld l"><p class="bd b fp z dy la ea eb lb ed ef dx translated">www.freecodecamp.org</p></div></div><div class="le l"><div class="lk l lg lh li le lj hp kv"/></div></div></a></div><div class="hh hi ez fb hj kv"><a href="https://busypeoples.github.io/post/react-component-lifecycle/" rel="noopener  ugc nofollow" target="_blank"><div class="kw ab dw"><div class="kx ab ky cl cj kz"><h2 class="hu b fi z dy la ea eb lb ed ef hs bi translated">了解React组件生命周期</h2><div class="lc l"><h3 class="bd b fi z dy la ea eb lb ed ef dx translated">了解组件的生命周期将使您能够在创建组件时执行某些操作，或者…</h3></div><div class="ld l"><p class="bd b fp z dy la ea eb lb ed ef dx translated">忙人. github.io</p></div></div></div></a></div><div class="hh hi ez fb hj kv"><a rel="noopener follow" target="_blank" href="/front-end-weekly/how-to-use-react-lifecycle-methods-103fc3b1711"><div class="kw ab dw"><div class="kx ab ky cl cj kz"><h2 class="hu b fi z dy la ea eb lb ed ef hs bi translated">如何使用React生命周期方法</h2><div class="lc l"><h3 class="bd b fi z dy la ea eb lb ed ef dx translated">React附带了几个生命周期方法，如果您不知道哪一个适合您的场景，它会变得很混乱…</h3></div><div class="ld l"><p class="bd b fp z dy la ea eb lb ed ef dx translated">medium.com</p></div></div><div class="le l"><div class="ll l lg lh li le lj hp kv"/></div></div></a></div></div></div>    
</body>
</html>