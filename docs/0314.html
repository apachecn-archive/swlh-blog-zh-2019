<html>
<head>
<title>How to answer Data Science Interview Coding Questions?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何回答数据科学面试编码问题？</h1>
<blockquote>原文：<a href="https://medium.com/swlh/how-to-answer-data-science-interview-coding-questions-b5e6b2335c7e?source=collection_archive---------2-----------------------#2019-01-17">https://medium.com/swlh/how-to-answer-data-science-interview-coding-questions-b5e6b2335c7e?source=collection_archive---------2-----------------------#2019-01-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="25c0" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">LinkedIn上目前有超过1829个开放的机器学习工程职位。</h2></div><p id="3ac4" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">看看过去几年雇用数据科学家的趋势，越来越明显的是，数据科学家不仅分析数据和建立模型，而且他们还编程以大规模部署算法。数据工程是数据科学家日常生活的一个重要方面。作为一名数据科学家，今天每个人都在寻找涉及相当多编码的机器学习专业知识。在<a class="ae jt" href="https://medium.com/acing-ai" rel="noopener">担任AI </a>时，我一直在努力帮助数据科学家进入数据科学角色。如今，所有招聘这个职位的科技公司通常都会从编码测试开始。本文旨在提供一种方法来回答数据科学面试或编码测试中提出的编码问题。</p><p id="8e22" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">面试官提出了一个问题，想看看你是如何解决的。解决问题的能力也在这里受到考验。受访者寻找问题解决方案的方法与解决方案本身一样重要。因此，直接跳到最佳解决方案可能不是最好的方法。让我们通过一步一步的解决方案来理解回答编码问题的方法。下面的问题以前在许多数据科学编码访谈中被问过。</p><figure class="jv jw jx jy fd jz er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es ju"><img src="../Images/558686e211f5738b06a35c236842316b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ri49w8TcHeXrnmO5dD4_aQ.jpeg"/></div></div><figcaption class="kg kh et er es ki kj bd b be z dx">Photo by <a class="ae jt" href="https://unsplash.com/photos/mDinBvq1Sfg?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Adi Goldstein</a> on <a class="ae jt" href="https://unsplash.com/search/photos/code?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="e46c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz kk"> <em class="kl">给定一个整数数组，返回两个数的索引，使它们加起来达到一个特定的目标。</em> </strong></p><p id="3219" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你可以假设每个输入只有一个解，你不能两次使用同一个元素。T9】</p><p id="c92c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">例如:给定nums = [2，7，11，15]，target = 18，</p><p id="587f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">nums[1] + nums[2] = 7+ 11= 18，return [1，2]。</p><p id="0431" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">回答编码问题的一个好方法是从一个强力解决方案开始，它给出了一个非优化的性能。在面试过程中，面试官希望受访者通过思考其他解决方案来优化解决方案。</p><p id="b6be" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们采取同样的方法来寻找解决办法。</p><p id="2307" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz kk">暴力破解方法:</strong></p><p id="6e04" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">强力方法是有两个For循环。第一个For循环是从数组的第一个元素循环到最后一个元素，而第二个For循环是从数组的第二个元素循环到最后一个元素。然后我们试着从目标中减去这些元素来找到它们。</p><pre class="jv jw jx jy fd km kn ko kp aw kq bi"><span id="96f8" class="kr ks hi kn b fi kt ku l kv kw">public int[] twoSumBruteForce(int[] numbers, int target) {<br/>   for (int i = 0; i &lt; numbers.length; i++) {<br/>     for (int j = i + 1; j &lt; numbers.length; j++) {<br/>        if (numbers[j] == target — numbers[i]) {<br/>           return new int[] { i, j };<br/>        }<br/>     }<br/>   }<br/>}</span></pre><p id="061c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">复杂性分析</p><ul class=""><li id="d8ec" class="kx ky hi iz b ja jb jd je jg kz jk la jo lb js lc ld le lf bi translated">时间复杂度:O(n)。对于每个元素，我们试图通过遍历数组的其余部分来找到它的补码，这需要O(n)时间。因此，时间复杂度为O(n)。</li><li id="b7f6" class="kx ky hi iz b ja lg jd lh jg li jk lj jo lk js lc ld le lf bi translated">空间复杂度:O(1)。</li></ul><p id="266f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz kk">优化:</strong></p><p id="5288" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们的时间复杂度需要改进。在这种情况下，时间复杂度很低，因为我们遍历了两次循环。此时，我们应该考虑减少元素查找的数据结构。让我们考虑使用散列表作为在散列表O(1)中查找大部分元素的时间。如果有冲突，查找时间将达到O(n ),但是只要仔细选择散列函数，对散列表的查找应该分摊到O(1)时间。</p><p id="5674" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用哈希表的一种方法是将元素存储到由数组索引索引的哈希表<strong class="iz kk">中。然后使用For循环，我们可以查找每个元素的补码(目标<code class="du ll lm ln kn b">-</code>元素值)是否存在。这将是O(n ),因为我们遍历元素两次，第一次是在将它们添加到表中时，第二次是在获取补数时。这将需要两遍。让我们进一步优化只有一个通道。我们可以迭代并将元素插入到表中，同时还可以回过头来检查当前元素的补码是否已经存在于表中。如果存在，我们返回值。</strong></p><pre class="jv jw jx jy fd km kn ko kp aw kq bi"><span id="dacc" class="kr ks hi kn b fi kt ku l kv kw">public int[] twoSum(int[] numbers, int target) {<br/>     Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();<br/>        for (int i = 0; i &lt; numbers.length; i++) {<br/>            int complement = target — numbers[i];<br/>        if (map.containsKey(complement)) {<br/>            return new int[] { map.get(complement), i };<br/>         }<br/>     map.put(numbers[i], i);<br/>   }<br/>}</span></pre><p id="c802" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">复杂性分析:</p><ul class=""><li id="6cf1" class="kx ky hi iz b ja jb jd je jg kz jk la jo lb js lc ld le lf bi translated">时间复杂度:O(n)。我们只遍历包含n个元素的列表一次。表格中的每次查找仅花费O(1)时间。</li><li id="1859" class="kx ky hi iz b ja lg jd lh jg li jk lj jo lk js lc ld le lf bi translated">空间复杂度:O(n)。所需的额外空间取决于哈希表中存储的项目数量，哈希表最多存储n个元素。</li></ul><p id="d632" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">从这个例子中，我们看到我们将时间复杂度从O(n)交换到O(n ),将空间复杂度从O(1)增加到O(n)。对于在数据上执行的任何算法，必须考虑这样的折衷。在数据科学领域，完全由构建模型的人来优化GPU和时间。GPU具有与之相关的成本价值。因此，重要的是要有一个最佳的时间成本比。在大多数情况下，时间总是优化的，但也有一些情况下，我们不能拥有无限的GPU，或者添加更多的GPU不会大幅减少时间。一个谨慎的数据科学家总是会看到什么是可用的，并在时间和成本之间进行权衡。</p><p id="aaef" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="kl">感谢阅读！</em>😊<em class="kl">如果你喜欢，测试一下你能打多少次</em>👏<em class="kl">再过5秒。这对你的手指来说是很好的有氧运动，并且会帮助其他人看到这个故事。</em></p><div class="lo lp ez fb lq lr"><a href="https://medium.com/acing-ai" rel="noopener follow" target="_blank"><div class="ls ab dw"><div class="lt ab lu cl cj lv"><h2 class="hj b fi z dy lw ea eb lx ed ef hh bi translated">阿信艾</h2><div class="ly l"><h3 class="bd b fi z dy lw ea eb lx ed ef dx translated">《人工智能》提供人工智能公司的分析以及进入这些公司的途径。</h3></div><div class="lz l"><p class="bd b fp z dy lw ea eb lx ed ef dx translated">medium.com</p></div></div><div class="ma l"><div class="mb l mc md me ma mf ke lr"/></div></div></a></div><p id="7d3e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="kl">这篇博客文章的唯一动机是为一些数据科学面试问题提供答案。我的目标是使这成为一个活的文档，所以任何更新和建议的变化都可以被包括在内。请提供相关反馈。</em></p><figure class="jv jw jx jy fd jz er es paragraph-image"><a href="https://medium.com/swlh"><div class="er es mg"><img src="../Images/308a8d84fb9b2fab43d66c117fcc4bb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YqDjlKFwScoQYQ62DWEdig.png"/></div></a></figure><h2 id="c148" class="kr ks hi bd mh mi mj mk ml mm mn mo mp jg mq mr ms jk mt mu mv jo mw mx my mz bi translated">这篇文章发表在<a class="ae jt" href="https://medium.com/swlh" rel="noopener"> The Startup </a>上，这是Medium最大的创业刊物，拥有+412，714名读者。</h2><h2 id="869c" class="kr ks hi bd mh mi mj mk ml mm mn mo mp jg mq mr ms jk mt mu mv jo mw mx my mz bi translated">在这里订阅接收<a class="ae jt" href="http://growthsupply.com/the-startup-newsletter/" rel="noopener ugc nofollow" target="_blank">我们的头条新闻</a>。</h2><figure class="jv jw jx jy fd jz er es paragraph-image"><a href="https://medium.com/swlh"><div class="er es mg"><img src="../Images/b0164736ea17a63403e660de5dedf91a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ouK9XR4xuNWtCes-TIUNAw.png"/></div></a></figure></div></div>    
</body>
</html>