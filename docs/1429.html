<html>
<head>
<title>Navigate the deepest parts of JavaScript- Closures [2/10]</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">浏览JavaScript的最深处——闭包[2/10]</h1>
<blockquote>原文：<a href="https://medium.com/swlh/navigate-the-deepest-parts-of-javascript-closures-2-10-b7deac267d1?source=collection_archive---------16-----------------------#2019-03-05">https://medium.com/swlh/navigate-the-deepest-parts-of-javascript-closures-2-10-b7deac267d1?source=collection_archive---------16-----------------------#2019-03-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/0b430656521bf7d1eb77dcac59dc9a34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bMsPa7dxk67vw25KplVf9A.jpeg"/></div></div></figure><p id="4698" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是一个关于中级JavaScript主题的连续系列。如果你还没有看过我的第一篇博客，请回头看看之前的文章(这也恰好是第一篇！)</p><div class="jo jp ez fb jq jr"><a rel="noopener follow" target="_blank" href="/swlh/navigate-the-deepest-parts-of-javascript-closures-1-10-a4214680b6f5"><div class="js ab dw"><div class="jt ab ju cl cj jv"><h2 class="hj b fi z dy jw ea eb jx ed ef hh bi translated">浏览JavaScript的最深处——闭包[1/10]</h2><div class="jy l"><h3 class="bd b fi z dy jw ea eb jx ed ef dx translated">作为初学者，我是如何破解困难的JS概念的。</h3></div><div class="jz l"><p class="bd b fp z dy jw ea eb jx ed ef dx translated">medium.com</p></div></div><div class="ka l"><div class="kb l kc kd ke ka kf io jr"/></div></div></a></div><p id="7518" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，关于JavaScript闭包，您已经有了非常需要的闭包。你知道他们如何在引擎盖下工作；以及它们在现实世界中是如何使用的。闭包的概念很简单，但是你需要很好的理解它。尽管语法上很简单，但是对闭包的理解不足已经导致了举世闻名的内存泄漏。(我将在接下来的几周内写下相关内容！)所以我们再深入一下。是时候深入挖掘并了解一些最常见的奇怪行为了，这些行为是由对闭包的不正确理解引起的。仔细听着。</p><figure class="kh ki kj kk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kg"><img src="../Images/20a5f32b678afe79ce11abeb7110230c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o_dAmNs2tj6dTMEx7swDPQ.jpeg"/></div></div></figure><p id="1485" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，让我们看几个来自闭包的奇怪行为的例子，然后我们将深入了解它的本质，然后看看如何使用闭包在JavaScript中创建一个设计模式。</p><p id="dde1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">见后面的著名面试问题。</p><figure class="kh ki kj kk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kl"><img src="../Images/d9b21ee6ad8aa6510eabcf20439d92a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bIeVUtVA0hXDTdhOS7Tbmg.png"/></div></div></figure><p id="8fc0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">仔细看，有内在作用，也有外在作用；内部函数是setTimeout，外部函数是countTime。变量I在闭包作用域内是因为即使函数countTime已经停止运行，setTimeout函数仍然可以访问I，所以我们来问一个问题；上面的代码产生了什么？</p><p id="1b57" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你知道如果答案是1，2，3，这个问题会看起来很蠢。写它的人显然需要打印1，2，3，但它不会。</p><p id="d377" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">那么输出会是什么呢？</p><p id="8ba8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你盯着控制台看，程序会吐出“4”而不是别的。搞什么鬼？</p><p id="f3d5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们言归正传。为此，您需要对事件循环如何工作有一个基本的了解。如果你需要快速复习，我会给你一个。</p><p id="2801" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">JavaScript是一种单线程、事件驱动的非阻塞语言。</p><p id="2b09" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是你每天都会听到的。</p><h2 id="411a" class="km kn hi bd ko kp kq kr ks kt ku kv kw jb kx ky kz jf la lb lc jj ld le lf lg bi translated">出于各种原因，它的设计是为了避免竞态条件。非原子内存访问等等。这并不意味着它只有一根线。</h2><p id="499e" class="pw-post-body-paragraph iq ir hi is b it lh iv iw ix li iz ja jb lj jd je jf lk jh ji jj ll jl jm jn hb bi translated">1.主线程处理你的代码——获取它，编译它并执行它。<br/> 2。实际上有一个单独的线程用于编译；以便我们的主线程可以继续执行。<br/> 3。有一个分析器线程，用于确定执行线程在哪些方法上花费更多时间，以便优化编译器可以优化它。<br/> 4。还有一些其他线程用于垃圾清理。<br/> 5。如果你在node.js上，那么我们有其他的webAPIS线程，它们与底层的C++对应线程对话。</p><p id="3132" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">单线程意味着它只有一个线程处理请求。JS引擎主要有以下组件。</p><p id="2145" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">1.<strong class="is lm">调用堆栈；</strong>其中要执行的指令被推到堆栈顶部并执行；然后就爆了。这是执行指令的唯一地方。</p><p id="3f93" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">2.<strong class="is lm">事件队列:</strong>这是一个中间地带，回调在这里等待被执行。它可以是数据库查询或异步API调用。回调本质上做的是，它为事件注册一个处理程序；或者功能；并告诉事件循环。“当您的数据库查询执行完毕时调用此函数”或“当您的API调用返回数据时执行此函数”。首先，需要将它们推入堆栈。让这一切发生。堆栈应该是空的。所以JS运行时，简单来说就是在迭代中完成这个任务。这个所谓的“<strong class="is lm"> <em class="ln">事件循环</em> </strong>”周期性地检查调用栈是否为空，如果是，它将把第一个事件推送到调用栈。这种迭代称为“滴答”。</p><blockquote class="lo lp lq"><p id="211c" class="iq ir ln is b it iu iv iw ix iy iz ja lr jc jd je ls jg jh ji lt jk jl jm jn hb bi translated">就像我说的，基本上它是所有等待执行的事情的中间状态。</p></blockquote><figure class="kh ki kj kk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lu"><img src="../Images/abfda18453b6a7445818fa2ed16095bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f5TtEIHBh-4RfhE0FpRuNg.jpeg"/></div></div></figure><p id="0f5c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">3.堆:这是非结构化的内存，对象和其他值都存储在内存中。这主要是垃圾收集器收集垃圾的地方。</p><h2 id="8659" class="km kn hi bd ko kp kq kr ks kt ku kv kw jb kx ky kz jf la lb lc jj ld le lf lg bi translated">调用方与响应的解耦，就像在事件循环中发生的那样，允许JS运行时做其他比等待更好的事情。</h2><p id="6ab0" class="pw-post-body-paragraph iq ir hi is b it lh iv iw ix li iz ja jb lj jd je jf lk jh ji jj ll jl jm jn hb bi translated">for循环运行三次，并且在每次迭代后增加I的值。然后，它将打印命令发送到事件队列，在第四次尝试时，I的值变为4，循环中断执行。</p><h2 id="1323" class="km kn hi bd ko kp kq kr ks kt ku kv kw jb kx ky kz jf la lb lc jj ld le lf lg bi translated">让我们来分解一下:</h2><p id="939a" class="pw-post-body-paragraph iq ir hi is b it lh iv iw ix li iz ja jb lj jd je jf lk jh ji jj ll jl jm jn hb bi translated">1.调用countTime函数。<br/> 2。countTime函数被推到调用堆栈的顶部。<br/> 3。For循环开始执行。<br/> 4。对于I的每次迭代，<br/> 1。调用SetTimeout方法，该方法被推入栈顶。<br/> 2。setTimeout中的控制台命令被发送到事件队列，以供事件循环选取。<br/> 3。事件循环保存控制台命令，直到调用堆栈被清除。<br/> 5。I的值变为4，并且for循环中断。<br/> 6。从堆栈中弹出for循环。<br/> 7。countTime函数存在；并从堆栈中弹出。<br/> 8。事件循环检查调用堆栈，发现它是空的。9。Even loop将第一个console.log(i)命令推入堆栈帧。<br/> 10。变量I只不过是对我存储在堆中某处的原始内存位置的引用。11。is的当前值为for循环中断时)<br/> 12。它只打印4次，并打印3次，考虑到每个console.log。</p><p id="355d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">那么我们如何解决这个问题呢？</p><p id="4211" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们看看。</p><figure class="kh ki kj kk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lv"><img src="../Images/fb2ba78e075f75d7019e5eebdd8566e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jf67bBUTQgbUDkt2dWjcmQ.png"/></div></div></figure><p id="4bf3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，我们所做的是，我们已经将内部setTimeout函数包装在所谓的立即调用函数表达式中，我们将隆重地称之为IEFE。所以我们现在在函数中有了一个函数。</p><p id="f4d2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有什么变化？</p><p id="def9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在for循环内调用函数3次时，在每次迭代开始时；I的当前值被赋给一个名为currentTime的局部变量。每当循环通过一次迭代，IEFE就会被调用，3个console.log语句以及范围从1到3的3个currentTime(局部变量)值被发送到事件循环。当堆栈变空时，三条语句被打印出来；解决我们的问题。</p><h2 id="8bc7" class="km kn hi bd ko kp kq kr ks kt ku kv kw jb kx ky kz jf la lb lc jj ld le lf lg bi translated">我们所需要的是函数中的函数，创建一个闭包作用域。</h2><figure class="kh ki kj kk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lu"><img src="../Images/0cf90d304a751f39c639ffee6807258a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v8CSwSg0T7A0AY0yz3fG5g.jpeg"/></div></div></figure><p id="a5f7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你真的浏览其他人的代码，你可以看到上述代码的变体。</p><figure class="kh ki kj kk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lw"><img src="../Images/4037e7f3486d9da8aaba6762a9394b06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I4UQy7SdrODwn9YC0ypKkQ.png"/></div></div></figure><blockquote class="lo lp lq"><p id="6e3c" class="iq ir ln is b it iu iv iw ix iy iz ja lr jc jd je ls jg jh ji lt jk jl jm jn hb bi translated">在上面的例子中，IEFE通过变量currentTime记住每次迭代中I的每个值，该变量在每次循环中被传递到函数的执行上下文中。</p></blockquote><p id="a6e5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们甚至不必使用不同的变量名，如I和currentTime。我们可以用一个变量I来实现，代码如下。</p><figure class="kh ki kj kk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lw"><img src="../Images/8e06abe84213a986f9dd5cc6f620a968.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DFOSJFk1H-J0V1MhFL8F8w.png"/></div></div></figure><p id="b928" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">哒哒！！我希望你喜欢这篇文章。在接下来的几周里，我会写更多关于JS的东西。感谢阅读。</p><figure class="kh ki kj kk fd ij er es paragraph-image"><a href="https://medium.com/swlh"><div class="er es lx"><img src="../Images/308a8d84fb9b2fab43d66c117fcc4bb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YqDjlKFwScoQYQ62DWEdig.png"/></div></a></figure><h2 id="c148" class="km kn hi bd ko kp kq kr ks kt ku kv kw jb kx ky kz jf la lb lc jj ld le lf lg bi translated">这篇文章发表在<a class="ae ly" href="https://medium.com/swlh" rel="noopener"> The Startup </a>上，这是Medium最大的创业刊物，有+431，678人关注。</h2><h2 id="869c" class="km kn hi bd ko kp kq kr ks kt ku kv kw jb kx ky kz jf la lb lc jj ld le lf lg bi translated">订阅接收<a class="ae ly" href="https://growthsupply.com/the-startup-newsletter/" rel="noopener ugc nofollow" target="_blank">我们的头条</a>。</h2><figure class="kh ki kj kk fd ij er es paragraph-image"><a href="https://medium.com/swlh"><div class="er es lx"><img src="../Images/b0164736ea17a63403e660de5dedf91a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ouK9XR4xuNWtCes-TIUNAw.png"/></div></a></figure></div></div>    
</body>
</html>