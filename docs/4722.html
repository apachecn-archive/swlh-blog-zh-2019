<html>
<head>
<title>Context and memory leaks in Android</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android中的上下文和内存泄漏</h1>
<blockquote>原文：<a href="https://medium.com/swlh/context-and-memory-leaks-in-android-82a39ed33002?source=collection_archive---------0-----------------------#2019-06-04">https://medium.com/swlh/context-and-memory-leaks-in-android-82a39ed33002?source=collection_archive---------0-----------------------#2019-06-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="cba2" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">管理上下文和避免内存泄漏</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/f432cab3166eae637af51febb5124d0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CE5F0fJKyoAZSxkPITPU7Q.jpeg"/></div></div></figure><p id="19c7" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">迟早每个Android开发者都必须面对<strong class="jl kf">上下文</strong>的概念。<em class="kg">吐司、适配器、意图、膨胀器、共享优先权、系统服务</em>是经常与<em class="kg">上下文</em>相关联的术语。显示一个<em class="kg"> Toast </em>，打开一个新的屏幕，创建一个视图或者在首选项中保存数据都需要使用<em class="kg">上下文</em>作为参数。</p><p id="1072" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">有时候解决方案很简单(比如如果我们在一个<em class="kg">活动</em>中就使用<code class="du kh ki kj kk b"><strong class="jl kf">this</strong></code>，但是其他时候我们不确定我们在做什么，我们会感到疑惑……</p><h1 id="6479" class="kl km hi bd kn ko kp kq kr ks kt ku kv io kw ip kx ir ky is kz iu la iv lb lc bi translated">语境是什么？</h1><p id="fddb" class="pw-post-body-paragraph jj jk hi jl b jm ld ij jo jp le im jr js lf ju jv jw lg jy jz ka lh kc kd ke hb bi translated">应用程序环境的接口。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es li"><img src="../Images/552001a8084b8f7ff5a312afabd22a65.png" data-original-src="https://miro.medium.com/v2/resize:fit:896/format:webp/1*0X2clklAFLmCDYuFW1Iong.jpeg"/></div></figure><h2 id="ca7e" class="lj km hi bd kn lk ll lm kr ln lo lp kv js lq lr kx jw ls lt kz ka lu lv lb lw bi translated">嗯…好吧…但是那是什么意思…</h2><p id="bf43" class="pw-post-body-paragraph jj jk hi jl b jm ld ij jo jp le im jr js lf ju jv jw lg jy jz ka lh kc kd ke hb bi translated">这个定义试图告诉我们的是，<em class="kg">上下文</em>是一个具有访问应用程序资源和系统服务的方法的类。</p><p id="e1fa" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">为了得到<em class="kg">上下文，</em>我们通常使用<em class="kg">活动，</em>写单词<strong class="jl kf"> this </strong>，为此，我们可以推断一个<em class="kg">活动</em>是一个<em class="kg">上下文</em>。</p><p id="d403" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">的确，<em class="kg">活动</em>、<em class="kg">服务</em>或<em class="kg">应用</em>都是<em class="kg">上下文</em>抽象类的具体实现。在一个应用程序内部，可以有一些<em class="kg">活动</em>，一些<em class="kg">服务</em>，因此，有多个<em class="kg">上下文</em>，但是只有一个<em class="kg">应用程序</em>，因此，只有一个<strong class="jl kf">应用程序上下文</strong>。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lx"><img src="../Images/af556cd3332492aa28c0035af582ed53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*UfkM21pehBV_V9avkhywmw.png"/></div></div><figcaption class="ly lz et er es ma mb bd b be z dx">Complete inheritance tree</figcaption></figure><h1 id="57aa" class="kl km hi bd kn ko kp kq kr ks kt ku kv io kw ip kx ir ky is kz iu la iv lb lc bi translated">上下文是什么？</h1><p id="8c63" class="pw-post-body-paragraph jj jk hi jl b jm ld ij jo jp le im jr js lf ju jv jw lg jy jz ka lh kc kd ke hb bi translated">我们需要使用<em class="kg">上下文</em>的最常见场景是在使用视图(<em class="kg"> Toasts </em>、<em class="kg"> Adapters </em>、<em class="kg"> Inflaters </em>)、启动<em class="kg">活动</em> ( <em class="kg"> Intents </em>)或访问系统服务(<em class="kg"> SharedPreferences </em>、<em class="kg"> ContentProviders </em>)时。如果我们寻找一个更正式的分类，有四种情况:</p><ul class=""><li id="73c3" class="mc md hi jl b jm jn jp jq js me jw mf ka mg ke mh mi mj mk bi translated">聚集应用<strong class="jl kf">资源</strong> : <em class="kg">资源</em>，<em class="kg">资产</em>，<em class="kg">内部存储</em></li><li id="0163" class="mc md hi jl b jm ml jp mm js mn jw mo ka mp ke mh mi mj mk bi translated"><strong class="jl kf">沟通</strong>活动之间:<em class="kg">意图</em></li><li id="3b8d" class="mc md hi jl b jm ml jp mm js mn jw mo ka mp ke mh mi mj mk bi translated">访问<strong class="jl kf">系统</strong>服务:<em class="kg">系统服务</em></li><li id="d4a4" class="mc md hi jl b jm ml jp mm js mn jw mo ka mp ke mh mi mj mk bi translated">获取<strong class="jl kf">应用信息</strong> : <em class="kg">应用信息</em></li></ul><h2 id="a6cc" class="lj km hi bd kn lk ll lm kr ln lo lp kv js lq lr kx jw ls lt kz ka lu lv lb lw bi translated">我从哪里得到上下文？</h2><p id="10d4" class="pw-post-body-paragraph jj jk hi jl b jm ld ij jo jp le im jr js lf ju jv jw lg jy jz ka lh kc kd ke hb bi translated">返回一个<em class="kg"> Context </em>的方法有三个，分别在视图、活动和<em class="kg"> ContextWrapper </em>类中，每一个都有它的功能。</p><h2 id="df40" class="lj km hi bd kn lk ll lm kr ln lo lp kv js lq lr kx jw ls lt kz ka lu lv lb lw bi translated">在一种观点看来</h2><p id="0ec2" class="pw-post-body-paragraph jj jk hi jl b jm ld ij jo jp le im jr js lf ju jv jw lg jy jz ka lh kc kd ke hb bi translated"><em class="kg">视图</em>类有<code class="du kh ki kj kk b">getContext<strong class="jl kf">()</strong></code>方法来获取包含它的<em class="kg">活动</em>的<em class="kg">上下文</em>。作为一个<em class="kg">活动上下文</em>而不是一个<em class="kg">应用上下文</em>，它可以包含关于特定主题的信息，这些主题改变了特定活动的美感。因此，当管理视图、展开布局、启动活动、显示对话框或使用短期课程时，<strong class="jl kf">活动上下文</strong>是必不可少的。</p><blockquote class="mq mr ms"><p id="04d9" class="jj jk kg jl b jm jn ij jo jp jq im jr mt jt ju jv mu jx jy jz mv kb kc kd ke hb bi translated"><em class="hi">理解</em>【短期班】<em class="hi">为:</em> <code class="du kh ki kj kk b">classLifespan <strong class="jl kf">&lt;=</strong> activityLifespan</code></p></blockquote><h2 id="dd4d" class="lj km hi bd kn lk ll lm kr ln lo lp kv js lq lr kx jw ls lt kz ka lu lv lb lw bi translated">在一次活动中</h2><p id="0b44" class="pw-post-body-paragraph jj jk hi jl b jm ld ij jo jp le im jr js lf ju jv jw lg jy jz ka lh kc kd ke hb bi translated"><em class="kg">活动</em>类<strong class="jl kf">是</strong>的一个<em class="kg">上下文</em>被继承。这是前面提到的<em class="kg">活动上下文</em>，我们可以用这个来访问它。但是你可能已经知道了。</p><p id="2a20" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">您可以用来获得不同的<em class="kg">上下文</em>的方法是<code class="du kh ki kj kk b">getApplicationContext<strong class="jl kf">()</strong></code>，顾名思义，它返回<strong class="jl kf">应用程序的上下文</strong>，而不是活动的上下文。这是活动运行的流程的<em class="kg">上下文</em>，它用在超过<em class="kg">活动</em>生命周期的类中，如后台任务或数据访问。</p><h2 id="3c5c" class="lj km hi bd kn lk ll lm kr ln lo lp kv js lq lr kx jw ls lt kz ka lu lv lb lw bi translated">在上下文包装中</h2><p id="4060" class="pw-post-body-paragraph jj jk hi jl b jm ld ij jo jp le im jr js lf ju jv jw lg jy jz ka lh kc kd ke hb bi translated">这是继承树中的一个中间类，提供了<code class="du kh ki kj kk b">getBaseContext<strong class="jl kf">()</strong></code>方法。在大多数情况下，不建议使用<strong class="jl kf"/>。</p><h2 id="8f48" class="lj km hi bd kn lk ll lm kr ln lo lp kv js lq lr kx jw ls lt kz ka lu lv lb lw bi translated">总结…</h2><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mw"><img src="../Images/e6ca07dcd944a6f1531f909398ca2268.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wLlzFk7hU5RBfbCZu7FZNw.png"/></div></div><figcaption class="ly lz et er es ma mb bd b be z dx">How to use every type of Context</figcaption></figure><p id="86e1" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在这个表中，我们有动作和上下文类型的组合。启动<em class="kg">活动</em>时，务必指出<em class="kg">应用</em>和<em class="kg">服务</em>栏中的<strong class="jl kf">号</strong>。这是因为调用栈丢失<em class="kg"> (1) </em>。在展开布局时使用它也不好，因为它们的主题被应用来匹配<em class="kg">活动</em>的特定视觉风格，它们在<em class="kg">【2】</em>中。</p><p id="4c2f" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">学习正确管理<em class="kg">上下文</em>是一项将我们从意外问题中拯救出来的技能，它与内存泄漏密切相关。</p><h1 id="c676" class="kl km hi bd kn ko kp kq kr ks kt ku kv io kw ip kx ir ky is kz iu la iv lb lc bi translated">内存泄漏</h1><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mx"><img src="../Images/9a9a5d9314feef98b602d5fc5fb06e64.png" data-original-src="https://miro.medium.com/v2/resize:fit:406/format:webp/1*TiDIxO0UHQY3zYfeXwfGFg.png"/></div></figure><p id="11ec" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这篇文章的主要目的是帮助你防止<em class="kg">内存泄漏</em>。这就是:<strong class="jl kf">不再需要时不释放RAM </strong>资源。如果多次执行此操作，分配给应用程序的内存部分可能会超出限制，导致系统终止执行，用户会遇到应用程序崩溃。</p><p id="ddd9" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">内存泄漏的常见原因是静态变量、<em class="kg">单例</em>模式、后台任务和<em class="kg">匿名内部类</em>。让我们看一些如何检测和修复它们的例子。</p><h2 id="3057" class="lj km hi bd kn lk ll lm kr ln lo lp kv js lq lr kx jw ls lt kz ka lu lv lb lw bi translated">静态变量</h2><p id="9c5d" class="pw-post-body-paragraph jj jk hi jl b jm ld ij jo jp le im jr js lf ju jv jw lg jy jz ka lh kc kd ke hb bi translated">在新示例中，静态变量<code class="du kh ki kj kk b">vista</code>引用了活动的上下文:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="my mz l"/></div></figure><p id="c96a" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">如果应用程序在<em class="kg">活动</em>被销毁后继续运行，它正在使用的内存不会被释放，因为<code class="du kh ki kj kk b">vista</code>变量引用了该活动的上下文。</p><p id="bd11" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">一种解决方案是在<code class="du kh ki kj kk b">onDestroy<strong class="jl kf">()</strong></code>方法中取消对变量的引用。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="my mz l"/></div></figure><p id="4700" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">如果在使用<em class="kg">单例</em>时，它正在保存<strong class="jl kf">活动上下文</strong>，也会发生同样的问题。在这种情况下，最好的解决方案通常是使用应用程序上下文，因为我们应该有一个合适的MVC架构，所以不需要直接访问视图，也不需要活动上下文。</p><h2 id="6b05" class="lj km hi bd kn lk ll lm kr ln lo lp kv js lq lr kx jw ls lt kz ka lu lv lb lw bi translated">内部类</h2><p id="38ed" class="pw-post-body-paragraph jj jk hi jl b jm ld ij jo jp le im jr js lf ju jv jw lg jy jz ka lh kc kd ke hb bi translated">可怕的<em class="kg">内部类</em>是在另一个类或方法中创建的。例如，如果我们在一个<em class="kg">活动</em>中这样做，内部类将保存一个对该活动上下文的引用:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="my mz l"/></div></figure><p id="d577" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">和之前是一样的问题，真的，<code class="du kh ki kj kk b">innerClass</code>变量是静态的。如果是动态的，问题就消失了(再见<strong class="jl kf">静态的</strong>):</p><pre class="iy iz ja jb fd na kk nb nc aw nd bi"><span id="67d6" class="lj km hi kk b fi ne nf l ng nh"><strong class="kk kf">Object</strong> innerClass;</span></pre><h2 id="5cfa" class="lj km hi bd kn lk ll lm kr ln lo lp kv js lq lr kx jw ls lt kz ka lu lv lb lw bi translated">后台任务</h2><p id="0ba5" class="pw-post-body-paragraph jj jk hi jl b jm ld ij jo jp le im jr js lf ju jv jw lg jy jz ka lh kc kd ke hb bi translated">异步任务可以访问活动，并在活动完成后继续在后台运行。例如，在这段代码中，在活动内部创建了一个<em class="kg"> AsyncTask </em>:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="my mz l"/></div></figure><p id="d6c2" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">问题是，我们正在创建一个匿名类。如果我们将相同的代码放入继承AsyncTask的类中，问题就解决了。要运行<em class="kg"> MiAsyncTask </em>:</p><pre class="iy iz ja jb fd na kk nb nc aw nd bi"><span id="b38a" class="lj km hi kk b fi ne nf l ng nh"><strong class="kk kf">new</strong> MiAsyncTask<strong class="kk kf">.</strong>execute<strong class="kk kf">();</strong></span></pre><p id="5111" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">一个<strong class="jl kf"> <em class="kg">线程</em> </strong>会导致同样的错误，但是这次我们可以在活动被破坏时中断线程:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="my mz l"/></div></figure><h2 id="28a0" class="lj km hi bd kn lk ll lm kr ln lo lp kv js lq lr kx jw ls lt kz ka lu lv lb lw bi translated">事件处理</h2><p id="5684" class="pw-post-body-paragraph jj jk hi jl b jm ld ij jo jp le im jr js lf ju jv jw lg jy jz ka lh kc kd ke hb bi translated">另一个可能导致内存泄漏的微妙情况是，当一个活动注册为<em class="kg">监听器</em>来处理系统服务的事件时。传感器的一个例子是:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="my mz l"/></div></figure><p id="89c7" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">解决办法很简单，取消注册:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="my mz l"/></div></figure><h2 id="b379" class="lj km hi bd kn lk ll lm kr ln lo lp kv js lq lr kx jw ls lt kz ka lu lv lb lw bi translated">内存泄漏检测</h2><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ni"><img src="../Images/eff7eff2ce48ef38c3032231c211431e.png" data-original-src="https://miro.medium.com/v2/resize:fit:272/format:webp/1*rixH-ImQNSkfApJx84Uklw.png"/></div><figcaption class="ly lz et er es ma mb bd b be z dx">Leak Canary logo</figcaption></figure><p id="5e13" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">有时候，工具是检测内存泄漏的最快方法，特别是当我们正在处理一个已经编写了大量代码的大型项目时。</p><p id="b8c9" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">两个基本工具是<strong class="jl kf">内存分析器</strong>和<strong class="jl kf">泄漏检测器</strong>:</p><ul class=""><li id="ac3b" class="mc md hi jl b jm jn jp jq js me jw mf ka mg ke mh mi mj mk bi translated"><strong class="jl kf">内存分析器</strong>:这个工具是Android Studio的一部分，它是生成垃圾收集和显示内存消耗信息的文件的最快方式。</li><li id="f687" class="mc md hi jl b jm ml jp mm js mn jw mo ka mp ke mh mi mj mk bi translated"><strong class="jl kf">泄密金丝雀</strong>:安卓系统的矿工金丝雀。在我们的应用程序中安装这个库，我们可以看到导致设备内存泄漏的所有引用的踪迹。</li></ul><h1 id="9c7c" class="kl km hi bd kn ko kp kq kr ks kt ku kv io kw ip kx ir ky is kz iu la iv lb lc bi translated">参考</h1><ul class=""><li id="6cd6" class="mc md hi jl b jm ld jp le js nj jw nk ka nl ke mh mi mj mk bi translated">深入讲解<strong class="jl kf">背景</strong>:【https://possiblemobile.com/2013/06/context/】T4</li><li id="144a" class="mc md hi jl b jm ml jp mm js mn jw mo ka mp ke mh mi mj mk bi translated">关于<strong class="jl kf">内存泄漏的文章</strong>:<a class="ae nm" href="https://android.jlelse.eu/9-ways-to-avoid-memory-leaks-in-android-b6d81648e35e" rel="noopener ugc nofollow" target="_blank">https://android . JL else . eu/9-避免Android内存泄漏的方法-b6d81648e35e </a></li><li id="c91e" class="mc md hi jl b jm ml jp mm js mn jw mo ka mp ke mh mi mj mk bi translated">一些关于内存泄漏的可能<strong class="jl kf">原因</strong>和<strong class="jl kf">解决方案</strong>:<a class="ae nm" href="https://www.youtube.com/watch?v=DikbJw2D5RY" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=DikbJw2D5RY</a></li><li id="faef" class="mc md hi jl b jm ml jp mm js mn jw mo ka mp ke mh mi mj mk bi translated"><strong class="jl kf">内存分析器</strong>官方文档:<a class="ae nm" href="https://developer.android.com/studio/profile/memory-profiler?hl=es-419" rel="noopener ugc nofollow" target="_blank">https://developer . Android . com/studio/profile/Memory-Profiler？hl=es-419 </a></li><li id="3ee8" class="mc md hi jl b jm ml jp mm js mn jw mo ka mp ke mh mi mj mk bi translated"><strong class="jl kf">泄密的金丝雀【https://github.com/square/leakcanary图书馆:<a class="ae nm" href="https://github.com/square/leakcanary" rel="noopener ugc nofollow" target="_blank">T21</a></strong></li></ul></div></div>    
</body>
</html>