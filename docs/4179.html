<html>
<head>
<title>Class and Object Attributes — Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">类和对象属性Python</h1>
<blockquote>原文：<a href="https://medium.com/swlh/class-and-object-attributes-python-8191dcd1f4cf?source=collection_archive---------3-----------------------#2019-05-29">https://medium.com/swlh/class-and-object-attributes-python-8191dcd1f4cf?source=collection_archive---------3-----------------------#2019-05-29</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="7ab0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">什么是类和对象属性？有什么区别？为什么？</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/bb5d7dbc747c4879550aeccc509b189d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4dhdR-hOjoP3jlyQtk_27Q.jpeg"/></div></div></figure><p id="0978" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在进入类和对象属性的比较和例子之前，让我们首先定义它们—</p><ul class=""><li id="8374" class="jp jq hi ih b ii ij im in iq jr iu js iy jt jc ju jv jw jx bi translated"><strong class="ih jy">类属性</strong>是属于某个类的变量，而不是特定的对象。这个类的每个实例共享同一个变量。这些属性通常在<code class="du ka kb kc kd b">__init__</code>构造函数之外定义。</li><li id="582e" class="jp jq hi ih b ii ke im kf iq kg iu kh iy ki jc ju jv jw jx bi translated"><strong class="ih jy">实例/对象属性</strong>是属于一个(<em class="jz">且仅属于一个</em>)对象的变量。一个类的每个实例都指向它自己的属性变量。这些属性是在<code class="du ka kb kc kd b">__init__</code>构造函数中定义的。</li></ul><h1 id="a567" class="kj kk hi bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">为什么呢？</h1><p id="5a6d" class="pw-post-body-paragraph if ig hi ih b ii lh ik il im li io ip iq lj is it iu lk iw ix iy ll ja jb jc hb bi translated">为什么需要使用类属性和对象属性？</p><p id="345b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在一个只有狗的平行世界里，每只狗都有名字和年龄。狗的总数必须随时更新。所有这些都必须在一个类中定义！这可能看起来像这样:</p><pre class="je jf jg jh fd lm kd ln lo aw lp bi"><span id="ea46" class="lq kk hi kd b fi lr ls l lt lu">class Dog:<br/>    dogs_count = 0</span><span id="fb63" class="lq kk hi kd b fi lv ls l lt lu">    def __init__(self, name, age):<br/>        self.name = name<br/>        self.age = age<br/>        print("Welcome to this world {}!".format(self.name))<br/>        Dog.dogs_count += 1</span><span id="2336" class="lq kk hi kd b fi lv ls l lt lu">    def __del__(self):<br/>        print("Goodbye {} :(".format(self.name))<br/>        Dog.dogs_count -= 1</span></pre><p id="c9b5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这个类中，我们有一个类属性<code class="du ka kb kc kd b">dogs_count</code>。这个变量记录了我们的狗狗世界中狗狗的数量。我们有两个实例属性，<code class="du ka kb kc kd b">name</code>和<code class="du ka kb kc kd b">age</code>。这些变量对每只狗都是唯一的(每个实例的属性有不同的内存位置)。每次执行<code class="du ka kb kc kd b">__init__</code>功能，<code class="du ka kb kc kd b">dogs_count</code>增加。同样地——每一次狗死了(不幸的是狗不会永远活在这个世界上)，调用<code class="du ka kb kc kd b">__del__</code>方法，<code class="du ka kb kc kd b">dogs_count</code>减少。</p><pre class="je jf jg jh fd lm kd ln lo aw lp bi"><span id="c65c" class="lq kk hi kd b fi lr ls l lt lu">a = Dog("Max", 1)<br/>print("Number of dogs: {}".format(Dog.dogs_count))<br/>b = Dog("Charlie", 7)<br/>del a<br/>c = Dog("Spot", 4.5)<br/>print("Number of dogs: {}".format(Dog.dogs_count))<br/>del b<br/>del c<br/>print("Number of dogs: {}".format(Dog.dogs_count))</span><span id="422b" class="lq kk hi kd b fi lv ls l lt lu"><strong class="kd jy"><em class="jz">Output:<br/></em></strong>Welcome to this world Max!<br/>Number of dogs: 1<br/>Welcome to this world Charlie!<br/>Goodbye Max :(<br/>Welcome to this world Spot!<br/>Number of dogs: 2<br/>Goodbye Charlie :(<br/>Goodbye Spot :(<br/>Number of dogs: 0</span></pre><p id="873e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">啊哈！我们设法为一个对象分配唯一的变量，同时拥有一个所有对象都包含的共享变量。</p></div><div class="ab cl lw lx gp ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="hb hc hd he hf"><h1 id="d85b" class="kj kk hi bd kl km md ko kp kq me ks kt ku mf kw kx ky mg la lb lc mh le lf lg bi translated">属性的继承</h1><p id="9bd9" class="pw-post-body-paragraph if ig hi ih b ii lh ik il im li io ip iq lj is it iu lk iw ix iy ll ja jb jc hb bi translated">在打开这个话题之前，我们先来看看内置的<code class="du ka kb kc kd b">__dict__</code>属性。</p><pre class="je jf jg jh fd lm kd ln lo aw lp bi"><span id="ec25" class="lq kk hi kd b fi lr ls l lt lu">class Example:<br/>    classAttr = 0<br/>    def __init__(self, instanceAttr):<br/>        self.instanceAttr = instanceAttr</span><span id="f530" class="lq kk hi kd b fi lv ls l lt lu">a = Example(1)<br/>print(a.__dict__)<br/>print(Example.__dict__)</span><span id="a628" class="lq kk hi kd b fi lv ls l lt lu"><strong class="kd jy"><em class="jz">Output:<br/></em></strong>{'instanceAttr': 1}<br/>{'__module__': '__main__', '__doc__': None, '__dict__': &lt;attribute '__dict__' of 'Example' objects&gt;, '__init__': &lt;function Example.__init__ at 0x7f8af2113f28&gt;, 'classAttr': 0, '__weakref__': &lt;attribute '__weakref__' of 'Example' objects&gt;}</span></pre><p id="32ea" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如我们所看到的，类和对象都有一个包含属性键和值的字典。类字典存储实例不包含的多个内置属性。</p><pre class="je jf jg jh fd lm kd ln lo aw lp bi"><span id="ea59" class="lq kk hi kd b fi lr ls l lt lu">b = Example(2)<br/>print(b.classAttr)<br/>print(Example.classAttr)<br/>b.classAttr = 653<br/>print(b.classAttr)<br/>print(Example.classAttr)</span><span id="9595" class="lq kk hi kd b fi lv ls l lt lu"><strong class="kd jy"><em class="jz">Output:<br/></em></strong>0<br/>0<br/>653<br/>0</span></pre><p id="1afd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih jy"> WOAH。回到我之前写的，<em class="jz">一个类的每个实例共享相同的类属性</em>。这里发生了什么？我们改变了某个实例的class属性，但是共享变量实际上并没有改变。看一看这些元素的字典会有更深入的了解:</strong></p><pre class="je jf jg jh fd lm kd ln lo aw lp bi"><span id="bd9d" class="lq kk hi kd b fi lr ls l lt lu">b = Example(2)<br/>print(b.__dict__)<br/>print(Example.__dict__)<br/>b.classAttr = 653<br/>print(b.__dict__)<br/>print(Example.__dict__)</span><span id="4296" class="lq kk hi kd b fi lv ls l lt lu"><strong class="kd jy"><em class="jz">Output:<br/></em></strong>{'instanceAttr': 2}<br/>'__module__': '__main__', '__doc__': None, '__dict__': &lt;attribute '__dict__' of 'Example' objects&gt;, '__init__': &lt;function Example.__init__ at 0x7f8af2113f28&gt;, 'classAttr': 0, '__weakref__': &lt;attribute '__weakref__' of 'Example' objects&gt;}<br/><strong class="kd jy">{'instanceAttr': 2, 'classAttr': 653}</strong><br/>{'__module__': '__main__', '__doc__': None, '__dict__': &lt;attribute '__dict__' of 'Example' objects&gt;, '__init__': &lt;function Example.__init__ at 0x7f8af2113f28&gt;, 'classAttr': 0, '__weakref__': &lt;attribute '__weakref__' of 'Example' objects&gt;}</span></pre><p id="d919" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">仔细观察，我们注意到<code class="du ka kb kc kd b">classAttr</code>已经被添加到对象的字典中，并带有修改后的值。类的字典保持不变，这表明类属性有时可以表现为实例属性。</p><h1 id="a060" class="kj kk hi bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">结论</h1><p id="fca9" class="pw-post-body-paragraph if ig hi ih b ii lh ik il im li io ip iq lj is it iu lk iw ix iy ll ja jb jc hb bi translated">综上所述，类和对象属性非常有用，但是在一起使用时会变得混乱。当每个对象需要共享一个变量(如计数器)时，类属性是有利的。当每个唯一的对象需要自己的值时，对象属性具有优势，这使它们不同于其他对象。</p></div></div>    
</body>
</html>