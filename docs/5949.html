<html>
<head>
<title>Create your Spring framework — History and Internals of Dependency Injection + IoC</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">创建你的Spring框架——依赖注入+ IoC的历史和内部</h1>
<blockquote>原文：<a href="https://medium.com/swlh/create-your-spring-framework-history-and-internals-of-dependency-injection-ioc-a957e6ccf6cf#2019-06-16">https://medium.com/swlh/create-your-spring-framework-history-and-internals-of-dependency-injection-ioc-a957e6ccf6cf#2019-06-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="21d7" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">这篇文章讲述了Spring (Boot)框架的历史，Spring框架是如何工作的，它的内部结构以及控制反转(IoC)和依赖注入(DI)的基础</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/bfa74b339400e37c0262715ef60020c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DSCKDrShBd4FRwEpGddt4Q.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Spring Framework Internals</figcaption></figure><p id="62f4" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">我观察到现在的年轻人对使用一种技术或框架更感兴趣，而不是了解一种特定的技术或框架在幕后是如何工作的？或者甚至退一步去理解为什么这个框架在一开始就被建立起来？</p><p id="07a2" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">作为一名工程经理，我个人在团队中看到，每个人都习惯使用像Spring Framework或Spring Boot这样的框架，但没有人有兴趣问这样的问题:</p><ol class=""><li id="d4cb" class="kk kl hi jp b jq jr jt ju jw km ka kn ke ko ki kp kq kr ks bi translated">我们应该在哪里使用Spring Boot或Spring框架？</li><li id="a246" class="kk kl hi jp b jq kt jt ku jw kv ka kw ke kx ki kp kq kr ks bi translated">Spring Boot和Spring框架有什么不同？</li><li id="984c" class="kk kl hi jp b jq kt jt ku jw kv ka kw ke kx ki kp kq kr ks bi translated">Spring框架之前的社区是如何运作的？</li><li id="65d7" class="kk kl hi jp b jq kt jt ku jw kv ka kw ke kx ki kp kq kr ks bi translated">Spring框架是如何在幕后工作的？</li><li id="51d7" class="kk kl hi jp b jq kt jt ku jw kv ka kw ke kx ki kp kq kr ks bi translated">如果被要求这样做，我可以构建自己的框架吗？</li></ol><p id="1c39" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">当你的头脑开始问这样的问题时，你将开始进入一个完全不同的自我。</p><h1 id="7ce3" class="ky kz hi bd la lb lc ld le lf lg lh li io lj ip lk ir ll is lm iu ln iv lo lp bi translated">使用案例</h1><h2 id="d272" class="lq kz hi bd la lr ls lt le lu lv lw li jw lx ly lk ka lz ma lm ke mb mc lo md bi translated">版本1</h2><p id="df6d" class="pw-post-body-paragraph jn jo hi jp b jq me ij js jt mf im jv jw mg jy jz ka mh kc kd ke mi kg kh ki hb bi translated">为了解释这一点，我将举一个消息呈现应用程序的简单用例。将有一个类负责提供消息，还有一个类负责接收上述消息并在控制台上打印。因此，这将是您的核心包:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mj"><img src="../Images/1f2dc076830ae0f7874e6112363dd4e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Yauuq88XjHyORhfDU0ZuYg.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">HelloWorldMessageProvider- the class serving the message</figcaption></figure><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mk"><img src="../Images/ca60d54edc5ed6d7eaa039f8132a2c21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UzhV_GKnduUliTJFZwDMxg.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">StandardOutMessageRendered — Class responsible for printing the message above</figcaption></figure><div class="iy iz ja jb fd ab cb"><figure class="ml jc mm mn mo mp mq paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><img src="../Images/13388ca3488bc477c91b51b525854eaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:806/format:webp/1*89hz3RHVdNewotcF4hPc_Q.png"/></div></figure><figure class="ml jc mr mn mo mp mq paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><img src="../Images/3d1f82b7c171ac0042ad9ae2ad3de82c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1196/format:webp/1*PYEHgpMVvvojnohS_ZxVTw.png"/></div><figcaption class="jj jk et er es jl jm bd b be z dx ms di mt mu">App or Main Class — Glueing everything together to print our message on console</figcaption></figure></div><p id="3a6e" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">这里需要你注意的班级是Main.java<strong class="jp kj"/>。如果你仔细看，虽然商业逻辑似乎只与下面的线有关</p><blockquote class="mv"><p id="35d8" class="mw mx hi hj my mz na nb nc nd ne ki dx translated">messageRenderer.render()</p></blockquote><p id="bc10" class="pw-post-body-paragraph jn jo hi jp b jq nf ij js jt ng im jv jw nh jy jz ka ni kc kd ke nj kg kh ki hb bi translated">然而，该代码有许多粘合代码来创建对象，然后根据需要设置依赖关系。这似乎是我们可以避免的重复代码。</p><p id="f736" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">进一步假设现在我们想要添加更多的渲染器，比如带有不同消息提供者的FileOutMessageRenderer。这意味着在创建必要的对象并再次设置它们时，您的应用程序代码将再次更改。这太糟糕了！</p><p id="6478" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">工厂设计模式可以让你保持代码的整洁，但是设置依赖关系仍然是一个问题。</p><p id="8e47" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">现在问这个简单的问题:</p><h2 id="369a" class="lq kz hi bd la lr ls lt le lu lv lw li jw lx ly lk ka lz ma lm ke mb mc lo md bi translated">如果我们可以将创建和管理依赖关系的控制权从Main.java转移到其他地方，会怎么样？</h2><h2 id="0fb6" class="lq kz hi bd la lr ls lt le lu lv lw li jw lx ly lk ka lz ma lm ke mb mc lo md bi translated">版本2</h2><p id="4764" class="pw-post-body-paragraph jn jo hi jp b jq me ij js jt mf im jv jw mg jy jz ka mh kc kd ke mi kg kh ki hb bi translated">上面的问题会让你觉得这是所有项目中非常普遍的问题。如果我们能对此推出一个解决方案，并使其松散耦合，我们将实际上创建一个框架，可以帮助节省开发人员的大量工作，并实现一个更干净和模块化的代码。所以让我们称我们的框架为<strong class="jp kj">“Apurav框架”</strong></p><p id="ab59" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">Apurav框架的职责是读取对象定义文件以及每个对象需要满足的依赖关系。想象一个如下所示的属性文件:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nk"><img src="../Images/13c9b3ab57b5332e233f8c2e8c5ec25e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*98cKSuqEDCWnSbbLQ_zH5g.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Property file containing objects that need to be created and dependencies for each object</figcaption></figure><p id="bc56" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">从上述文件创建对象的核心框架代码是:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nl"><img src="../Images/0738a6b4fafe1638a696ca258bb40057.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q6giEafO_-Fg3wP5Plc5Rg.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">ApuravFramework.java</figcaption></figure><p id="7774" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">试着理解上面的代码，它做了以下事情:</p><ol class=""><li id="c9cf" class="kk kl hi jp b jq jr jt ju jw km ka kn ke ko ki kp kq kr ks bi translated">读取属性文件</li><li id="fff7" class="kk kl hi jp b jq kt jt ku jw kv ka kw ke kx ki kp kq kr ks bi translated">对于每个以<strong class="jp kj">开始的属性<em class="nm">对象。</em> </strong>，它使用Class.forName签名创建一个对象，并放入Hashmap注册表中</li><li id="957d" class="kk kl hi jp b jq kt jt ku jw kv ka kw ke kx ki kp kq kr ks bi translated">对于其他每个属性，它会找到已经创建的对象，并简单地设置它的依赖关系，如文件中所述</li></ol><p id="932e" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">创建和设置依赖关系的所有粘合代码现在已经被抽象到我们的ApuravFramework.java的<strong class="jp kj">中，我们的Main.java只剩下调用业务逻辑的单一责任。</strong></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nn"><img src="../Images/e6fca2548923e20f8649c6ab628f0a11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O8qqMKcK2hzRDcY8v-MPOg.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Version 2 of Main.java</figcaption></figure><p id="aa39" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">所以现在，这个<strong class="jp kj"> ApuravFramework </strong>实际上已经使用外部配置将管理依赖关系的控制权从Main.java转移到了它自己身上。我们可以称之为IoC(控制反转)容器或阿迪(依赖注入)框架。</p><p id="ca98" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">瞧啊。这是给你的弹簧芯。</p><h2 id="a87b" class="lq kz hi bd la lr ls lt le lu lv lw li jw lx ly lk ka lz ma lm ke mb mc lo md bi translated">版本3</h2><p id="dcf8" class="pw-post-body-paragraph jn jo hi jp b jq me ij js jt mf im jv jw mg jy jz ka mh kc kd ke mi kg kh ki hb bi translated">现在最终版本实际上是为你准备的Spring框架。在内部，它创建对象并设置它们，就像你在ApuravFramework.java看到的那样。唯一的区别是在下面的例子中，它读取的是XML文件而不是属性文件。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es no"><img src="../Images/2830ac749a2d3bbc829fb1a99dd0fe33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z6rVud4loj_6keTVsfA85w.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Spring Framework reading an XML file for dependencies definition</figcaption></figure><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es np"><img src="../Images/bcba0e7e50a656b270e2b3c0cb7d9055.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zENDQ425ifE5JdEur8YU3w.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">context.xml file which Spring framework reads</figcaption></figure><h1 id="93d2" class="ky kz hi bd la lb lc ld le lf lg lh li io lj ip lk ir ll is lm iu ln iv lo lp bi translated">下载</h1><p id="c418" class="pw-post-body-paragraph jn jo hi jp b jq me ij js jt mf im jv jw mg jy jz ka mh kc kd ke mi kg kh ki hb bi translated">在我的<a class="ae nq" href="https://github.com/apuravchauhan/spring-oldskool" rel="noopener ugc nofollow" target="_blank"> github </a>上下载完整的代码库。</p><h1 id="4a78" class="ky kz hi bd la lb lc ld le lf lg lh li io lj ip lk ir ll is lm iu ln iv lo lp bi translated">参考</h1><p id="0553" class="pw-post-body-paragraph jn jo hi jp b jq me ij js jt mf im jv jw mg jy jz ka mh kc kd ke mi kg kh ki hb bi translated">apress-Pro弹簧</p></div></div>    
</body>
</html>