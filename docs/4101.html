<html>
<head>
<title>JavaScript: Primitive vs Reference Values</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript:原始值与参考值</h1>
<blockquote>原文：<a href="https://medium.com/swlh/javascript-primitive-vs-reference-values-2836e8bb1c5d#2019-05-28">https://medium.com/swlh/javascript-primitive-vs-reference-values-2836e8bb1c5d#2019-05-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="d149" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如何以及何时在你的日常发展中使用</p><p id="6b46" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有时，忽视学习原语和引用值如何在JavaScript上工作的误解在新开发人员中非常普遍。有时这只是一个简单的实践，有时会在长期开发中导致意外的复杂性。</p><h1 id="beb5" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated"><strong class="ak">原始值</strong></h1><blockquote class="kc kd ke"><p id="c197" class="if ig kf ih b ii ij ik il im in io ip kg ir is it kh iv iw ix ki iz ja jb jc hb bi translated"><strong class="ih jd">原始值:</strong>是在<strong class="ih jd">堆栈内存上有专用内存地址值的值。</strong>它们是值，没有属性。</p></blockquote><p id="8951" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每种编程语言都有自己管理原始值的方式。通常原始值在存储方面更特殊。它在堆栈存储器上分配了一个固定的地址。</p><p id="9e8e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">JavaScript原语值类型列表有<strong class="ih jd"> <em class="kf">字符串、数字、布尔、未定义、空。</em> </strong>但是他们也有他们可以使用的原始方法。</p><p id="2179" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">JavaScript原始全局方法:<strong class="ih jd">(字符串、布尔、数字)</strong></p><p id="dc1f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">123和数字(123)是一样的。全局原语方法通常用于返回全局对象的原语值。</p><h1 id="2115" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">例子:让我们举一个基本方法号()的例子</h1><figure class="kk kl km kn fd ko er es paragraph-image"><div class="er es kj"><img src="../Images/56bcd02567795764f658825821170f4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1308/format:webp/1*A8K6imWlbnLPFuqQ8AzZyw.png"/></div><figcaption class="kr ks et er es kt ku bd b be z dx">Different implementation but the same values</figcaption></figure><p id="3533" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih jd"> Number() </strong>用于返回<em class="kf">一个表示同类数的对象否则将返回一个</em><strong class="ih jd"><em class="kf"/></strong><em class="kf">也称为</em> <strong class="ih jd"> <em class="kf">【非数】。</em> </strong> <em class="kf">它也和String一样，和Boolean一样。除了处理异常值之外，它们根据自己的种类返回相同的东西。</em></p><p id="bade" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我使用原始类来检查传递给我的类或函数的值是否与需要的值相同。</p><figure class="kk kl km kn fd ko er es paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="er es kv"><img src="../Images/01e838027d12803107dfef82ecc30db4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9zJc3DNlNFEVGyHZ2Zs44Q.png"/></div></div></figure><p id="fb71" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih jd">数字(年龄)</strong>检查给定参数是否为数字。<strong class="ih jd"> </strong>如果不是；它将返回一个<strong class="ih jd">【NaN】</strong>值或者也称为<strong class="ih jd">【非数字】</strong></p><h1 id="4005" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">另一个使用String()的例子</h1><p id="99b7" class="pw-post-body-paragraph if ig hi ih b ii la ik il im lb io ip iq lc is it iu ld iw ix iy le ja jb jc hb bi translated">在这种情况下，如果您不想将某个值保存为与预期的数据库列类型相同。您可以在保存到数据库之前转换表示值的参数，以确保满足要求。</p><figure class="kk kl km kn fd ko er es paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="er es lf"><img src="../Images/058d78c22889dca078f9921cd4505f1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dngKF3NjDwYY0AGySVi6Ag.png"/></div></div><figcaption class="kr ks et er es kt ku bd b be z dx">saveName(234) supposed to be invalid since the SQL expects a string name value. But since we put a String method within the name value. any parameter before its been saved is converted to a string type.</figcaption></figure><p id="64bd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这表明该值是函数<strong class="ih jd"> saveName() </strong>给出的数字。<strong class="ih jd"> 234 </strong>是数字的<strong class="ih jd">原始类型</strong>，如果要保存的预期列是字符串类型，它会导致数据库<strong class="ih jd">出错；Yes value <strong class="ih jd"> 234 </strong>不是真名但是姑且说是真名吧。</strong></p><p id="f9d8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">JavaScript是松散类型。以便至少按类型进行约束。我们可以使用这些全局原语方法来转换这些值。</p><h1 id="a417" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">参考值</h1><blockquote class="kc kd ke"><p id="4c7d" class="if ig kf ih b ii ij ik il im in io ip kg ir is it kh iv iw ix ki iz ja jb jc hb bi translated"><strong class="ih jd">参考值:</strong>是动态存储在<strong class="ih jd">堆内存或自由存储器中的值。</strong></p><p id="f7cf" class="if ig kf ih b ii ij ik il im in io ip kg ir is it kh iv iw ix ki iz ja jb jc hb bi translated"><strong class="ih jd">它们是由属性定义的。</strong>这些属性要么是默认属性，要么是添加属性</p></blockquote><p id="3301" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih jd">堆内存:</strong>动态存储在空闲存储上意味着数据被存储在一个具有随机内存地址的内存池中。</p><p id="71a3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">参考值通常用于大量数据。它们被分组为<strong class="ih jd"> JavaScript对象符号或JSON、函数或类。至少对我来说是这样。</strong></p><p id="e49f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih jd">示例:</strong></p><p id="c569" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一个<strong class="ih jd">变量配置文件</strong>由一个具有<strong class="ih jd">名、</strong>和<strong class="ih jd">出生日期</strong>属性<strong class="ih jd"> </strong>的对象分配</p><figure class="kk kl km kn fd ko er es paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="er es lg"><img src="../Images/fb6a4740a9390457cd260a629758411c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*41_9ZI13Pe4ITVkipYTZ8A.png"/></div></div></figure><p id="fc73" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">属性(名字、姓氏、出生日期)被分配给堆内存，并将分配的地址发送回var配置文件。</p><blockquote class="kc kd ke"><p id="0f8a" class="if ig kf ih b ii ij ik il im in io ip kg ir is it kh iv iw ix ki iz ja jb jc hb bi translated">属性不会被传递回var配置文件，而只是从<strong class="ih jd">堆内存</strong>中分配的地址</p></blockquote><p id="6f4e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih jd">缺点:</strong>拥有引用类型的缺点是如果你把它赋给另一个值，即使你把它改成下一个赋值的值也要改。第一个声明的值也会改变。当分配的值不是精确值，而只是分配地址时，参考值起作用。</p><h2 id="e295" class="lh jf hi bd jg li lj lk jk ll lm ln jo iq lo lp js iu lq lr jw iy ls lt ka lu bi translated">示例:</h2><figure class="kk kl km kn fd ko er es paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="er es lg"><img src="../Images/293ccc4f440dfc4349ebbc14d7d582b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n12QXojHdvyvxXMzU0Wo5Q.png"/></div></div></figure><p id="7ebc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih jd"> var profile </strong>被赋给<strong class="ih jd"> var jane </strong>现在有了<strong class="ih jd">var profile<strong class="ih jd">的参考</strong>值。</strong></p><p id="4d9d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在将其保存到var配置文件之前。它被分配给堆内存，用该地址创建一个快照，并将对象地址返回给<strong class="ih jd"> var配置文件。</strong></p><p id="081d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">而当<strong class="ih jd"> var profile </strong>被分配给<strong class="ih jd"> var jane </strong>时。理想情况下，从<strong class="ih jd">变量配置文件</strong>中保存的地址也被传递给<strong class="ih jd">变量简</strong>。</p><figure class="kk kl km kn fd ko er es paragraph-image"><div class="er es lv"><img src="../Images/655c4d131773dc98ed8a19bacf3b25c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/format:webp/1*kfqZtCPIiUpYuW2313wtQA.png"/></div></figure><blockquote class="kc kd ke"><p id="f395" class="if ig kf ih b ii ij ik il im in io ip kg ir is it kh iv iw ix ki iz ja jb jc hb bi translated">因此，引用是从var profile传递到var jane的地址。</p></blockquote><p id="d3dd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们修改<strong class="ih jd">var</strong>T46】Jane的<strong class="ih jd"> firstName </strong>属性。这是因为该值并不是真正的<strong class="ih jd">复制的</strong>，而是<strong class="ih jd">引用的</strong>。<strong class="ih jd"> var配置文件的</strong>属性<strong class="ih jd">名字</strong>也被更改。</p><p id="7ff0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面的例子是使用<strong class="ih jd">对象进行检查。is<strong class="ih jd">ES6</strong>的</strong>方法检查<strong class="ih jd"> var profile </strong>和<strong class="ih jd"> var jane </strong>是否共享同一个引用</p><figure class="kk kl km kn fd ko er es paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="er es lw"><img src="../Images/d39e85bae59d3530ff98951b66cadefd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m8YYCCR4lpdocuXYQ2QGkA.png"/></div></div></figure><blockquote class="kc kd ke"><p id="9d58" class="if ig kf ih b ii ij ik il im in io ip kg ir is it kh iv iw ix ki iz ja jb jc hb bi translated">因此，如果两个对象在同一个范围内，就要小心数据的改变。</p></blockquote></div></div>    
</body>
</html>