<html>
<head>
<title>React Lifecycle &amp; Hooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应生命周期和挂钩</h1>
<blockquote>原文：<a href="https://medium.com/swlh/react-lifecycle-hooks-71547ef4e7a8?source=collection_archive---------3-----------------------#2019-05-17">https://medium.com/swlh/react-lifecycle-hooks-71547ef4e7a8?source=collection_archive---------3-----------------------#2019-05-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="43a3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我最近几周才开始学习React，但我已经爱上了它。它很快，是模块化的，遵循一个清晰的结构，我很喜欢。到目前为止，学习React我最喜欢的部分之一是理解React组件的生命周期(见下文)。您可以使用这些方法来控制组件随时间推移的行为，这种方式非常棒。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/04b5e8d66e8f19d3693135ce1e67938d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EnuAy1kb9nOcFuIzM49Srw.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx">React lifecycle diagram — <a class="ae jt" href="http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/" rel="noopener ugc nofollow" target="_blank">http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/</a></figcaption></figure><p id="862d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">定义React组件有两种主要方式:</p><ul class=""><li id="c756" class="ju jv hi ih b ii ij im in iq jw iu jx iy jy jc jz ka kb kc bi translated">功能组件</li><li id="d289" class="ju jv hi ih b ii kd im ke iq kf iu kg iy kh jc jz ka kb kc bi translated">类别组件</li></ul><p id="796d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最初，函数组件不如类组件强大。他们缺乏使用“状态”(可以从类组件内部控制的可变属性)的能力，并且他们不能充分利用React的生命周期方法。因此，我主要在我的React应用中使用类组件(尽管功能组件的性能优势较小)。我也更喜欢类组件的更明确的语法。</p><p id="5fa7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">今天，我试图通过自学React Hooks来打破我的课堂组件习惯。钩子是在2018年10月引入React的，作为将状态和生命周期概念纳入功能组件的一种方式。关于它们的博客已经写了无数次了，但是它们在实际应用中仍然相对较新。在我的以JavaScript/React为中心的训练营中，仍然没有教授它们，尽管它们很明显是React开发者所设想的React的未来。我希望现在学习使用它们能在我开始开发生涯时助我一臂之力。</p><p id="4929" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，我想把重点放在我在React类组件中最常用的两个方法(除了render，它只是main函数的主体)——以及如何用React钩子编写它们的功能。</p><h1 id="1afa" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">构造函数( )-&gt;使用状态()</h1><p id="96e8" class="pw-post-body-paragraph if ig hi ih b ii lg ik il im lh io ip iq li is it iu lj iw ix iy lk ja jb jc hb bi translated">实际上，我甚至不确定构造函数算不算组件生命周期方法，但它的功能很像。事实上，这只是普通JavaScript的一部分，用于在实例化时定义给定类的对象的属性。在React中，构造函数主要用于两个目的:</p><ul class=""><li id="42de" class="ju jv hi ih b ii ij im in iq jw iu jx iy jy jc jz ka kb kc bi translated">设置状态的初始值</li><li id="48f6" class="ju jv hi ih b ii kd im ke iq kf iu kg iy kh jc jz ka kb kc bi translated">在非生命周期方法中绑定关键字“this”来引用当前对象</li></ul><p id="a0e0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">构造函数是这两个函数的理想位置，因为它甚至在组件呈现之前就运行了。</p><pre class="je jf jg jh fd ll lm ln lo aw lp bi"><span id="e2c6" class="lq kj hi lm b fi lr ls l lt lu">import React, {Component} from 'react'</span><span id="05ee" class="lq kj hi lm b fi lv ls l lt lu">class Message extends Component {<br/>  constructor(props) {<br/>    super(props)<br/>    this.state = {<br/>      message: ''<br/>    }<br/>  this.setMessage = this.setMessage.bind(this)<br/>  }</span><span id="2230" class="lq kj hi lm b fi lv ls l lt lu">  setMessage() {<br/>    this.setState({message: 'Hello World!'})<br/>  }</span><span id="89b5" class="lq kj hi lm b fi lv ls l lt lu">  render() {<br/>    return (<br/>      &lt;main&gt;<br/>        &lt;button onClick={this.setMessage}&gt;Click&lt;/button&gt;<br/>        &lt;p&gt;{this.state.message}&lt;p&gt;<br/>      &lt;/main&gt;<br/>    )<br/>  }<br/>}</span></pre><p id="5dc0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上面的示例中，消息组件有三个方法(函数),它们按以下顺序运行:</p><ul class=""><li id="6911" class="ju jv hi ih b ii ij im in iq jw iu jx iy jy jc jz ka kb kc bi translated">constructor() —设置初始“消息”状态，并在setMessage方法的上下文中将引用绑定到“this”</li><li id="cdad" class="ju jv hi ih b ii kd im ke iq kf iu kg iy kh jc jz ka kb kc bi translated">render() —确定该组件显示或“返回”什么内容；最初只呈现一个按钮(带有一个事件侦听器)和一个空段落(基于构造函数中为this.state.message设置的空字符串)</li></ul><p id="3ab4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果用户单击该按钮:</p><ul class=""><li id="df33" class="ju jv hi ih b ii ij im in iq jw iu jx iy jy jc jz ka kb kc bi translated">setMessage() —将消息状态从空字符串更新为“Hello World！”，导致组件重新呈现并到处触发陈词滥调警报</li><li id="f570" class="ju jv hi ih b ii kd im ke iq kf iu kg iy kh jc jz ka kb kc bi translated">render() —再次运行，现在显示“Hello World！”代替前面的空字符串</li></ul><p id="1dbd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是一个非常简单的例子，但我认为它涵盖了React中构造函数方法的两个主要用例。我仍然喜欢将所有这些分离出来，使其更加模块化，但我知道这并不吸引所有人。现在用React挂钩构建相同的组件:</p><pre class="je jf jg jh fd ll lm ln lo aw lp bi"><span id="a395" class="lq kj hi lm b fi lr ls l lt lu">import React, {useState} from 'react'</span><span id="4773" class="lq kj hi lm b fi lv ls l lt lu">function Message() {<br/>  const [message, setMessage] = useState('')<br/>  return (<br/>    &lt;main&gt;<br/>      &lt;button onClick={() =&gt; setMessage('Hello World!')}&gt;<br/>        Click<br/>      &lt;/button&gt;<br/>      &lt;p&gt;{message}&lt;/p&gt;<br/>    &lt;/main&gt;<br/>  )<br/>}</span></pre><p id="0da6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如您所见，这是非常少的代码，并且构造函数是完全不必要的。使用“useState()”，可以同时为“message”设置一个初始值，并创建“setMessage”函数以在将来更新状态。因为setMessage是一个函数而不是一个方法，并且它是用arrow函数内联调用的，所以没有必要定义“this”或者将它绑定到任何东西。</p><h1 id="7c76" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">componentidmount()-&gt; use effect()</h1><p id="d5e9" class="pw-post-body-paragraph if ig hi ih b ii lg ik il im lh io ip iq li is it iu lj iw ix iy lk ja jb jc hb bi translated">我最常用的生命周期方法之一是componentDidMount。首次成功装载和呈现组件后，会自动触发此方法。我使用它有几个目的，但最常见的是我用它为我的应用程序获取数据。</p><pre class="je jf jg jh fd ll lm ln lo aw lp bi"><span id="6ca7" class="lq kj hi lm b fi lr ls l lt lu">import React, {Component} from 'react'</span><span id="1d8a" class="lq kj hi lm b fi lv ls l lt lu">class List extends Component {<br/>  constructor(props) {<br/>    super(props)<br/>    this.state = {<br/>      data: null<br/>    }<br/>  }<br/><br/>  render() {<br/>    let listItems   <br/>    if (this.state.data) {<br/>      listItems = this.state.data.map((item, i) =&gt; {<br/>        &lt;p key={i}&gt;{item.name}&lt;/p&gt;<br/>      }<br/>    } else {<br/>      listItems = &lt;p&gt;Loading...&lt;/p&gt;<br/>    }<br/>    return {listItems}<br/>  }</span><span id="e59d" class="lq kj hi lm b fi lv ls l lt lu">  componentDidMount() {<br/>    fetch('http://imaginaryurl.com/api/listItems').then((res) =&gt; {<br/>      res.json()).then((json) =&gt; {<br/>        this.setState({data: json})<br/>      }<br/>    }<br/>  }<br/>}</span></pre><p id="1503" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面的代码遵循这种模式:</p><ul class=""><li id="4650" class="ju jv hi ih b ii ij im in iq jw iu jx iy jy jc jz ka kb kc bi translated">构造器/呈现—以不完整的状态装载和呈现组件(通常带有某种装载指示符)</li><li id="c969" class="ju jv hi ih b ii kd im ke iq kf iu kg iy kh jc jz ka kb kc bi translated">componentDidMount —从虚构的API获取数据，并使用该数据更新组件的状态，从而触发组件重新呈现</li><li id="ed5b" class="ju jv hi ih b ii kd im ke iq kf iu kg iy kh jc jz ka kb kc bi translated">render —组件再次呈现，这一次使用componentDidMount中提取的数据来完全满足其预期目的</li></ul><p id="3360" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在准备这篇博客的过程中，似乎有一个更好的方法来做这件事，那就是使用<a class="ae jt" href="https://reactjs.org/docs/code-splitting.html" rel="noopener ugc nofollow" target="_blank"> React.lazy和悬念</a>，但是我还是要用它作为useEffect钩子的例子(使用我们的好朋友useState的另一个例子):</p><pre class="je jf jg jh fd ll lm ln lo aw lp bi"><span id="5e12" class="lq kj hi lm b fi lr ls l lt lu">import React, {useState, useEffect} from 'react'<br/>import axios from 'axios'</span><span id="ce3c" class="lq kj hi lm b fi lv ls l lt lu">function List() {<br/>  const [data, loadData] = useState(null)<br/>  useEffect(async () =&gt; {<br/>    let listItems = await axios(<br/>      'http://imaginaryurl.com/api/listItems'<br/>    )<br/>    loadData(listItems.data)<br/>  }, [])<br/>  let listItems   <br/>  if (data) {<br/>    listItems = data.map((item, i) =&gt; {<br/>      &lt;p key={i}&gt;{item.name}&lt;/p&gt;<br/>    }<br/>  } else {<br/>   listItems = &lt;p&gt;Loading...&lt;/p&gt;<br/>  }<br/>  return {listItems}<br/>}</span></pre><p id="194c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我希望这有所帮助！正如我所说的，我仍然在学习React，我仍然喜欢类组件，但是钩子确实很有用。这仅仅是对钩子功能的皮毛，但这是我需要的入门知识，让我对使用它们感到舒服。希望很快我会设计自己的钩子，并在我的<a class="ae jt" href="https://www.adamgrider.dev" rel="noopener ugc nofollow" target="_blank">代码</a>中实现它们。</p></div></div>    
</body>
</html>