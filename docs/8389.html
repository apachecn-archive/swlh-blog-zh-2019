<html>
<head>
<title>Bitrise — Run Android instrumented tests on different modules within the same project</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">bit rise——在同一个项目的不同模块上运行Android测试</h1>
<blockquote>原文：<a href="https://medium.com/swlh/bitrise-run-android-instrumented-tests-on-different-modules-within-the-same-project-51a1fc38dfa1?source=collection_archive---------24-----------------------#2019-07-16">https://medium.com/swlh/bitrise-run-android-instrumented-tests-on-different-modules-within-the-same-project-51a1fc38dfa1?source=collection_archive---------24-----------------------#2019-07-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/b492cd8bdea2950f1484500f4af18629.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PPivUBZ9BxxmM9fV4QL22A.jpeg"/></div></div></figure><div class=""/><p id="3fde" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我最近遇到了这个问题，我发现很少有文档(大部分都已经过时了)，所以我决定写一个非常简单的<em class="jo">逐步</em>教程。</p><p id="d28d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先，让我们先简单介绍一下什么是<em class="jo">仪器化测试。</em>引用谷歌官方文件:</p><blockquote class="jp"><p id="27c7" class="jq jr ht hu js jt ju jv jw jx jy jn dx translated">插装单元测试是在物理设备和模拟器上运行的测试，它们可以利用Android框架API和支持API，如AndroidX Test。</p></blockquote><p id="47bf" class="pw-post-body-paragraph iq ir ht is b it jz iv iw ix ka iz ja jb kb jd je jf kc jh ji jj kd jl jm jn hb bi translated">单元测试的一个很大的优点是你可以测试你的类的真实实例(没有<em class="jo">嘲笑</em>它们)，或者你可以简单地运行UI测试(这些类型的测试也称为<em class="jo"> UI测试</em>)，但是另一方面它们非常慢。</p><h1 id="c9c7" class="ke kf ht bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">如何运行测量测试</h1><p id="a72c" class="pw-post-body-paragraph iq ir ht is b it lc iv iw ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn hb bi translated"><em class="jo">免责声明:这里我假设你已经(或知道)如何在Bitrise上建立一个基本的工作流程。</em></p><p id="683f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在Bitrise上运行<em class="jo">插装测试</em>非常简单，我们有一个专门的步骤可以让你实现这个目的:</p><figure class="li lj lk ll fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lh"><img src="../Images/80827c22adb567aa976b84440da8241f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6UmN3tUaGCiViCkHib4u6Q.png"/></div></div></figure><p id="6a4f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们把重点放在称为<em class="jo"> Android Build UI Test </em>的步骤上(我把它重命名为<em class="jo">Android Build for UI Testing—UI module</em>，我总是重命名步骤以更好地反映它们实际在做什么):它非常简单，你需要放入你想要运行插装测试的模块(在我的例子中是<em class="jo"> ui </em>)和哪个变体(在我的例子中是<em class="jo"> debug </em>)。</p><p id="9a30" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这一步之后，您可以添加步骤<em class="jo">Android虚拟设备测试，c </em>软管<em class="jo">装备</em>作为<em class="jo">测试类型</em>，它将运行所有基于前一步构建的测试。</p><h1 id="285d" class="ke kf ht bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">那么问题出在哪里？</h1><p id="4e60" class="pw-post-body-paragraph iq ir ht is b it lc iv iw ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn hb bi translated">当您需要为不同的模块运行多个插装测试时，问题就来了。</p><p id="f399" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">换句话说:你需要2个(或更多个)<em class="jo">构建用于UI测试</em>步骤和(以及2个或更多个<em class="jo">虚拟设备测试用于Android </em>)。</p><p id="c10d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你尝试这样做，你会得到一个类似这样的错误:</p><figure class="li lj lk ll fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lm"><img src="../Images/59bd26ddb657de6cf9efdc05bc0f2d9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D6jKfkMILfoIZDHjaG9oTg.png"/></div></div></figure><p id="cd8b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是一个已知的<em class="jo">问题。</em>并不是一个真正的问题，是Firebase测试实验室如何工作(它由用于Android s  tep的<em class="jo">虚拟设备测试使用):该步骤为每个构建向Firebase发送一个<em class="jo">构建模块</em>，因为主apk(它是应用程序apk)总是相同的，它将为两个步骤发送相同的<em class="jo">构建模块</em>，抛出提到的错误。</em></p><p id="dfb4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以有这样的东西:</p><figure class="li lj lk ll fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es ln"><img src="../Images/bd06b806d4b15c6c2980728dbb308ca0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bkNSK1SCI8en5fX3gauuxw.png"/></div></div></figure><p id="6d56" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我对2个模块(<em class="jo"> ui </em>和<em class="jo">数据</em>)运行<em class="jo">指令测试</em>的地方会使Bitrise构建失败。</p><h1 id="ab30" class="ke kf ht bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">解决办法</h1><p id="76c1" class="pw-post-body-paragraph iq ir ht is b it lc iv iw ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn hb bi translated">幸运的是，这个问题有一个解决方案:在不同的工作流中运行插装测试。</p><p id="57ca" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在Bitrise中，我们可以从一个工作流触发一个工作流，让我们看看下一个:</p><figure class="li lj lk ll fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lo"><img src="../Images/cd7e362052871b98078243df7a4379f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mwNcATZUxKi1hS165b2DHQ.png"/></div></div></figure><p id="2e72" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">正如您在这里看到的，我们有一个<em class="jo">父</em>工作流，其中3个是从父工作流触发的:</p><ul class=""><li id="d039" class="lp lq ht is b it iu ix iy jb lr jf ls jj lt jn lu lv lw lx bi translated">一个运行我们所有的单元测试</li><li id="40c3" class="lp lq ht is b it ly ix lz jb ma jf mb jj mc jn lu lv lw lx bi translated">一个在我们的<em class="jo">数据</em>模块中运行所有仪器测试</li><li id="005e" class="lp lq ht is b it ly ix lz jb ma jf mb jj mc jn lu lv lw lx bi translated">一个在我们的<em class="jo">展示</em>模块中运行所有仪表化测试</li></ul><p id="f030" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">*您可以从添加了<em class="jo">位上升开始构建</em>步骤的工作流触发另一个工作流</p><p id="f33d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们详细了解一下这一步通常需要什么:</p><figure class="li lj lk ll fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es md"><img src="../Images/20953a2b31260539318114bc03d15661.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x_bddfTftcJUAvYVkr12Wg.png"/></div></div></figure><ul class=""><li id="1b5d" class="lp lq ht is b it iu ix iy jb lr jf ls jj lt jn lu lv lw lx bi translated">一个<em class="jo"> bitrise访问令牌</em>(您可以在bitrise中轻松设置一个)</li><li id="b250" class="lp lq ht is b it ly ix lz jb ma jf mb jj mc jn lu lv lw lx bi translated">我们要触发的工作流的名称</li><li id="89a4" class="lp lq ht is b it ly ix lz jb ma jf mb jj mc jn lu lv lw lx bi translated">我们希望在构建中共享的最终环境</li><li id="20f6" class="lp lq ht is b it ly ix lz jb ma jf mb jj mc jn lu lv lw lx bi translated">等待构建:<strong class="is me">将它设置为true </strong>是很重要的，否则在并行构建中触发插装测试将会导致我们与之前相同的错误</li></ul><p id="20ae" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果这些构建中的任何一个失败，整个父工作流都将失败。这在某些情况下很方便:例如，我们可以在父工作流的末尾添加一个步骤(比如发送一个slack消息，或者上传一个新的Beta版apk ),只有当所有测试都通过了，它才会被执行。</p><h1 id="1c19" class="ke kf ht bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">考虑</h1><p id="c4f6" class="pw-post-body-paragraph iq ir ht is b it lc iv iw ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn hb bi translated">这种方法解决了我们最初的问题，这是我们的主要目的。然而，也有一些缺点:</p><ul class=""><li id="4011" class="lp lq ht is b it iu ix iy jb lr jf ls jj lt jn lu lv lw lx bi translated">您不能在构建中共享整个项目，这意味着您必须为每个工作流(也就是每个测试)克隆整个项目</li><li id="6d85" class="lp lq ht is b it ly ix lz jb ma jf mb jj mc jn lu lv lw lx bi translated">与所有测试都在同一个工作流中运行相比，构建时间将会慢很多</li><li id="7cd9" class="lp lq ht is b it ly ix lz jb ma jf mb jj mc jn lu lv lw lx bi translated">您必须在不同的工作流程中重复相同的步骤，这并不理想</li></ul><p id="646f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">没什么大不了的，但是值得考虑。</p><p id="dffa" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">虽然还有另一种方法，那就是手动设置Firebase测试实验室，并通过Bitrise发送相关命令，但我没有深入研究过。</p></div></div>    
</body>
</html>