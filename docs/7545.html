<html>
<head>
<title>Implementing Web Clients</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">实现Web客户端</h1>
<blockquote>原文：<a href="https://medium.com/swlh/thundering-web-requests-part-1-309177dabe65?source=collection_archive---------57-----------------------#2019-07-03">https://medium.com/swlh/thundering-web-requests-part-1-309177dabe65?source=collection_archive---------57-----------------------#2019-07-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="bb0a" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">雷鸣般的Web请求:第1部分</h2></div><p id="404b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是探索web服务相关技术系列文章的第一篇。它记录了我使用不同技术实现web客户端的观察结果。</p><figure class="jv jw jx jy fd jz er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es ju"><img src="../Images/7f891773bf173f59bc2504d0bea6bfc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*3FoJWYX0b7jFSH6k.jpeg"/></div></div></figure><h1 id="0af0" class="kg kh hi bd ki kj kk kl km kn ko kp kq io kr ip ks ir kt is ku iu kv iv kw kx bi translated">语境</h1><p id="ca4c" class="pw-post-body-paragraph ix iy hi iz b ja ky ij jc jd kz im jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">最近，我想探索web服务技术。我决定通过模拟和处理大量的web请求来进行这种探索。</p><p id="15e1" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">作为这项工作的一部分，其中一项任务是</p><blockquote class="ld"><p id="60ce" class="le lf hi hj lg lh li lj lk ll lm js dx translated">实现一个web客户端，它接受一个URL和一个正整数N作为命令行参数，并向该URL发出N个并发的HTTP GET请求。</p></blockquote><p id="1586" class="pw-post-body-paragraph ix iy hi iz b ja ln ij jc jd lo im jf jg lp ji jj jk lq jm jn jo lr jq jr js hb bi translated">客户机还报告每个HTTP GET请求到URL U所用的时间(延迟),以及N个请求中成功/失败的次数。</p><h1 id="bc6d" class="kg kh hi bd ki kj kk kl km kn ko kp kq io kr ip ks ir kt is ku iu kv iv kw kx bi translated">技术选择</h1><p id="1e31" class="pw-post-body-paragraph ix iy hi iz b ja ky ij jc jd kz im jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">我选择了四种技术来实现客户机的四种变体。</p><p id="cb29" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">影响这些选择的两个常见原因是:</p><ul class=""><li id="4931" class="ls lt hi iz b ja jb jd je jg lu jk lv jo lw js lx ly lz ma bi translated">探索开发web服务相关解决方案的支持。</li><li id="62f1" class="ls lt hi iz b ja mb jd mc jg md jk me jo mf js lx ly lz ma bi translated">探索对程序并发的支持。</li></ul><p id="cb00" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">除此之外，这些选择还受到一些特定于技术的次要原因的影响。</p><ol class=""><li id="7564" class="ls lt hi iz b ja jb jd je jg lu jk lv jo lw js mg ly lz ma bi translated"><a class="ae jt" href="http://www.erlang.org/" rel="noopener ugc nofollow" target="_blank"> Erlang </a>:我没有用过Erlang，我想尝试一下。</li><li id="ea7f" class="ls lt hi iz b ja mb jd mc jg md jk me jo mf js mg ly lz ma bi translated"><a class="ae jt" href="https://elixir-lang.org/" rel="noopener ugc nofollow" target="_blank"> Elixir </a> + <a class="ae jt" href="https://hexdocs.pm/httpoison/readme.html" rel="noopener ugc nofollow" target="_blank"> HTTPoison </a>:在我使用Erlang的内置库构建了客户端之后，我很想看看使用Elixir与使用Erlang在开发体验和执行性能方面是否会有所不同。对HTTPoison的选择相当随意。</li><li id="bf0c" class="ls lt hi iz b ja mb jd mc jg md jk me jo mf js mg ly lz ma bi translated">Go:我以前用过Go，我想用它做更多的事情。</li><li id="2aba" class="ls lt hi iz b ja mb jd mc jg md jk me jo mf js mg ly lz ma bi translated"><a class="ae jt" href="http://kotlinlang.org/" rel="noopener ugc nofollow" target="_blank">kot Lin</a>+<a class="ae jt" href="https://vertx.io/" rel="noopener ugc nofollow" target="_blank">vert . x</a>:我过去使用过这两种技术，我想拥有一个基于常用技术的客户端，即JVM。</li></ol><h1 id="a64a" class="kg kh hi bd ki kj kk kl km kn ko kp kq io kr ip ks ir kt is ku iu kv iv kw kx bi translated">实施选择</h1><p id="3713" class="pw-post-body-paragraph ix iy hi iz b ja ky ij jc jd kz im jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">我想保持源工件和使用源工件的过程简单和容易，同时在使用技术时跳过必要的“障碍”。因此，考虑到客户端的简单性，我将开发变体作为黑客练习，尽量少地使用代码之外的软件工程实践。具体来说，只要不违反上述条件，</p><ol class=""><li id="4b08" class="ls lt hi iz b ja jb jd je jg lu jk lv jo lw js mg ly lz ma bi translated">变体被编码为单个文件，而不遵循社区惯例，例如包、文件夹布局。<br/>例如，Go客户端被编码到一个<em class="mh">主</em>包中，该包存储在顶层文件夹中。类似地，Kotlin客户端既没有嵌入到包中，也没有嵌入到文件夹中。</li><li id="cbf5" class="ls lt hi iz b ja mb jd mc jg md jk me jo mf js mg ly lz ma bi translated">如果一个变体可以被编码成一个脚本并在编译模式下执行，那么它就可以被编码成一个脚本而不需要使用构建脚本。<br/>例如，Erlang客户端被编码成一个单独的脚本文件，可以使用Erlang的<a class="ae jt" href="http://erlang.org/doc/man/escript.html" rel="noopener ugc nofollow" target="_blank"> escript </a>工具编译和执行。类似地，Kotlin客户端被编码为一个单独的脚本文件，可以使用<a class="ae jt" href="https://github.com/holgerbrandl/kscript" rel="noopener ugc nofollow" target="_blank"> KScript </a>进行编译和执行。</li><li id="c295" class="ls lt hi iz b ja mb jd mc jg md jk me jo mf js mg ly lz ma bi translated">如果一个变体需要依赖关系，那么就使用一个工具来获取依赖关系。<br/>例如，由于Elixir客户端依赖于HTTPoison库，所以使用了<a class="ae jt" href="https://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html" rel="noopener ugc nofollow" target="_blank"> Mix </a>构建工具。依赖关系是通过mix.exs (build)文件指定的，mix用于在构建客户端之前下载和编译依赖关系。</li></ol><h1 id="9a0b" class="kg kh hi bd ki kj kk kl km kn ko kp kq io kr ip ks ir kt is ku iu kv iv kw kx bi translated">观察</h1><h2 id="7939" class="mi kh hi bd ki mj mk ml km mm mn mo kq jg mp mq ks jk mr ms ku jo mt mu kw mv bi translated">语言</h2><p id="73ab" class="pw-post-body-paragraph ix iy hi iz b ja ky ij jc jd kz im jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">第一次用Erlang编码很有趣。Erlang中的函数声明无缝地包含了模式匹配，以进行基于值的大小写拆分(而不是依赖于基于标志/选项的条件)。它还支持使用模式匹配将复合值(如结构和列表)解构(投影)到它们的组件中，并能够只挑选感兴趣的组件。我觉得这样既优雅又直观。模式匹配也可以在Elixir的函数声明中起到类似的效果。</p><h2 id="5b06" class="mi kh hi bd ki mj mk ml km mm mn mo kq jg mp mq ks jk mr ms ku jo mt mu kw mv bi translated">并发</h2><p id="7058" class="pw-post-body-paragraph ix iy hi iz b ja ky ij jc jd kz im jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">因为Erlang和Go都有内置的核心特性，可以轻松地产生并发计算并使用消息传递通信，所以调度并发请求很容易。Elixir也是如此，因为它的目标是Erlang的VM。</p><p id="bc1d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">至于基于Vert.x的Kotlin变体，这甚至更容易，因为它的API接受一个回调，当请求完成时将调用这个回调。</p><h2 id="238e" class="mi kh hi bd ki mj mk ml km mm mn mo kq jg mp mq ks jk mr ms ku jo mt mu kw mv bi translated">图书馆和文献</h2><p id="e1b6" class="pw-post-body-paragraph ix iy hi iz b ja ky ij jc jd kz im jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">Erlang的内置库对于这个练习来说已经足够了。我最终使用了核心的httpc库。因为这是我第一次使用Erlang，所以我花了一些时间来理解Erlang的文档模式。虽然文档中使用的术语的额外超链接可以简化导航和搜索，但我真的很喜欢Erlang文档的结构，因为它模仿了Erlang中代码/API和数据的结构。</p><p id="ddc9" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">虽然我可以将Erlang的httpc库与Elixir一起使用，但我决定不这样做，只是为了探索一个Elixir库。虽然HTTPoison的文档很好，但我觉得包含一个完整的示例会更有帮助。这个限制可能是因为我是一个新手。总的来说，我喜欢在一个中心位置(https://hexdocs.pm)存放Elixir库(十六进制包)文档的想法。</p><p id="4043" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">像Erlang一样，Go的内置库对于这个练习来说是相当自给自足的。我最终使用了core <a class="ae jt" href="https://golang.org/pkg/net/http/" rel="noopener ugc nofollow" target="_blank"> http </a>包。我非常喜欢文档的示例部分，因为它有助于快速了解软件包的功能以及如何组合这些功能。</p><p id="b9d6" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">虽然Vert.x在功能上是自给自足的，但我发现它的文档(像JVM生态系统中的其他库一样)有局限性。具体来说，虽然关于“如何使用capability X”的文档很好，但它似乎与相关API的文档“脱节”。此外，考虑到不同API和模块的数量(例如，core vs web)，在API文档中根据名称搜索适当的API既不简单也不容易。我认为这与javadoc风格的文档有更大的关系。[如果你很好奇，比较一下<code class="du mw mx my mz b">httpc</code>包和<code class="du mw mx my mz b">httpc::request</code>方法是如何在Erlang中记录的，以及<code class="du mw mx my mz b">Web</code>模块和<code class="du mw mx my mz b">sendXXX</code>方法是如何在Vert.x中记录的]</p><p id="2810" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">独立于语言之外，我惊喜地发现可以轻松使用web服务的支持。在库方面有很多选择，而且大多数都很容易使用。我想这可能是微服务繁荣的一个原因:)</p><h2 id="9679" class="mi kh hi bd ki mj mk ml km mm mn mo kq jg mp mq ks jk mr ms ku jo mt mu kw mv bi translated">工具作业</h2><p id="304e" class="pw-post-body-paragraph ix iy hi iz b ja ky ij jc jd kz im jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">虽然在Go中构建客户端的工具很简单(例如<code class="du mw mx my mz b">go build</code>)，但我真的很喜欢Kotlin(通过KScript)和Erlang(通过escript)对编译模式下执行脚本的支持。KScript支持通过使用注释来管理依赖关系。这在许多情况下消除了构建文件的负担，这些情况下使用的脚本以简单、快速和短暂等形容词为特征。我在escript中没有找到类似的支持。因此，如果我在Erlang客户机中使用了外部库，那么我对Erlang的体验会有所不同。</p><p id="cc96" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">相比之下，由于Elixir客户机依赖于HTTPoison，所以我使用了Mix工具和一个“构建”文件来捕获依赖关系。虽然文件本身不是问题，但是使用Mix需要像使用任何其他构建工具一样做更多的工作，例如，创建项目，了解各种构建相关文件的相关性，对这些文件进行适当的更改；在下一篇文章中会有更多的介绍。我认为在简单的情况下这是一个不必要的障碍。</p><p id="4810" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">[如果有一种方法可以使用escript来管理依赖项和执行脚本(比如KScript)，那么请告诉我如何使用。]</p><h2 id="a0c6" class="mi kh hi bd ki mj mk ml km mm mn mo kq jg mp mq ks jk mr ms ku jo mt mu kw mv bi translated">电码长度</h2><p id="8d91" class="pw-post-body-paragraph ix iy hi iz b ja ky ij jc jd kz im jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">就LOC而言，Kotlin是最短的实现，其次是Erlang、Go和Elixir。虽然我预期Go客户端会很长，但令我惊讶的是，Elixir客户端也几乎一样长。我不确定这是我如何实现Elixir客户端的产物，还是Elixir的设计和生态系统。</p><h2 id="e116" class="mi kh hi bd ki mj mk ml km mm mn mo kq jg mp mq ks jk mr ms ku jo mt mu kw mv bi translated">代码复杂性</h2><p id="a30a" class="pw-post-body-paragraph ix iy hi iz b ja ky ij jc jd kz im jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">由于任务本身的简单性和调度HTTP请求的丰富库支持，所有的客户机都相当简单。</p><h1 id="1c70" class="kg kh hi bd ki kj kk kl km kn ko kp kq io kr ip ks ir kt is ku iu kv iv kw kx bi translated">源代码</h1><p id="140c" class="pw-post-body-paragraph ix iy hi iz b ja ky ij jc jd kz im jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">所有客户端的代码都可以在<a class="ae jt" href="https://github.com/rvprasad/thundering-web-requests" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上获得。</p><h1 id="4fa4" class="kg kh hi bd ki kj kk kl km kn ko kp kq io kr ip ks ir kt is ku iu kv iv kw kx bi translated">接下来</h1><p id="c423" class="pw-post-body-paragraph ix iy hi iz b ja ky ij jc jd kz im jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">我的下一篇文章将是关于使用不同技术实现web服务 <strong class="iz na"> </strong>的<a class="ae jt" rel="noopener" href="/@rvprasad/thundering-web-requests-part-2-de040873c4da?source=friends_link&amp;sk=c5a574b75d9c9b105d3b2c98185b1506">观察。</a></p><h1 id="11bc" class="kg kh hi bd ki kj kk kl km kn ko kp kq io kr ip ks ir kt is ku iu kv iv kw kx bi translated">笔记</h1><h2 id="02e8" class="mi kh hi bd ki mj mk ml km mm mn mo kq jg mp mq ks jk mr ms ku jo mt mu kw mv bi translated">2019年8月20日:发现Erlang中的http客户端问题</h2><p id="902e" class="pw-post-body-paragraph ix iy hi iz b ja ky ij jc jd kz im jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">在使用客户机评估服务器的过程中，erlang客户机有时会挂起。虽然实现处理了HTTP请求的成功和失败，以及发出HTTP请求的衍生进程的异常失败，但似乎有一个条件没有被涵盖。感谢来自Erlang社区的输入(通过Slack)，我用一个无所不包的处理程序扩展了客户端。有趣的是，这个处理程序在挂起运行期间没有被触发。</p><p id="c10a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，在这一点上，我认为要么Erlang中的httpc库在一些罕见的情况下被破坏，要么该库需要进行适当的配置，以处理客户端可能发出大量并发请求的情况，例如3200。不管怎样，我都不会使用Erlang client来评估服务器。</p></div></div>    
</body>
</html>