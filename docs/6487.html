<html>
<head>
<title>Smuggler and Cove: A PoC for data exfiltration using Scapy.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">走私者和海湾:使用Scapy进行数据泄漏的概念验证。</h1>
<blockquote>原文：<a href="https://medium.com/swlh/smuggler-and-cove-a-poc-for-data-exfiltration-using-scapy-e44649feae6?source=collection_archive---------9-----------------------#2019-06-21">https://medium.com/swlh/smuggler-and-cove-a-poc-for-data-exfiltration-using-scapy-e44649feae6?source=collection_archive---------9-----------------------#2019-06-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/96ce5eab556161b3d4134a40dcbfed2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7x6N_7YocV0BSqIgAUlNoA.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">Bouncing packets for fun, not profit.</figcaption></figure><div class=""/><p id="0fd9" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我一直对秘密渠道和数据走私的概念着迷。几年前，我想出了一个主意，我可以将数据从一个网络偷偷传输到互联网上的另一台机器，而不需要使用TCP包中的序列号直接与那台机器对话，并将包从第三方服务器反弹到伪造的源IP系统。我和一些朋友讨论过这个问题，甚至画了一张它如何工作的图表，并把它展示给我的一个有坚实网络背景的朋友，他说这个想法似乎是可行的。(谢谢凯尔！)</p><p id="c9c2" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">快进一年左右，在参加GCIH课程时，我了解到这个概念并不新鲜。(当然不是，事实证明我并没有那么有创意。)Covert_TCP是个东西。谁知道呢？显然不是我。</p><p id="4ba1" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">无论如何，为了从实践的角度理解秘密渠道，并在假期有很多空闲时间，我决定看看我是否可以发送一些秘密数据。目标是通过将数据包从第三方机器上弹回而将消息发送到远程机器，这样接收端的所有传入数据包都不会看到原始系统。如果您能够设置接收系统从合法的可信服务器中嗅探数据，甚至从监视您的数据包的公司内部的机器中泄漏数据，这将是一种有趣的C2机器的方式。注意:如果您的网络设备被设置为丢弃所有包含不属于您的网络的源IP的传出数据包，这种方法很容易被数据渗透所击败。</p><p id="a2f9" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw js">目标:</strong>创建一个客户端，它可以将数据偷偷传送到互联网上的第三方系统，而无需直接与它对话，并在数据包中隐藏信息。这是通过伪造每个数据包的源IP，并在每个SYN数据包的ISN中隐藏数据来实现的。(走私者)</p><p id="eb1e" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw js">目标:</strong>创建一个监听器，它可以接收来自世界各地不同服务器的数据，并将它们重新排序以形成消息/命令。(小海湾)</p><p id="26e8" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw js">高级目标:</strong>依靠可信域内不存在的服务器，通过隐蔽通道建立双向通信。(稍后将详细介绍)</p><p id="d2e2" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这些目标需要几样东西:</p><ol class=""><li id="8a76" class="jt ju hx iw b ix iy jb jc jf jv jj jw jn jx jr jy jz ka kb bi translated">一个无声的监听服务器。这个服务器监听来自外界的SYN/ack，并且知道这些是走私者发送的消息的一部分。Cove服务器将捕获这些数据包，并将它们重新组织成一条消息，或者更不可思议的是，一条命令？也许吧？由…改编</li><li id="04e1" class="jt ju hx iw b ix kc jb kd jf ke jj kf jn kg jr jy jz ka kb bi translated">一种新的“协议”。使用SYN包的ISN，我们只有4个字节的数据要处理，这意味着我们必须创建一种全新的语言，以便客户端和服务器可以在这个有限的空间中进行通信。最初的想法是创建一种新的“走私SYN ”,这是发送到Cove服务器的初始序列，然后告诉它醒来并注意——有数据包传入！监听这些数据包的美妙之处在于不需要打开套接字。服务器可以悄悄地嗅探来自野外的ack，发回它们的rst，并在没有“活动”的情况下形成数据。例如，第一个ISN可能是4294967295，这将强制SYN/ACK(因此rst)为0。(这将序列号包装回0)。如果服务器看到ACK为0，它知道是时候醒来注意了，有一个请求进来了。</li></ol><figure class="ki kj kk kl fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es kh"><img src="../Images/0daef9ee8ef7ff30348d351929dc57da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_VxKxGf0b3lfH377zbUNkA.png"/></div></div></figure><p id="75e3" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">无论这个“走私SYN”是用什么方法发送的，这个想法都有希望是明确的。知道我们有4294967294个其他数字要处理，我们可以创建一个完整的代码集来表示从客户端到服务器的任何内容，如果我们愿意，还可以从服务器到客户端创建一个完全不同的代码集。我们甚至可以构建填充系统，其中预先确定的代码代表某些功能，就像从LDAP服务器向浏览器发送404或错误49(无效凭证)。</p><figure class="ki kj kk kl fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es km"><img src="../Images/7452c2d70970a86d0f95225183be3474.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2azLwmv5QoCU8kwIPURyGA.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">Yeah, it’s MS Paint. Don’t judge me!</figcaption></figure><h1 id="8582" class="kn ko hx bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated"><strong class="ak"> <em class="ll">开始</em> </strong></h1><p id="e20b" class="pw-post-body-paragraph iu iv hx iw b ix lm iz ja jb ln jd je jf lo jh ji jj lp jl jm jn lq jp jq jr hb bi translated">所以我们在这里。这个概念很简单，但是我需要为自己建立一个概念验证，看看我是否能做到。我首先用Perl构建了一个脚本来生成原始包，它工作得很好，但是不像我希望的那样健壮。我也用C语言编写了一些基本的包，但这就像是我自己建造道路，只是为了在上面行驶。</p><p id="ec8f" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">经过一些研究，我了解了Scapy，这是一个非常棒的Python包制作工具，它使制作包变得非常容易。Scapy允许你像乐高积木一样或以一种感觉合乎逻辑的方式构建包。</p><p id="0cc8" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">拿你的第二层框架；您期望以太网层、IP层、TCP层和标准TCP通信的有效载荷。在Scapy中，您可以使用缺省值构建一个包，只需执行以下操作:</p><p id="8e20" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw js"><em class="lr">&gt;lyr _ two _ packet = Ether()/IP()/TCP()/load</em></strong></p><p id="b7dc" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw js"><em class="lr">&gt;sendp(lyr _ two _ packet)</em></strong><em class="lr"/># # sendp()是针对第二层的！</p><p id="add1" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw js"><em class="lr">&gt;lyr _ three _ packet = IP()/TCP()/load</em></strong></p><p id="90ad" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw js"><em class="lr">&gt;send(lyr _ three _ packet)</em></strong><em class="lr"/># #注意这是send()，不是sendp()！</p><p id="e6a0" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果您不考虑以太层，Scapy将在send()中广播以太网。</p><p id="4971" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这些函数的默认设置不会直接工作，但是结构会存在。更改数据包的属性非常简单:</p><p id="06f1" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw js"><em class="lr">&gt;lyr _ two _ packet[IP]。src = " 192 . 168 . 1 . 2 "</em>T27<em class="lr">T29】或者</em></strong></p><p id="0bbb" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw js"><em class="lr">&gt;lyr _ two _ packet【TCP】。seq=11111111 </em> </strong> <em class="lr"> </em>或者</p><p id="2d68" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw js"><em class="lr">&gt;【mytcp = TCP(sport = 20，dport=80，seq=11111111) </em> </strong> <em class="lr"> </em>然后将那一层叠加在其他层上，如上。请注意,“seq”值是奇迹发生的地方。</p><figure class="ki kj kk kl fd hk er es paragraph-image"><div class="er es ls"><img src="../Images/0c598c79d55a552b90388e95c3290770.png" data-original-src="https://miro.medium.com/v2/resize:fit:774/format:webp/1*8tBOhQ8WnkPkAKLJGBxqnw.png"/></div><figcaption class="hr hs et er es ht hu bd b be z dx">A packet using show2(). MAC addresses have been removed to protect the innocent.</figcaption></figure><p id="98c7" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">一旦构建了包，就可以使用show()或show2()查看它。我推荐show2()，因为它将向您展示组装好的数据包、校验和等等。Protip:如果你组装你的数据包，然后改变一个属性，你可能需要强制scapy重新计算你的校验和。您可以通过删除校验和，然后再次调用数据包，强制其重建来实现这一点。</p><p id="8573" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw js"><em class="lr">&gt;del lyr _ two _ packet[IP]。chk sum</em>T15】</strong></p><p id="d586" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw js"><em class="lr">&gt;del lyr _ two _ packet【TCP】。chk sum</em>T19】</strong></p><h1 id="41be" class="kn ko hx bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">让我们建造</h1><p id="7b31" class="pw-post-body-paragraph iu iv hx iw b ix lm iz ja jb ln jd je jf lo jh ji jj lp jl jm jn lq jp jq jr hb bi translated">我们需要做的第一件事是想出一种方法，在尽可能小的空间里进行尽可能多的交流。由于我们在SYN包的ISN中只有10个字符要处理，(实际上只有9个，你会明白为什么)，我们需要想出一个简单的方法来构造原型。我不想在这上面花太多时间，所以我决定在一个9位数的空间中使用6/3的划分，前6位可以用于订购号，后3位用于字符本身。换句话说，我们可以传输多达999，999个单独的字符，然后再重新开始新的一批数据。最后3位数用于翻译我们要发送的字符，方法是将字符传递给python的ord()函数。ord()只是把一个字符翻译成一个数字，chr()把一个数字翻译成一个字符(256是允许的最大值。)</p><p id="7cfb" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw js"><em class="lr">im _ now _ a _ number = ord(im _ a _ character)</em></strong></p><p id="eb89" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw js"><em class="lr">im _ now _ a _ character = chr(I _ was _ a _ number)</em></strong></p><p id="928b" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们最终得到的是这样的结果:</p><figure class="ki kj kk kl fd hk er es paragraph-image"><div class="er es lt"><img src="../Images/5181f7e75371eb5af45284d3530be445.png" data-original-src="https://miro.medium.com/v2/resize:fit:754/format:webp/1*xZXUffqelKfQy0g4Q-m46g.png"/></div><figcaption class="hr hs et er es ht hu bd b be z dx">A custom sequence number</figcaption></figure><p id="f950" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">9115或000009115。把它分成6/3组，我们得到000009 115。前6个数字是顺序，后3个是字符。在这种情况下，字母“s”是本次传输中发送的第9个字符。</p><p id="cc76" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们不使用最左边的空格是因为它的上限是4。如果您还记得，最大允许的ISN是4294967295，所以我们不能在最左边的位置跳过4。我们可以变得狡猾，如果我们愿意，可以将它用作“带符号”位，甚至是某种类型的4位开关！</p><p id="cdd6" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">接下来，我们需要一个我们想要退出的服务器列表。在这种情况下，我会从web服务器上反弹，因为它们很容易找到，我们知道它们会返回给我们。</p><p id="c012" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">当所有这些放在一起时，变速器看起来像这样:</p><figure class="ki kj kk kl fd hk er es paragraph-image"><div class="er es lu"><img src="../Images/73c6742e20a793c273b308628af1f4f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:976/format:webp/1*rWr7s9bqc6iNoIKuCLNIMw.png"/></div><figcaption class="hr hs et er es ht hu bd b be z dx">Hiding characters in SYN packets!</figcaption></figure><p id="0cb1" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">太好了！我们刚刚在发往世界各地的SYN数据包的ISN中走私了一些数据。每个服务器捕获我们的SYN，并用一个+1递增的序列号进行SYN/ACK。</p><figure class="ki kj kk kl fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lv"><img src="../Images/b752251048a596224e2af3be5766f1da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a7CgmSl0-D_a4-Enideeuw.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">tcpdump | grep ack</figcaption></figure><p id="0795" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">请注意，ack的到来并不像预期的那样有序，这就是为什么我们需要一个排序系统。在这个例子中，你看不到的是来自这些服务器的重新传输。由于反弹，Cove machines内核并不期待SYN/ACK，而是发送一个RST或不回复——这取决于内核。你可以期待每台机器的多次重新传输，直到他们放弃。</p><p id="f5db" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在我们需要建立一个更好的方法来捕捉和组织数据。</p><p id="8761" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">回到斯卡帕。</p><h1 id="56c2" class="kn ko hx bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">用Scapy构建嗅探器</h1><p id="51ff" class="pw-post-body-paragraph iu iv hx iw b ix lm iz ja jb ln jd je jf lo jh ji jj lp jl jm jn lq jp jq jr hb bi translated">Scapy有一个很好的函数，叫做sniff()。它做你期望它做的事。该函数的一个很好的特性是“store”参数，当设置为0时，它不会在数据包到达时保存数据包，而是将它们流式传输到您传递给它的任何回调(prn参数)值。</p><p id="561b" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">例如:<strong class="iw js"> <em class="lr"> sniff(iface="eth0 "，prn=p_catch，filter="tcp "，store=0) </em> </strong></p><p id="1674" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这将把每个TCP包发送到一个名为p_catch的函数，在那里你可以分解它，或者对它做任何你想做的事情。这对于编写您自己的id非常方便！在我的例子中，我捕捉数据包并断开它们的ISN，这样我就可以捕捉到秘密消息。(请注意，您可以将过滤器更改为您想要监视的任何类型的数据包— tcp、icmp等。完全移除过滤器会捕获所有东西。)</p><p id="6f3d" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">所以现在我们把所有的TCP包都发送给p_catch。p_catch是做什么的？它首先检查数据包是否有TCP层—<strong class="iw js"><em class="lr">if(p . has layer(TCP)):</em></strong></p><p id="aa62" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">接下来，它取出数据包的ack值。超级容易！</p><p id="c685" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw js"><em class="lr">&gt;ack _ n = p . getlayer(TCP)。确认</em> </strong></p><p id="2b9f" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">没错。真的就这么简单。Scapy太棒了！</p><p id="5c54" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在，我们从值中减去1，分离出字符和顺序。请注意，通过将字符值放在最右边，我们可以很容易地从中减去1，然后将其弹出，传递给chr()并完成。</p><p id="4de5" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">下面是完成后的样子:</p><figure class="ki kj kk kl fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lw"><img src="../Images/5ed8f8010500e280d5eee626940d76d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BaeHsFxV6KQFGjmZKHvl8w.png"/></div></div></figure><p id="d152" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在我们只需重新排列信息，去掉RTX，就大功告成了。在不知道来源的情况下成功发送到第三方系统的消息！</p><p id="e5b1" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我认为传输速率在300到600波特之间。速度不快，但绝对隐秘。</p><p id="fca4" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果你仔细想想，你已经可以用它做各种事情了，但更有趣的是双向交流。我现在将简要地讨论这个主题的一些想法，但需要更多的研究和更好的实验室环境来构建它，这是我目前无法获得的。</p><h1 id="7ca0" class="kn ko hx bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">建立双向沟通的理论</h1><p id="1609" class="pw-post-body-paragraph iu iv hx iw b ix lm iz ja jb ln jd je jf lo jh ji jj lp jl jm jn lq jp jq jr hb bi translated">让我们假设你有一栋房子，你信任来自亚马逊的包裹。假设您有一个看门的保镖，它还可以过滤/阻止来自世界上不受信任的地方的任何包裹。我们知道这个保镖是防火墙。假设保镖通常会扔掉来自不可信来源的任何包裹，并且假设保镖只接受来自亚马逊的包裹，如果他们知道你首先向亚马逊发送了包裹，并且正在期待返回包裹。</p><p id="0c2e" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果你让房子里的一个人在预定的时间，比如下午5点，决定将一个包裹发送到亚马逊的校园，但发送到他们校园内不存在的一栋建筑，会怎么样？保镖检查外发包裹，看到的是“厕所部，亚马逊”，确认一下，就在路上发，等待亚马逊发回包裹。突然来了一个包裹，说是亚马逊厕所部门的，门卫让它进来。</p><p id="5ecb" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">就这样，一个带有伪造来源的包裹到达了目的地，被允许进屋。</p><p id="3c9f" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">目前，许多C2检测都是基于重复出现的时间(例如，通过反向外壳)，到达一些坏人的域并收集命令在被利用的机器上执行。坏人域名可以看到和阻止。如果一个重复出现的时间被发送到受信任公司范围内的受信任IP会怎样？“嗯，我们看到每5分钟就有一个随机的ping回应请求/回应回复进入Google.com的IP地址范围。那是怎么回事？”这种情况下的假设是不存在这样的服务器，但是域本身是可信的。攻击者利用这一点，伪造一个带有正确的预期校验和的数据包。TCP通过发送带有随机序列号的SYN/ACK来防止此类攻击，发送方必须第三次重复该序列号以进行双向验证。ICMP没有。ICMP只依赖于通过校验和与回应请求相等的有效载荷——我想是<em class="lr"/>。这就是我的知识开始不足的地方，所以如果有人知道答案，请告诉我！</p><p id="5da1" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我的理解是，ICMP回应请求与有效载荷一起发送，回应应答必须包含相同的有效载荷，但带有0标志，而不是8。但是，这个有效载荷是通过适当的校验和检查的，还是由有效载荷本身检查的？这是在内核级完成的，还是由深度包检测防火墙完成的？如果防火墙通过校验和允许有效载荷，那么是否有可能用消息覆盖有效载荷的某些部分并保持校验和？</p><p id="0aa2" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">例如:\x00\x00\x00\x00变成\xde\xad\xbe\xef？</p><p id="d4a9" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果上述情况属实，那么双向通信就建立起来了，而发送方却不为人所知。</p><p id="3127" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果你有这个问题的答案，或者我在某些方面有所偏差，请告诉我你的想法。赞赏评论！</p><p id="5032" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">黑客快乐！</p></div></div>    
</body>
</html>