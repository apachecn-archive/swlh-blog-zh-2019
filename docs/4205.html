<html>
<head>
<title>Jumping Between Front-End and Back-End (React and Ruby on Rails)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在前端和后端之间跳转(React和Ruby on Rails)</h1>
<blockquote>原文：<a href="https://medium.com/swlh/jumping-between-front-end-and-back-end-react-and-ruby-on-rails-ee05ecfc7b6#2019-05-29">https://medium.com/swlh/jumping-between-front-end-and-back-end-react-and-ruby-on-rails-ee05ecfc7b6#2019-05-29</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="f931" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">背景</h1><p id="07de" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">作为一个blooming全栈开发人员，需要对前端代码和后端代码有一个透彻的理解。对于我的例子，前端代码是React，一个基于Javascript的框架，后端代码是Ruby on Rails，一个基于Ruby的框架。虽然理解我正在使用的编程语言/框架很重要，但我也需要完全理解前端如何与后端代码通信。不然我真的是全栈开发者吗？</p><h1 id="c17d" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">React(和普通Javascript)</h1><p id="fb3e" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">React是前端代码的框架，这意味着它直接与客户端交互。客户端可能想要输入来自后端服务器的新信息，通常是一个API，这意味着在我们前端代码的某个地方，我需要向后端服务器发出请求，以给出客户端发布的特定信息。在React中，幸运的是在普通Javascript中，实现这一点的方法是一个fetch请求。这里的链接<a class="ae kb" href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch" rel="noopener ugc nofollow" target="_blank">将提供获取请求的完整文档。以下代码是上述请求的一个示例:</a></p><figure class="kc kd ke kf fd kg"><div class="bz dy l di"><div class="kh ki l"/></div></figure><p id="5dd9" class="pw-post-body-paragraph jd je hi jf b jg kj ji jj jk kk jm jn jo kl jq jr js km ju jv jw kn jy jz ka hb bi translated">第一个参数是我发出请求的URL，而第二个参数是我发出的请求的类型。在headers hash中，对于“Content-Type”，我发送的数据类型是JSON格式。主体散列是我发送的数据本身。对于JSON.stringify()，这个<a class="ae kb" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify" rel="noopener ugc nofollow" target="_blank">链接</a>解释了这个函数的作用。现在我知道我发送的数据本身以及它的格式。接下来的问题是，后端服务器会接受这个吗？</p><h1 id="6d57" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">Ruby on Rails</h1><p id="42d4" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在大多数情况下，如果您使用现有的服务器，应该有一个README文件，指导开发人员如何将特定数据和数据本身格式化为后端服务器通常接受的格式。对于这个例子，因为我用Ruby on Rails从头开始创建了一个API，所以我可以自由选择要接收的数据类型，假设Ruby on Rails有这个能力。到目前为止，我见过的最常见的格式是JSON格式。为了简单起见，我遵循了RESTful routes约定，在这里可以更详细地解释<a class="ae kb" href="https://guides.rubyonrails.org/routing.html" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="25d3" class="pw-post-body-paragraph jd je hi jf b jg kj ji jj jk kk jm jn jo kl jq jr js km ju jv jw kn jy jz ka hb bi translated">在上面的fetch示例中，在第一个参数的末尾，它以“/students”结尾，而第二个参数中的方法(通常也称为HTTP动词)是“POST”。基于RESTful路由，这用于创建一个新学生(如客户端所期望的)。然后，这个RESTful路径将进入我的学生控制器，并进入“创建”操作，如下所示:</p><figure class="kc kd ke kf fd kg"><div class="bz dy l di"><div class="kh ki l"/></div></figure><p id="d1fd" class="pw-post-body-paragraph jd je hi jf b jg kj ji jj jk kk jm jn jo kl jq jr js km ju jv jw kn jy jz ka hb bi translated">现在，信息(名字:“John”，姓氏:“Smith”)被传递到我的后端服务器，下一步是在后端服务器中创建和持久存储这些数据，如下所示:</p><figure class="kc kd ke kf fd kg"><div class="bz dy l di"><div class="kh ki l"/></div></figure><p id="0e91" class="pw-post-body-paragraph jd je hi jf b jg kj ji jj jk kk jm jn jo kl jq jr js km ju jv jw kn jy jz ka hb bi translated">您可以假设一个学生模型已经存在并且运行正常。</p><p id="0099" class="pw-post-body-paragraph jd je hi jf b jg kj ji jj jk kk jm jn jo kl jq jr js km ju jv jw kn jy jz ka hb bi translated">信息被传递到后端服务器并存储在params散列中。对于这篇博文的相关性，您只需要知道params hash内置于Ruby on Rails中，它充当将任何输入信息传递给Rails控制器的媒介。</p><p id="de32" class="pw-post-body-paragraph jd je hi jf b jg kj ji jj jk kk jm jn jo kl jq jr js km ju jv jw kn jy jz ka hb bi translated">在第4行中，创建了一个新学生，并将其保存在API中，存储为变量@student。在第5行中,@student变量被呈现为JSON格式。您可以将此视为来自后端服务器的“响应”。尽管第5行无论如何都不是必需的，但是提供某种“响应”作为创建成功(或失败)的确认通常是一个好的实践。这种“响应”现在可以在前端进行操作。我们不需要为此创建一个新函数，而是扩展我们的fetch示例来实现。</p><figure class="kc kd ke kf fd kg"><div class="bz dy l di"><div class="kh ki l"/></div></figure><p id="75ff" class="pw-post-body-paragraph jd je hi jf b jg kj ji jj jk kk jm jn jo kl jq jr js km ju jv jw kn jy jz ka hb bi translated">第12–17行是。then()函数可以按照我想要的方式处理数据。一个重要的注意事项是Rails示例中的第5行“render json: <a class="ae kb" href="http://twitter.com/student" rel="noopener ugc nofollow" target="_blank"> @student </a>”，以及fetch示例中的第4行“Accept”:“application/JSON”。在Rails示例中，我明确声明将@student信息呈现为JSON格式。在fetch示例中，头散列的一个键是“Accept”，其值是“application/json”。这个键值对允许fetch接收JSON格式的数据。这允许从后端服务器到前端的通信在彼此之间传输信息。</p><h1 id="2ea2" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">抽象前端和后端流程</h1><p id="27bc" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我让React和Rails相互通信的过程可以在任何前端和后端之间进行抽象。每一步也可以与我的例子相关联。</p><p id="ce01" class="pw-post-body-paragraph jd je hi jf b jg kj ji jj jk kk jm jn jo kl jq jr js km ju jv jw kn jy jz ka hb bi translated"><strong class="jf ko">前端到后端:</strong></p><ol class=""><li id="5d3c" class="kp kq hi jf b jg kj jk kk jo kr js ks jw kt ka ku kv kw kx bi translated"><strong class="jf ko">我的前端如何发送信息？</strong>在React中，这可以通过“POST”方法通过fetch发送。</li><li id="4549" class="kp kq hi jf b jg ky jk kz jo la js lb jw lc ka ku kv kw kx bi translated">我的后端服务器接收什么格式？ Rails可以接收JSON格式的信息。</li><li id="47b9" class="kp kq hi jf b jg ky jk kz jo la js lb jw lc ka ku kv kw kx bi translated"><strong class="jf ko">我的前端能否将信息转换成适合后端服务器的格式？</strong>是的，通过头:{ " Content-Type ":" application/JSON " }在我的获取中。</li><li id="6532" class="kp kq hi jf b jg ky jk kz jo la js lb jw lc ka ku kv kw kx bi translated"><strong class="jf ko">我的后端服务器如何接收信息？</strong>在Rails中，它将信息存储在params散列中。</li></ol><p id="8bf9" class="pw-post-body-paragraph jd je hi jf b jg kj ji jj jk kk jm jn jo kl jq jr js km ju jv jw kn jy jz ka hb bi translated"><strong class="jf ko">后端到前端:</strong></p><ol class=""><li id="edfe" class="kp kq hi jf b jg kj jk kk jo kr js ks jw kt ka ku kv kw kx bi translated"><strong class="jf ko">我的前端接收什么格式？</strong> React可以通过头接收JSON格式的消息:{"Accept": "application/json"}。</li><li id="3be7" class="kp kq hi jf b jg ky jk kz jo la js lb jw lc ka ku kv kw kx bi translated">我的后端服务器能把信息转换成适合我的前端的格式吗？可以，通过render json: @student。</li><li id="6265" class="kp kq hi jf b jg ky jk kz jo la js lb jw lc ka ku kv kw kx bi translated"><strong class="jf ko">前端如何接收信息？作为我取完东西后的承诺。</strong></li></ol><h1 id="46f8" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">关键外卖</h1><p id="f660" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在很大程度上，任何可交付成果都可以被抽象和分解成步骤。每一步都应该有一个清晰简洁的“迷你可交付物”,它构建到原始的可交付物中。如果“最小交付”是不可能的，仔细检查你的假设，如果失败了…总是有堆栈溢出！</p></div></div>    
</body>
</html>