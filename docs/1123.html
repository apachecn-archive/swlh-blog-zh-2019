<html>
<head>
<title>Navigate the deepest parts of JavaScript- Closures [1/10]</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">浏览JavaScript的最深处——闭包[1/10]</h1>
<blockquote>原文：<a href="https://medium.com/swlh/navigate-the-deepest-parts-of-javascript-closures-1-10-a4214680b6f5?source=collection_archive---------8-----------------------#2019-02-20">https://medium.com/swlh/navigate-the-deepest-parts-of-javascript-closures-1-10-a4214680b6f5?source=collection_archive---------8-----------------------#2019-02-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/77a0817fe374c448fbe2475717c2bb27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1bBZnX9uHBX_YSEU2Cng_A.jpeg"/></div></div></figure><p id="24bf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">作为初学者，我是如何破解困难的JS概念的。</p><p id="c881" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我过去常常想知道JavaScript是什么(我现在仍然想知道！).几年前，当我开始我的程序员职业时，首先是PHP开发人员，然后是Python程序员，我只从前端人员那里听说过JavaScript。最终，在我的眼皮底下，JavaScript摆脱了所有的架构限制，我也阅读了关于它如何被用于服务器端编码的博客。然后JavaScript突然无处不在——无所不在，从网站到灯泡——就像Java曾经那样，在丑陋的甲骨文出现并吞噬它之前。我经常想知道为什么这是一个悖论——同时是世界上最受欢迎和最受讨厌的语言；存在于黑白相交的灰色区域内。</p><p id="75c0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">几年后，我现在在这里，冒险进入JavaScript，写下一些主题，我希望在我开始的时候已经得到了关于这些主题的建议和课程。我不得不查阅大量资料来理解一些概念。来自贫困家庭；但是除了大学里的一些项目之外，我没有真正的Java经验，我很难平静地理解基于原型的JavaScript应用程序的结构。我写下这些来帮助任何正在经历同样旅程的人。这不是火箭科学，但我希望它能帮助你。</p><p id="8e75" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我假设阅读它的人对JavaScript有基本的了解。</p><p id="fe5c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在让我们冒险进入闭包。</p><p id="40de" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在正式开始使用闭包之前，我希望你理解什么是<em class="jo"> Scop </em> e，什么是JavaScript中的<em class="jo">垃圾收集</em>。</p><h1 id="79b8" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">范围。</h1><p id="67fc" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">作用域是指程序中可以看到或使用变量的区域。换句话说，变量的可见性。范围的重要性增加了，因为JavaScript引擎必须有一种有效管理内存的方法。显然，它可以让用户销毁不再使用的物品。但是它怎么能信任人类呢？我们会忘记，无知对我们来说是福。</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ks"><img src="../Images/2c187d3a6867d5c289577ef9fd4e7636.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vqtmqdxK4CZXscZq4eOsqA.jpeg"/></div></div></figure><p id="7f70" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">雪上加霜的是，与C语言不同，ECMAScript缺少访问内存管理的特定接口。这意味着没有API。这意味着程序中的内存管理权限被传递给引擎本身。这意味着，如果我们搞砸了，再多的程序员黑魔法也救不了我们。</p><p id="4cfb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们搞砸的结果？分配的对象记录下内存，就像陷入交通堵塞的纽约市车道。无论你试图挤多少辆车，车道都会停下来，然后你会有一个像《权力的游戏》婚礼一样红的控制台。</p><p id="b39a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jo">你有一个堆内存不足的场景。</em></p><h2 id="b0d7" class="kx jq hi bd jr ky kz la jv lb lc ld jz jb le lf kd jf lg lh kh jj li lj kl lk bi translated"><strong class="ak">什么是垃圾收集？</strong></h2><p id="04e7" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">该程序不能记录整个内存堆，因为它将未使用的变量或对象保存在内存中。这意味着，它需要有一个聪明的方法来删除超出范围的变量。这就是垃圾收集器的用武之地，它的工作是跟踪内存分配，以便发现何时不再需要一块已分配的内存。但这是最难的部分。在所有的高级和低级语言中，这个过程不过是一种近似；因为一般的问题是算法无法判定的。这个问题要么通过收集不存在引用的所有对象来解决，要么通过标记和清除算法来解决，该算法将清除所有不可到达的分配。在引擎盖下，每个引擎都有自己的垃圾收集试探法，但它们基本上都在做其中之一，或者两者都做。V8 JavaScript优化引擎的组件——为V8提供动力的全代码和曲轴——从那时起变得更加智能，使用其他更智能的方法来收集垃圾。(完整的codeGen和曲轴已被前一年的<em class="jo">点火和涡轮风扇</em>取代，V8的新解释器和优化编译器。他们在去年推出了V8 5.9)</p><p id="13ac" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是，当我们通过不让垃圾收集器收集某些超出范围的对象而显著提高效率时，会发生什么呢？</p><p id="8977" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这就是终结的由来。</p><p id="af2c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们想象以下场景。</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ll"><img src="../Images/11e9c898f8cb4cf6de2ec13bf578ae75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C42rQELqVwDx06WgPk6dsQ.png"/></div></div></figure><p id="552f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里，函数调用结束后，调用栈弹出函数语句。垃圾车都进来了，准备拖走你的孤儿对象，函数中声明或使用的任何对象都将被杀死和收集，然后释放到堆池中，供其他变量生存和发展。</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ks"><img src="../Images/af3e7e3b5477527025a7671c69883747.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nQ7LJcfjF1uSOTB_UwVKbg.jpeg"/></div></div></figure><p id="0ffb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是嘿，停下来想想函数结束后<em class="jo"> outer_var1 </em>的状态？你可能会问，你为什么在乎？它只是一个函数范围内的变量，在<em class="jo">外部函数</em>运行后，它在哪里？没关系。反正不能用。反正对我们没用。但是让我们稍微修改一下代码，看看这会把我们引向何方。</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ll"><img src="../Images/af5c758b3cc913c4c6c56e10ea3f18a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p-QAt4lVu9h8dG3vSsS8pg.png"/></div></div></figure><p id="e578" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你打印出存储在sampler中的对象的类型，你会得到类型是" function"。那又怎样？你可能会问。函数是JavaScript中的一级公民，可以被传递或从函数返回。但是这里需要注意的是，当内部函数返回时，它创建了一个新的作用域——一个<strong class="is lm"> <em class="jo">闭包作用域</em> </strong>，它允许我们在函数退出后访问一个函数作用域的变量。您可以调用sampler函数，它可以访问变量<em class="jo"> outer_var1 </em>，<strong class="is lm">，即使<em class="jo"> outerFunction </em>已经存在。</strong></p><p id="c93d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">那么垃圾车会怎么样呢？让我们看看下面会发生什么。</p><ol class=""><li id="30e2" class="ln lo hi is b it iu ix iy jb lp jf lq jj lr jn ls lt lu lv bi translated">调用<em class="jo">外部函数()</em>。</li></ol><p id="ff4e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">2.它创建一个新的执行上下文，并将其绑定到“this”。</p><p id="d674" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">3.它将函数作用域变量<em class="jo"> outer_var1 </em>声明为10。</p><p id="a3e0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">4.它返回<em class="jo"> innerFunction() </em>，存储在sampler变量中。</p><p id="a598" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">5.从调用堆栈中弹出<em class="jo">外部函数</em>。</p><p id="aecc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">6.垃圾车来拖走了<em class="jo">外部函数</em>的剩余部分，并且变量<em class="jo"> outer_val1 </em>也将被收集。</p><p id="5792" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是，令人遗憾的是，舒舒服服地坐在内部函数中是对外部变量的引用，防止它被收集。</p><p id="4e09" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jo">var sum = outer _ var 1+inner _ var 1；</em></p><figure class="kt ku kv kw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ks"><img src="../Images/2242b473c8894f4375d6d310f946103e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7G-Khsz-MWDLWD-17yQHvw.jpeg"/></div></div></figure><p id="5a0e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is lm">在现实生活中，我们可能需要在哪些地方使用闭包？</strong></p><p id="ab2d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">众所周知，JavaScript是一种动态类型的函数式编程语言。当运行在强大的引擎上时，比如Google的V8，比如node.js和React，JavaScript变得非常强大。说它是纯功能性的是错误的。在闭包的帮助下，这种语言已经超越了无数的规范；我们可以在JavaScript中模拟面向对象的行为。闭包主要用于，</p><ol class=""><li id="4554" class="ln lo hi is b it iu ix iy jb lp jf lq jj lr jn ls lt lu lv bi translated">通过封装函数和变量来模拟JavaScript中的类行为——模块模式。</li></ol><p id="4ac9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">2.功能工厂。</p><p id="a82b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">3.记忆化。</p><h1 id="4a80" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">#1:记忆化:案例研究。</h1><p id="4913" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">让我们考虑下面的例子。目标是写一个函数，接受一个数n，并输出第n个质数。这不是一个理想的例子，因为这种情况不会在日常生活中出现。但这个例子是一个完美的例子，但当它发生时，你不需要站在黑暗的一边。</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lw"><img src="../Images/d106180c469a26d7d6a8174fa2d48ee3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r0Kc7XjG_z_20agWXfNgJw.png"/></div></div></figure><p id="8fc5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">变量current保存我们当前正在检查是否是质数的数字。变量计数器保存我们到目前为止发现的素数的总数。质数数组是找到的质数的实际列表。</p><p id="a110" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这种情况下，如果您注意到，变量current、counter和prime在<strong class="is lm"><em class="jo">search nth prime</em></strong>函数的词法范围内。它们是控制主回路状态的控制变量。当函数存在时，这些控制变量被垃圾收集器收集走。</p><p id="f80b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你说“谢天谢地”。</p><p id="0d96" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，随着n值的增加，计算量会逐渐变大。</p><p id="1cdb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">尝试调用searchNthPrime(10000)，它给出104729，这是第10000个素数。</p><p id="0587" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在再次调用该函数，但这次传递10001，如searchNthPrime(10001)</p><p id="7f1c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">输出数字104743仍然需要几秒钟。</p><h2 id="e895" class="kx jq hi bd jr ky kz la jv lb lc ld jz jb le lf kd jf lg lh kh jj li lj kl lk bi translated">有点不对劲。</h2><p id="d279" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">即使我们计算第10000个质数，像<em class="jo"> searchNthPrime(10000) </em>一样，下一次我们越过<em class="jo"> searchNthPrime(10001) </em>时，函数会从头迭代一遍。所以你们问自己。<em class="jo">不！JavaScript引擎必须足够聪明，能够理解我们可能不需要从头开始。不管怎样，它必须足够聪明，以便为下一次记忆控制变量。</em></p><p id="2c13" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">是啊。他们知道了。这就是他们创建闭包作用域的原因。</p><p id="f550" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在让我们重写代码如下。</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lw"><img src="../Images/1add01eeccffa92d904929f5a2e1acd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N-VoZODtpLOK437mMG_qWQ.png"/></div></div></figure><p id="87af" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，尝试运行<em class="jo"> findPrime(10000) </em>。它将打印出104，729。<br/>尝试调用<em class="jo"> findPrime(10001) </em>。它在十亿分之一秒内打印104，743。</p><h2 id="6339" class="kx jq hi bd jr ky kz la jv lb lc ld jz jb le lf kd jf lg lh kh jj li lj kl lk bi translated">瞧啊。！</h2><p id="9c66" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">我们已经成功地使用闭包来创建控制变量的记忆。这里发生的是，外部函数将内部函数和控制变量封装到一个<em class="jo">闭包范围</em>中，然后连同这个范围一起返回函数。这个内部函数<em class="jo"> searchNthPrime(10000) </em>可以访问控制变量，不在<em class="jo"> setNthPrime </em>函数的范围内。也就是外部函数。所以当你第一次运行这个函数，计算第10000个质数时，这些变量会获得一个值。这个值不会被垃圾收集，因为返回的函数仍然从外部引用它；从<em class="jo"> findPrime </em>变量内部，该变量现在包含一个函数。当我们运行第二个函数调用时，控制变量从它们的当前值恢复...也就是说，它们将从对应于第10000个质数的值开始。不是1。</p><p id="4db5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">闭包在另外两种情况下使用:</p><ol class=""><li id="a251" class="ln lo hi is b it iu ix iy jb lp jf lq jj lr jn ls lt lu lv bi translated">创建一个函数工厂。</li><li id="8852" class="ln lo hi is b it lx ix ly jb lz jf ma jj mb jn ls lt lu lv bi translated">创建模块设计模式。</li></ol><p id="73da" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这些将在我的下一篇博客中从头开始探讨。闭包还导致了世界著名的内存泄漏，我将在接下来的几天里写下来。敬请关注。感谢您的阅读。！！</p><figure class="kt ku kv kw fd ij er es paragraph-image"><a href="https://medium.com/swlh"><div class="er es mc"><img src="../Images/308a8d84fb9b2fab43d66c117fcc4bb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YqDjlKFwScoQYQ62DWEdig.png"/></div></a></figure><h2 id="c148" class="kx jq hi bd jr ky kz la jv lb lc ld jz jb le lf kd jf lg lh kh jj li lj kl lk bi translated">这篇文章发表在<a class="ae md" href="https://medium.com/swlh" rel="noopener"> The Startup </a>上，这是Medium最大的创业刊物，拥有+426，678名读者。</h2><h2 id="869c" class="kx jq hi bd jr ky kz la jv lb lc ld jz jb le lf kd jf lg lh kh jj li lj kl lk bi translated">订阅接收<a class="ae md" href="https://growthsupply.com/the-startup-newsletter/" rel="noopener ugc nofollow" target="_blank">我们的头条新闻在这里</a>。</h2><figure class="kt ku kv kw fd ij er es paragraph-image"><a href="https://medium.com/swlh"><div class="er es mc"><img src="../Images/b0164736ea17a63403e660de5dedf91a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ouK9XR4xuNWtCes-TIUNAw.png"/></div></a></figure></div></div>    
</body>
</html>