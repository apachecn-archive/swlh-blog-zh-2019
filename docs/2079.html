<html>
<head>
<title>Resizing Images in Nativescript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Nativescript中调整图像大小</h1>
<blockquote>原文：<a href="https://medium.com/swlh/resizing-images-in-nativescript-d9bb513ef5c9#2019-04-03">https://medium.com/swlh/resizing-images-in-nativescript-d9bb513ef5c9#2019-04-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="ee28" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我开始使用Nativescript Vue已经有几个月了，所以我想为新的Nativescript开发人员分享一些更多的技巧。我在<a class="ae jd" href="https://blog.angelengineering.com/vue-firebase-login/" rel="noopener ugc nofollow" target="_blank">最后两篇</a> <a class="ae jd" href="https://blog.angelengineering.com/nativescript-vue-firebase-profile/" rel="noopener ugc nofollow" target="_blank">博文</a>中讨论了我的一些初步开发实验，使用Firebase和Nativescript Vue创建了一个基本的社交媒体应用框架。从这个基础开始，我创建了<a class="ae jd" href="https://nerdaly.com/" rel="noopener ugc nofollow" target="_blank"> Nerdaly </a>，一个用Nativescript Vue编写的社交媒体应用，有一个NodeJS后端。大图像导致上传新帖子的延迟和渲染缓慢，所以我决定限制客户端发送的图像的大小。在这篇文章中，我将讨论通过减少像素尺寸来控制Nativescript中的图像文件大小，以产生更小(更快)的图像文件上传。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/b780e3c9e01da77951cd87985e36f7cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*12zpD4WNv_V0lrKT4Hk5zQ.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx">Final application built using Nativescript Vue</figcaption></figure><p id="2f3c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">起初，我首先尝试了一些更高级的方法，例如在将图像保存到文件时使用另一个插件和<a class="ae jd" href="https://github.com/NativeScript/nativescript-imagepicker/issues/185" rel="noopener ugc nofollow" target="_blank"> ImageAsset选项</a><a class="ae jd" href="https://discourse.nativescript.org/t/how-can-i-resize-images/1336" rel="noopener ugc nofollow" target="_blank">，但是这两种方法都无法在两个平台上(以及模拟器和真实设备上)一致地将最终图像宽度限制为400像素。Nativescript根据与设备无关的像素对图像对象进行了抽象，并针对Android和iOS设备进行了缩放，从而为程序员提供了一个Nativescript中的通用界面，但我需要对最终尺寸进行更细粒度的控制。使用每个平台的本地代码，我能够在上传之前将图像文件调整到精确的尺寸。</a></p><p id="8af7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们从上一篇文章中的<a class="ae jd" href="https://blog.angelengineering.com/nativescript-vue-firebase-profile/" rel="noopener ugc nofollow" target="_blank">基本配置文件应用程序开始，来说明控制来自ImagePicker和Camera插件的图像的已保存图像尺寸所需的更改。克隆并运行应用程序，使用:</a></p><pre class="jf jg jh ji fd ju jv jw jx aw jy bi"><span id="1b3e" class="jz ka hi jv b fi kb kc l kd ke">git clone https://github.com/drangelod/nsvfbprofile nsvfbresize <br/>cd nsvfbresize <br/>npm i <br/>tns platform remove ios <br/>tns run ios --bundle</span></pre><p id="99ab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">自从最初的帖子发布以来，已经有了一些重要的更新(特别是ImagePicker插件，以避免变通办法并修复一些iOS错误)，我们将在进入新代码之前首先<a class="ae jd" href="https://docs.nativescript.org/releases/upgrade-instructions" rel="noopener ugc nofollow" target="_blank">更新应用程序</a>。</p><pre class="jf jg jh ji fd ju jv jw jx aw jy bi"><span id="1047" class="jz ka hi jv b fi kb kc l kd ke">npm install -g nativescript</span></pre><p id="6e67" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这将把你的主要Nativescript CLI更新到4.3版。</p><pre class="jf jg jh ji fd ju jv jw jx aw jy bi"><span id="df97" class="jz ka hi jv b fi kb kc l kd ke">tns update</span></pre><p id="07bf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这将把你的核心模块以及Android和iOS平台更新到5.3.x。我们还需要更新这个应用程序中使用的NPM包和Nativescript插件。我一般使用<a class="ae jd" href="https://www.npmjs.com/package/npm-check-updates" rel="noopener ugc nofollow" target="_blank"> NCU工具</a>扫描<code class="du kf kg kh jv b">package.json</code>，让我知道哪些模块有可用的更新。<em class="ki">注意:使用</em> <code class="du kf kg kh jv b"><em class="ki">-a</em></code> <em class="ki">标志将告诉NCU将所有包更新到最新版本，即使是主要的版本更改，但是要小心，因为这可能会由于重大更改而引入错误。</em>对于这个应用程序，更新webpack相关的模块确实会导致问题，需要您使用最新的Nativescript Vue模板重新创建您的项目。相反，我们将只更新Nativescript插件和平台声明，暂时忽略与Vue相关的更新。</p><pre class="jf jg jh ji fd ju jv jw jx aw jy bi"><span id="6251" class="jz ka hi jv b fi kb kc l kd ke">ncu <br/>npm install nativescript-plugin-firebase@latest tns-platform-declarations@latest nativescript-camera@latest nativescript-imagepicker@latest<br/>tns run ios --bundle</span></pre><h1 id="72e0" class="kj ka hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">Firebase初始化修复</h1><p id="1635" class="pw-post-body-paragraph if ig hi ih b ii lg ik il im lh io ip iq li is it iu lj iw ix iy lk ja jb jc hb bi translated">另一个重要的变化应该是对使用Firebase和Nativescript Vue的应用程序进行修改，以避免Firebase认证插件和NSVue应用程序<code class="du kf kg kh jv b">watch</code>在Firebase登录状态下的竞争情况。从<code class="du kf kg kh jv b">/main.js</code>中删除或注释掉<code class="du kf kg kh jv b">firebase.init()</code>代码块。将带有firebase初始化代码的新的<code class="du kf kg kh jv b">mounted()</code>属性添加到<code class="du kf kg kh jv b">LoginPage.vue</code>中的<code class="du kf kg kh jv b">export default</code>对象，看起来如下:</p><pre class="jf jg jh ji fd ju jv jw jx aw jy bi"><span id="d368" class="jz ka hi jv b fi kb kc l kd ke">mounted() {<br/>    let that = this;<br/>    firebase<br/>      .init({<br/>        onAuthStateChanged: data =&gt; {<br/>          console.log(<br/>            (data.loggedIn<br/>              ? "Logged in to firebase"<br/>              : "Logged out from firebase") +<br/>              " (firebase.init() onAuthStateChanged callback)"<br/>          );<br/>          if (data.loggedIn) {<br/>            that.$backendService.token = data.user.uid;<br/>            console.log("uID: " + data.user.uid);<br/>            that.$store.commit("setIsLoggedIn", true);<br/>          } else {<br/>            that.$store.commit("setIsLoggedIn", false);<br/>          }<br/>        }<br/>      })<br/>      .then(<br/>        function(instance) {<br/>          console.log("firebase.init done");<br/>        },<br/>        function(error) {<br/>          console.log("firebase.init error: " + error);<br/>        }<br/>      );<br/>  },</span></pre><p id="f1e8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这将确保NSVue准备好从Firebase Auth插件中查看登录状态更改，并将登录用户正确重定向到仪表板页面。</p><h1 id="7532" class="kj ka hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">控制图像尺寸</h1><p id="006d" class="pw-post-body-paragraph if ig hi ih b ii lg ik il im lh io ip iq li is it iu lj iw ix iy lk ja jb jc hb bi translated">下面是原始的<code class="du kf kg kh jv b">chooseImage()</code>功能，用于处理从设备中选择的新个人资料图像。由于用户可以上传他们设备上的任何图片，所以我最终选择了各种尺寸和大小的图片。这导致了Nerdaly应用程序的存储、显示和延迟问题，所以我添加了一个尺寸检查来调整大图像的大小。如果你目前的iOS模拟器上没有任何图像，可以用Safari从类似<a class="ae jd" href="https://images.nasa.gov/" rel="noopener ugc nofollow" target="_blank"> NASA </a>这样的网站下载一些高分辨率的图像，稍后进行测试。</p><pre class="jf jg jh ji fd ju jv jw jx aw jy bi"><span id="3be2" class="jz ka hi jv b fi kb kc l kd ke">chooseImage() {<br/>      try {<br/>        context<br/>          .authorize()<br/>          .then(() =&gt; {<br/>            return context.present();<br/>          })<br/>          .then(selection =&gt; {<br/>            loader.show();<br/>            const imageAsset = selection.length &gt; 0 ? selection[0] : null;<br/>            imageAsset.options = {<br/>              width: 400,<br/>              height: 400,<br/>              keepAspectRatio: true<br/>            };<br/>            imageSourceModule<br/>              .fromAsset(imageAsset)<br/>              .then(imageSource =&gt; {<br/>                let saved = false;<br/>                let localPath = "";<br/>                let filePath = "";<br/>                let image = {};<br/>                const folderPath = knownFolders.documents().path;<br/>                let fileName =<br/>                  this.$store.state.profile.id +<br/>                  "-" +<br/>                  new Date().getTime() +<br/>                  ".jpg";<br/>                if (imageAsset.android) {<br/>                  localPath = imageAsset.android.toString().split("/");<br/>                  fileName =<br/>                    fileName +<br/>                    "_" +<br/>                    localPath[localPath.length - 1].split(".")[0] +<br/>                    ".jpg";<br/>                  filePath = path.join(folderPath, fileName);<br/>                  saved = imageSource.saveToFile(filePath, "jpeg");<br/>                  if (saved) {<br/>                    this.pictureSource = imageAsset.android.toString();<br/>                  } else {<br/>                    console.log(<br/>                      "Error! Unable to save pic to local file for saving"<br/>                    );<br/>                  }<br/>                  loader.hide();<br/>                } else {<br/>                  const ios = imageAsset.ios;<br/>                  if (ios.mediaType === PHAssetMediaType.Image) {<br/>                    const opt = PHImageRequestOptions.new();<br/>                    opt.version = PHImageRequestOptionsVersion.Current;<br/>                    PHImageManager.defaultManager().requestImageDataForAssetOptionsResultHandler(<br/>                      ios,<br/>                      opt,<br/>                      (imageData, dataUTI, orientation, info) =&gt; {<br/>                        image.src = info<br/>                          .objectForKey("PHImageFileURLKey")<br/>                          .toString();<br/>                        localPath = image.src.toString().split("/");<br/>                        fileName =<br/>                          fileName +<br/>                          "_" +<br/>                          localPath[localPath.length - 1].split(".")[0] +<br/>                          ".jpeg";<br/>                        filePath = path.join(folderPath, fileName);<br/>                        saved = imageSource.saveToFile(filePath, "jpeg");<br/><br/>                        if (saved) {<br/>                          this.pictureSource = filePath;<br/>                        } else {<br/>                          console.log(<br/>                            "Error! Unable to save pic to local file for saving"<br/>                          );<br/>                        }<br/>                        loader.hide();<br/>                      }<br/>                    );<br/>                  }<br/>                }<br/>              })<br/>              .catch(err =&gt; {<br/>                console.log(err);<br/>                loader.hide();<br/>              });<br/>          })<br/>          .catch(err =&gt; {<br/>            console.log(err);<br/>            loader.hide();<br/>          });<br/>      } catch (err) {<br/>        alert("Please select a valid image.");<br/>        console.log(err)<br/>        loader.hide();<br/>      }<br/>    },</span></pre><p id="6f28" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上传到服务器之前，我们需要检查所选图像的尺寸。Nativescript ImagePicker插件返回一个<code class="du kf kg kh jv b">ImageAsset</code>(以设备无关像素表示的图像的内存表示)。在使用<code class="du kf kg kh jv b">ImageAsset</code>创建<code class="du kf kg kh jv b">ImageSource</code>之前，我们不会知道实际的图像尺寸。在ImageSource准备好之后，保存和上传之前，我们将首先检查图像宽度。如果宽度超过400像素，我们将应用平台本机代码来调整图像的大小，并将其保存到设备的文件系统，然后可以上传到Firebase。</p><p id="5f31" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">更新后的chooseImage()函数代码部分将如下所示:</p><pre class="jf jg jh ji fd ju jv jw jx aw jy bi"><span id="b88b" class="jz ka hi jv b fi kb kc l kd ke">getSampleSize(uri, options) {<br/>      var scale = 1;<br/>      if (isAndroid) {<br/>        var boundsOptions = new android.graphics.BitmapFactory.Options();<br/>        boundsOptions.inJustDecodeBounds = true;<br/>        android.graphics.BitmapFactory.decodeFile(uri, boundsOptions);<br/>        // Find the correct scale value. It should be the power of 2.<br/>        var outWidth = boundsOptions.outWidth;<br/>        var outHeight = boundsOptions.outHeight;<br/>        if (options) {<br/>          var targetSize =<br/>            options.maxWidth &lt; options.maxHeight<br/>              ? options.maxWidth<br/>              : options.maxHeight;<br/>          while (<br/>            !(<br/>              this.matchesSize(targetSize, outWidth) ||<br/>              this.matchesSize(targetSize, outHeight)<br/>            )<br/>          ) {<br/>            outWidth /= 2;<br/>            outHeight /= 2;<br/>            scale *= 2;<br/>          }<br/>        }<br/>      }<br/>      return scale;<br/>    },<br/>    matchesSize(targetSize, actualSize) {<br/>      return targetSize &amp;&amp; actualSize / 2 &lt; targetSize;<br/>    },<br/>    chooseImage() {<br/>      let pickcontext = imagepicker.create({ mode: "single" });<br/>      try {<br/>        pickcontext<br/>          .authorize()<br/>          .then(() =&gt; {<br/>            return pickcontext.present();<br/>          })<br/>          .then(selection =&gt; {<br/>            const imageAsset = selection.length &gt; 0 ? selection[0] : null;<br/>            imageAsset.options = {<br/>              width: 400,<br/>              keepAspectRatio: true,<br/>              autoScaleFactor: false<br/>            };<br/>            loader.show();<br/>            imageSourceModule<br/>              .fromAsset(imageAsset)<br/>              .then(imageSource =&gt; {<br/>                var ratio = 400 / imageSource.width;<br/>                var newheight = imageSource.height * ratio;<br/>                var newwidth = imageSource.width * ratio;<br/>                if (imageSource.width &gt; 400) {<br/>                  console.log(<br/>                    "Resizing original image dimentions from : " +<br/>                      imageSource.height +<br/>                      " x " +<br/>                      imageSource.width +<br/>                      " to " +<br/>                      newheight +<br/>                      " x " +<br/>                      newwidth<br/>                  );<br/>                  if (isIOS) {<br/>                    try {<br/>                      let that = this;<br/>                      let manager = PHImageManager.defaultManager();<br/>                      let options = new PHImageRequestOptions();<br/><br/>                      options.resizeMode =<br/>                        PHImageRequestOptionsResizeMode.Exact;<br/>                      options.deliveryMode = PHImageRequestOptionsDeliveryModeHighQualityFormat;<br/>                      manager.requestImageForAssetTargetSizeContentModeOptionsResultHandler(<br/>                        imageAsset.ios,<br/>                        { width: newwidth, height: newheight },<br/>                        PHImageContentModeAspectFill,<br/>                        options,<br/>                        function(result, info) {<br/>                          let saved = false;<br/>                          let filePath = "";<br/>                          const folderPath = knownFolders.documents().path;<br/>                          let fileName =<br/>                            that.$store.state.profile.id +<br/>                            "-" +<br/>                            new Date().getTime() +<br/>                            ".jpg";<br/>                          console.log(<br/>                            "saving image " +<br/>                              fileName +<br/>                              " to path " +<br/>                              folderPath<br/>                          );<br/>                          console.log(<br/>                            "Original image dimentions: " +<br/>                              imageSource.height +<br/>                              " x " +<br/>                              imageSource.width<br/>                          );<br/>                          filePath = path.join(folderPath, fileName);<br/>                          let newasset = new imageAssetModule.ImageAsset(<br/>                            result<br/>                          );<br/><br/>                          imageSourceModule<br/>                            .fromAsset(newasset)<br/>                            .then(newimageSource =&gt; {<br/>                              saved = newimageSource.saveToFile(<br/>                                filePath,<br/>                                "jpeg"<br/>                              );<br/>                              if (saved) {<br/>                                that.pictureSource = filePath;<br/>                                that.newFilename = fileName;<br/>                                console.log(<br/>                                  "Resized image imensions: " +<br/>                                    newimageSource.height +<br/>                                    " x " +<br/>                                    newimageSource.width<br/>                                );<br/>                              } else {<br/>                                console.log(<br/>                                  "Error! Unable to save image to local file for saving"<br/>                                );<br/>                              }<br/>                              loader.hide();<br/>                            });<br/>                        }<br/>                      );<br/>                    } catch (e) {<br/>                      console.log("err: " + e);<br/>                      console.log("stack: " + e.stack);<br/>                    }<br/>                  } else if (isAndroid) {<br/>                    try {<br/>                      var downsampleOptions = new android.graphics.BitmapFactory.Options();<br/>                      downsampleOptions.inSampleSize = this.getSampleSize(<br/>                        imageAsset.android,<br/>                        { maxWidth: newwidth, maxHeight: newheight }<br/>                      );<br/>                      var bitmap = android.graphics.BitmapFactory.decodeFile(<br/>                        imageAsset.android,<br/>                        downsampleOptions<br/>                      );<br/>                      imageSource.setNativeSource(bitmap);<br/><br/>                      let filename =<br/>                        this.$store.state.profile.id +<br/>                        "-" +<br/>                        new Date().getTime() +<br/>                        ".jpg";<br/>                      let folder = knownFolders.documents();<br/>                      let fullpath = path.join(folder.path, filename);<br/>                      let saved = imageSource.saveToFile(fullpath, "jpeg");<br/><br/>                      if (saved) {<br/>                        this.pictureSource = fullpath;<br/>                        this.newFilename = filename;<br/>                        console.log(<br/>                          "Resized image imensions: " +<br/>                            imageSource.height +<br/>                            " x " +<br/>                            imageSource.width<br/>                        );<br/>                      } else {<br/>                        console.log(<br/>                          "Error! Unable to save image to local file for saving"<br/>                        );<br/>                      }<br/>                      loader.hide();<br/>                    } catch (err) {<br/>                      console.log(err);<br/>                      loader.hide();<br/>                    }<br/>                  }<br/>                } else {<br/>                  let saved = false;<br/>                  let filePath = "";<br/>                  const folderPath = knownFolders.documents().path;<br/>                  let fileName =<br/>                    this.$store.state.profile.id +<br/>                    "-" +<br/>                    new Date().getTime() +<br/>                    ".jpg";<br/>                  console.log(<br/>                    "saving image " + fileName + " to path " + folderPath<br/>                  );<br/>                  filePath = path.join(folderPath, fileName);<br/>                  saved = imageSource.saveToFile(filePath, "jpeg");<br/><br/>                  if (saved) {<br/>                    this.pictureSource = filePath;<br/>                    this.newFilename = fileName;<br/>                  } else {<br/>                    console.log(<br/>                      "Error! Unable to save image to local file for saving"<br/>                    );<br/>                  }<br/>                  loader.hide();<br/>                }<br/>              })<br/>              .catch(err =&gt; {<br/>                console.log(err);<br/>                loader.hide();<br/>              });<br/>          })<br/>          .catch(err =&gt; {<br/>            console.log(err);<br/>            loader.hide();<br/>          });<br/>      } catch (err) {<br/>        alert("Please select a valid image.");<br/>        console.log(err);<br/>        loader.hide();<br/>      }<br/>    },</span></pre><p id="05f6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们需要修改脚本部分顶部的导入，删除全局<code class="du kf kg kh jv b">context</code>变量(现在在<code class="du kf kg kh jv b">chooseImage</code>函数中局部声明)并添加一个新的导入来使用<code class="du kf kg kh jv b">ImageAsset</code>模块。如果你运行iOS版本，用一些小的和大的图片进行测试，你应该会看到大的图片被应用程序调整了大小。</p><p id="6106" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">还增加了两个新功能来帮助Android维度计算，因为它可以对缩放的分辨率稍微挑剔一些。现在，您可以运行Android版本来验证这些设备的图像大小调整是否正确:</p><pre class="jf jg jh ji fd ju jv jw jx aw jy bi"><span id="e4fe" class="jz ka hi jv b fi kb kc l kd ke">tns platform remove android <br/>tns run android --bundle</span></pre><h1 id="308b" class="kj ka hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">调整相机图像的大小</h1><p id="66c7" class="pw-post-body-paragraph if ig hi ih b ii lg ik il im lh io ip iq li is it iu lj iw ix iy lk ja jb jc hb bi translated">对于Android，在上传到Firebase之前，您可以将相同的更改应用到<code class="du kf kg kh jv b">takePicture()</code>函数，以调整大型相机照片的大小。然而，对于iOS来说，使用这种方法有一个问题，它无法访问源图像来调整大小。由于iOS相机插件可靠地在最大尺寸要求内产生调整大小的图像，我没有深入挖掘这一失败的确切原因，但我猜测这与iOS上对照片库图像的沙盒访问有关，以防止平台调用的直接操作。如果您真的需要完全控制这种情况，那么添加一些额外的代码来将图像保存到一个可访问的临时文件中，然后在调整大小之前重新加载它应该是可行的。</p><p id="6597" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">新的takePicture()函数将如下所示:</p><pre class="jf jg jh ji fd ju jv jw jx aw jy bi"><span id="af90" class="jz ka hi jv b fi kb kc l kd ke">takePicture() {<br/>      cameraModule<br/>        .takePicture({<br/>          width: 400, //these are in device independent pixels<br/>          keepAspectRatio: true, //    keepAspectRatio is enabled.<br/>          saveToGallery: false //Don't save a copy in local gallery, ignored by some Android devices<br/>        })<br/>        .then(imageAsset =&gt; {<br/>          imageAsset.options.autoScaleFactor = false;<br/>          imageAsset.options.keepAspectRatio = true;<br/>          imageAsset.options.width = 400;<br/><br/>          //save to file<br/>          imageSourceModule.fromAsset(imageAsset).then(<br/>            imageSource =&gt; {<br/>              var ratio = 400 / imageSource.width;<br/>              var newheight = imageSource.height * ratio;<br/>              var newwidth = imageSource.width * ratio;<br/>              if (imageSource.width &gt; 400) {<br/>                console.log(<br/>                  "Resizing original image dimentions from : " +<br/>                    imageSource.height +<br/>                    " x " +<br/>                    imageSource.width +<br/>                    " to " +<br/>                    newheight +<br/>                    " x " +<br/>                    newwidth<br/>                );<br/>                if (isIOS) {<br/>                  console.log("Ignoring resize for camera images on iOS");<br/>                  let filename =<br/>                    this.$store.state.profile.id +<br/>                    "-" +<br/>                    new Date().getTime() +<br/>                    ".jpg";<br/>                  let folder = knownFolders.documents();<br/>                  let fullpath = path.join(folder.path, filename);<br/>                  let saved = imageSource.saveToFile(fullpath, "jpeg");<br/>                  if (saved) {<br/>                    this.pictureSource = fullpath;<br/>                    this.newFilename = filename;<br/>                    console.log(<br/>                      "image imensions: " +<br/>                        imageSource.height +<br/>                        " x " +<br/>                        imageSource.width<br/>                    );<br/>                  } else {<br/>                    console.log(<br/>                      "Error! Unable to save photo to local file for upload"<br/>                    );<br/>                  }<br/>                } else if (isAndroid) {<br/>                  try {<br/>                    var downsampleOptions = new android.graphics.BitmapFactory.Options();<br/>                    downsampleOptions.inSampleSize = this.getSampleSize(<br/>                      imageAsset.android,<br/>                      { maxWidth: newwidth, maxHeight: newheight }<br/>                    );<br/>                    var bitmap = android.graphics.BitmapFactory.decodeFile(<br/>                      imageAsset.android,<br/>                      downsampleOptions<br/>                    );<br/>                    imageSource.setNativeSource(bitmap);<br/><br/>                    let filename =<br/>                      this.$store.state.profile.id +<br/>                      "-" +<br/>                      new Date().getTime() +<br/>                      ".jpg";<br/>                    let folder = knownFolders.documents();<br/>                    let fullpath = path.join(folder.path, filename);<br/>                    let saved = imageSource.saveToFile(fullpath, "jpeg");<br/><br/>                    if (saved) {<br/>                      this.pictureSource = fullpath;<br/>                      this.newFilename = filename;<br/>                      console.log(<br/>                        "Resized image imensions: " +<br/>                          imageSource.height +<br/>                          " x " +<br/>                          imageSource.width<br/>                      );<br/>                    } else {<br/>                      console.log(<br/>                        "Error! Unable to save image to local file for saving"<br/>                      );<br/>                    }<br/>                    loader.hide();<br/>                  } catch (err) {<br/>                    console.log(err);<br/>                    loader.hide();<br/>                  }<br/>                }<br/>              } else {<br/>                let saved = false;<br/>                let filePath = "";<br/>                const folderPath = knownFolders.documents().path;<br/>                let fileName =<br/>                  this.$store.state.profile.id +<br/>                  "-" +<br/>                  new Date().getTime() +<br/>                  ".jpg";<br/>                console.log(<br/>                  "saving image " + fileName + " to path " + folderPath<br/>                );<br/>                filePath = path.join(folderPath, fileName);<br/>                saved = imageSource.saveToFile(filePath, "jpeg");<br/><br/>                if (saved) {<br/>                  this.pictureSource = filePath;<br/>                  this.newFilename = fileName;<br/>                } else {<br/>                  console.log(<br/>                    "Error! Unable to save image to local file for saving"<br/>                  );<br/>                }<br/>                loader.hide();<br/>              }<br/>            },<br/>            err =&gt; {<br/>              console.log("Failed to load from asset");<br/>            }<br/>          );<br/>        })<br/>        .catch(err =&gt; {<br/>          console.error(err);<br/>        });<br/>    },</span></pre><h1 id="bce1" class="kj ka hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">搞定了。</h1><p id="c2f1" class="pw-post-body-paragraph if ig hi ih b ii lg ik il im lh io ip iq li is it iu lj iw ix iy lk ja jb jc hb bi translated">这就是我的建议。如果你想下载最终的源文件，你可以在<a class="ae jd" href="https://github.com/drangelod/nsvfbresize" rel="noopener ugc nofollow" target="_blank"> Github </a>上找到。</p></div><div class="ab cl ll lm gp ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="hb hc hd he hf"><p id="230e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="ki">原载于2019年4月3日blog.angelengineering.com</em><a class="ae jd" href="https://blog.angelengineering.com/resizing-images/" rel="noopener ugc nofollow" target="_blank"><em class="ki"/></a><em class="ki">。</em></p></div></div>    
</body>
</html>