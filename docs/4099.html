<html>
<head>
<title>Thinking With Portals</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用门户思考</h1>
<blockquote>原文：<a href="https://medium.com/swlh/thinking-with-portals-47c5a0a3d155#2019-05-28">https://medium.com/swlh/thinking-with-portals-47c5a0a3d155#2019-05-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="efe8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">关于React门户的帖子</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/39410d73b94021e5d79a639ebd00808a.png" data-original-src="https://miro.medium.com/v2/resize:fit:652/format:webp/1*f9a7uhlEWChBJv95Cfzehg.png"/></div></figure><p id="b657" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您是否曾经想要将子组件渲染到一个<a class="ae jl" href="https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Introduction" rel="noopener ugc nofollow" target="_blank"> DOM </a>节点中，该节点存在于父组件的DOM层次结构的 之外的<strong class="ih jm"> <em class="jn">？你有没有尝试过创建一个模态，但是却弄乱了你所有的CSS？都不知道我在说什么？去过那里。</em></strong></p><p id="2287" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">按照惯例，当我们呈现一个React组件时，它作为最近的父节点的子节点被挂载到DOM，并被约束到我们在。直升机家长多吗？</p><p id="97d4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，随着React 16中门户的增加，子组件现在能够与讨厌的父组件“脱离”。但是，他们并不是完全自由的；通过门户呈现的组件保留了普通React子组件的行为。</p><p id="98f0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是因为子节点和门户存在于<strong class="ih jm">反应树</strong>中，而不管它们在<strong class="ih jm"> DOM树</strong>中的位置。在<a class="ae jl" href="https://reactjs.org/docs/portals.html#event-bubbling-through-portals" rel="noopener ugc nofollow" target="_blank"> React文档</a>中了解更多信息。</p><div class="js jt ez fb ju jv"><a href="https://reactjs.org/docs/portals.html" rel="noopener  ugc nofollow" target="_blank"><div class="jw ab dw"><div class="jx ab jy cl cj jz"><h2 class="hj b fi z dy ka ea eb kb ed ef hh bi translated">门户-反应</h2><div class="kc l"><h3 class="bd b fi z dy ka ea eb kb ed ef dx translated">门户提供了一种一流的方法来将子节点呈现到一个DOM节点中，该节点存在于…</h3></div><div class="kd l"><p class="bd b fp z dy ka ea eb kb ed ef dx translated">reactjs.org</p></div></div><div class="ke l"><div class="kf l kg kh ki ke kj jj jv"/></div></div></a></div><h2 id="cdc3" class="kk kl hi bd km kn ko kp kq kr ks kt ku iq kv kw kx iu ky kz la iy lb lc ld le bi translated">等等，但是为什么？</h2><p id="24d4" class="pw-post-body-paragraph if ig hi ih b ii lf ik il im lg io ip iq lh is it iu li iw ix iy lj ja jb jc hb bi translated">由于DOM在React中的结构(<code class="du jo jp jq jr b">&lt;App /&gt;</code>是<code class="du jo jp jq jr b">&lt;div id="root"&gt;</code>的孩子)，我们的组件不可避免地变得嵌套很深，随着React应用程序的增加，情况更是如此。如果我们试图在其中一个嵌套组件中创建一个弹出窗口(或类似的东西)，我们将会遇到一些CSS问题，即<a class="ae jl" href="https://developer.mozilla.org/en-US/docs/Web/CSS/z-index" rel="noopener ugc nofollow" target="_blank"> z索引</a>和<a class="ae jl" href="https://developer.mozilla.org/en-US/docs/Web/CSS/overflow" rel="noopener ugc nofollow" target="_blank">溢出</a>。</p><p id="d1f2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">门户让我们能够在不同的DOM下，甚至在不同的窗口中呈现组件。使用门户，我们不再需要担心我们的弹出窗口(和应用程序的其他部分)会受到CSS限制的影响。</p><h2 id="944b" class="kk kl hi bd km kn ko kp kq kr ks kt ku iq kv kw kx iu ky kz la iy lb lc ld le bi translated">好吧，那怎么做？</h2><p id="39eb" class="pw-post-body-paragraph if ig hi ih b ii lf ik il im lg io ip iq lh is it iu li iw ix iy lj ja jb jc hb bi translated">让我们来看一下如何给我们的应用程序添加工具提示。</p><p id="cff6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">1.创建可重用的门户组件:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="lk ll l"/></div></figure><ul class=""><li id="d986" class="lm ln hi ih b ii ij im in iq lo iu lp iy lq jc lr ls lt lu bi translated">在我们的<code class="du jo jp jq jr b">constructor()</code>中，我们将组件包装在一个<code class="du jo jp jq jr b">&lt;div&gt;</code>中。然后，我们使用<code class="du jo jp jq jr b">componentDidMount</code>和<code class="du jo jp jq jr b">componentWillUnmount</code>将它放到DOM上，并适当地将其从DOM中移除。</li><li id="3190" class="lm ln hi ih b ii lv im lw iq lx iu ly iy lz jc lr ls lt lu bi translated">在我们的<code class="du jo jp jq jr b">render()</code>中，我们调用<code class="du jo jp jq jr b">ReactDOM.createPortal()</code>，它接受JSX进入门户的参数，以及目标目的地。</li><li id="bcd7" class="lm ln hi ih b ii lv im lw iq lx iu ly iy lz jc lr ls lt lu bi translated">注意，我们的<code class="du jo jp jq jr b">render()</code>实际上并没有返回任何东西。相反，我们设置这个组件是为了在其他地方做一些事情。</li></ul><p id="2e16" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2.创建可重用的工具提示组件:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="lk ll l"/></div></figure><ul class=""><li id="28f3" class="lm ln hi ih b ii ij im in iq lo iu lp iy lq jc lr ls lt lu bi translated">我们用一个布尔值初始化组件，并编写事件处理程序，通过鼠标悬停来切换工具提示</li><li id="95a2" class="lm ln hi ih b ii lv im lw iq lx iu ly iy lz jc lr ls lt lu bi translated">当鼠标悬停在门户上时，门户“打开”并显示工具提示，否则门户“关闭”并隐藏工具提示</li><li id="8e37" class="lm ln hi ih b ii lv im lw iq lx iu ly iy lz jc lr ls lt lu bi translated"><code class="du jo jp jq jr b">this.props.children</code>和<code class="du jo jp jq jr b">this.props.text</code>在我们使用以下组件时定义:</li></ul><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="lk ll l"/></div></figure><p id="bdcb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在CodePen中:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ma ll l"/></div></figure><p id="0f9d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过一些额外的CSS，我们可以让工具提示显示在其他地方。我们甚至可以修改门户组件，在每次鼠标经过时在新窗口中打开工具提示。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="mb ll l"/></div></figure><h2 id="edc8" class="kk kl hi bd km kn ko kp kq kr ks kt ku iq kv kw kx iu ky kz la iy lb lc ld le bi translated">总结:</h2><ul class=""><li id="5e14" class="lm ln hi ih b ii lf im lg iq mc iu md iy me jc lr ls lt lu bi translated">门户允许我们在DOM树中的任何地方插入一个子容器，并且可视化地“逃离”一个父容器(比如模态、工具提示、弹出窗口)</li><li id="2e4f" class="lm ln hi ih b ii lv im lw iq lx iu ly iy lz jc lr ls lt lu bi translated">使用门户渲染的组件表现得像普通的React子组件，因为它仍然存在于React树中</li></ul><p id="c13b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih jm">关于可访问性的重要说明:</strong> <a class="ae jl" href="https://reactjs.org/docs/accessibility.html#programmatically-managing-focus" rel="noopener ugc nofollow" target="_blank">管理门户的键盘焦点</a>，并在创建模态时遵循<a class="ae jl" href="https://www.w3.org/TR/wai-aria-practices-1.1/#dialog_modal" rel="noopener ugc nofollow" target="_blank">模态创作实践</a>。</p></div><div class="ab cl mf mg gp mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="hb hc hd he hf"><p id="8a5b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">阅读更多关于门户网站/查看更多示例<a class="ae jl" href="https://hackernoon.com/using-a-react-16-portal-to-do-something-cool-2a2d627b0202" rel="noopener ugc nofollow" target="_blank">此处</a>和<a class="ae jl" href="https://codeburst.io/reacts-portals-in-3-minutes-9b2efb74e9a9" rel="noopener" target="_blank">此处</a>。</p></div></div>    
</body>
</html>