<html>
<head>
<title>A simpler entry to Redux (without Redux) using React Hooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用React钩子的Redux(无Redux)的一个更简单的入口</h1>
<blockquote>原文：<a href="https://medium.com/swlh/a-simpler-entry-to-redux-without-redux-using-react-hooks-3de90ec2f060?source=collection_archive---------13-----------------------#2019-06-24">https://medium.com/swlh/a-simpler-entry-to-redux-without-redux-using-react-hooks-3de90ec2f060?source=collection_archive---------13-----------------------#2019-06-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><h2 id="1a9c" class="hg hh hi bd b fp hj hk hl hm hn ho dx hp translated" aria-label="kicker paragraph">使用React钩子来编写受益于Redux状态管理的应用程序，而不需要额外的库和样板文件。</h2><div class=""/><figure class="ev ex ip iq ir is er es paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="er es io"><img src="../Images/961286e888f682072de57bfe4e4d3f3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-Ijet6kVJqGgul6adezDLQ.png"/></div></div></figure><blockquote class="iz ja jb"><p id="d193" class="jc jd je jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated"><strong class="jf kb">样本文件</strong></p><p id="a6e4" class="jc jd je jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我已经创建了一个简单的待办列表React应用程序，它利用钩子来实现Redux生命周期的等价物。</p><p id="9ac6" class="jc jd je jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">克隆这个<a class="ae kc" href="https://github.com/greaveselliott/medium/tree/master/reduxless" rel="noopener ugc nofollow" target="_blank">样本库</a></p></blockquote><h1 id="d4c1" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">什么是React钩子？</h1><p id="e022" class="pw-post-body-paragraph jc jd hi jf b jg lb ji jj jk lc jm jn ld le jq jr lf lg ju jv lh li jy jz ka hb bi translated">React挂钩是作为<a class="ae kc" href="https://reactjs.org/blog/2019/02/06/react-v16.8.0.html" rel="noopener ugc nofollow" target="_blank"> React v16.8.0 </a>稳定版的一部分提供的实用方法的集合，为<a class="ae kc" rel="noopener" href="/@Zwenza/functional-vs-class-components-in-react-231e3fbd7108">功能组件</a>提供了额外的功能，例如状态管理的替代方法，同时启用了以前在React类组件生命周期事件中发现的一些功能。</p><h1 id="4d22" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">重复，好的，坏的，样板。</h1><p id="b1af" class="pw-post-body-paragraph jc jd hi jf b jg lb ji jj jk lc jm jn ld le jq jr lf lg ju jv lh li jy jz ka hb bi translated">Redux经常在我的同行中激起复杂的感情……虽然许多工程师享受解耦应用程序状态管理的好处，冗长的样板文件实现起来很乏味，经常让开发人员寻找其他方法。</p><h1 id="f8a2" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">让我们回顾一下Redux的生命周期</h1><p id="3e8f" class="pw-post-body-paragraph jc jd hi jf b jg lb ji jj jk lc jm jn ld le jq jr lf lg ju jv lh li jy jz ka hb bi translated"><em class="je">如果您熟悉Redux，请随意跳到下一节。</em></p><p id="1ea8" class="pw-post-body-paragraph jc jd hi jf b jg jh ji jj jk jl jm jn ld jp jq jr lf jt ju jv lh jx jy jz ka hb bi translated">在用React钩子实现Redux生命周期之前，让我们创建一个清单，包含我们需要复制的Redux的支柱。</p><figure class="lk ll lm ln fd is er es paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="er es lj"><img src="../Images/876107bfc6a9851263e2454379956eeb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cZbTPxi7TppS0fAbKEyhCg.jpeg"/></div></div><figcaption class="lo lp et er es lq lr bd b be z dx">Fig 1: Redux Lifecycle</figcaption></figure><p id="7709" class="pw-post-body-paragraph jc jd hi jf b jg jh ji jj jk jl jm jn ld jp jq jr lf jt ju jv lh jx jy jz ka hb bi translated">我们的<strong class="jf kb">视图</strong>从商店中消费它们的状态。</p><p id="35e8" class="pw-post-body-paragraph jc jd hi jf b jg jh ji jj jk jl jm jn ld jp jq jr lf jt ju jv lh jx jy jz ka hb bi translated"><strong class="jf kb">存储</strong>包含应用程序状态。</p><p id="76db" class="pw-post-body-paragraph jc jd hi jf b jg jh ji jj jk jl jm jn ld jp jq jr lf jt ju jv lh jx jy jz ka hb bi translated"><strong class="jf kb">动作</strong>描述商店应该如何更新的说明。</p><p id="4e79" class="pw-post-body-paragraph jc jd hi jf b jg jh ji jj jk jl jm jn ld jp jq jr lf jt ju jv lh jx jy jz ka hb bi translated"><strong class="jf kb">reducer</strong>消耗动作来更新存储的状态。</p><h1 id="3120" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">应用程序…一个简单的任务列表</h1><p id="d010" class="pw-post-body-paragraph jc jd hi jf b jg lb ji jj jk lc jm jn ld le jq jr lf lg ju jv lh li jy jz ka hb bi translated">让我们创建一个简单的待办事项列表，允许用户添加或删除项目。</p><figure class="lk ll lm ln fd is er es paragraph-image"><div class="er es ls"><img src="../Images/7b13b894a83be7d4a2fccf5d2782800e.png" data-original-src="https://miro.medium.com/v2/resize:fit:984/1*0ZHRMfp1niMnFBrvjlHx0w.gif"/></div><figcaption class="lo lp et er es lq lr bd b be z dx">Fig 2: Example App</figcaption></figure></div><div class="ab cl lt lu gp lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="hb hc hd he hf"><h1 id="e483" class="kd ke hi bd kf kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la bi translated">创建商店</h1><p id="46f4" class="pw-post-body-paragraph jc jd hi jf b jg lb ji jj jk lc jm jn ld le jq jr lf lg ju jv lh li jy jz ka hb bi translated">为了实现这个商店，让我们引入<strong class="jf kb"><em class="je"/></strong><a class="ae kc" href="https://reactjs.org/docs/context.html" rel="noopener ugc nofollow" target="_blank">React . create context()</a>和一个React钩子<a class="ae kc" href="https://reactjs.org/docs/hooks-reference.html#usereducer" rel="noopener ugc nofollow" target="_blank"> React.useReducer() </a>。</p><h2 id="368f" class="mf ke hi bd kf mg mh mi kj mj mk ml kn ld mm mn kr lf mo mp kv lh mq mr kz ho bi translated">React.createContext()</h2><blockquote class="iz ja jb"><p id="c36c" class="jc jd je jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">上下文提供了一种通过组件树传递数据的方式，而不必在每一层手动向下传递属性。</p><p id="90c7" class="jc jd je jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">- <a class="ae kc" href="https://reactjs.org/docs/hooks-reference.html#usecontext" rel="noopener ugc nofollow" target="_blank"> React文档</a></p></blockquote><figure class="lk ll lm ln fd is"><div class="bz dy l di"><div class="ms mt l"/></div><figcaption class="lo lp et er es lq lr bd b be z dx">Fig 3: Store.js</figcaption></figure><h2 id="dd3d" class="mf ke hi bd kf mg mh mi kj mj mk ml kn ld mm mn kr lf mo mp kv lh mq mr kz ho bi translated">定义商店上下文</h2><p id="6412" class="pw-post-body-paragraph jc jd hi jf b jg lb ji jj jk lc jm jn ld le jq jr lf lg ju jv lh li jy jz ka hb bi translated">在名为store.js的新文件中初始化共享应用程序上下文</p><figure class="lk ll lm ln fd is"><div class="bz dy l di"><div class="ms mt l"/></div><figcaption class="lo lp et er es lq lr bd b be z dx">Fig 4: Store.js</figcaption></figure><h2 id="d35b" class="mf ke hi bd kf mg mh mi kj mj mk ml kn ld mm mn kr lf mo mp kv lh mq mr kz ho bi translated">定义初始存储状态</h2><p id="07db" class="pw-post-body-paragraph jc jd hi jf b jg lb ji jj jk lc jm jn ld le jq jr lf lg ju jv lh li jy jz ka hb bi translated">定义初始应用程序状态。对于这个简单的待办事项列表应用程序，我们只需要一个列表属性。</p><h2 id="51a8" class="mf ke hi bd kf mg mh mi kj mj mk ml kn ld mm mn kr lf mo mp kv lh mq mr kz ho bi translated">React.useReducer()</h2><blockquote class="iz ja jb"><p id="35fb" class="jc jd je jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">接受类型为<code class="du mu mv mw mx b"><em class="hi">(state, action) =&gt; newState</em></code>的缩减器，并返回与<code class="du mu mv mw mx b"><em class="hi">dispatch</em></code>方法配对的当前状态。(如果你熟悉Redux，你已经知道这是如何工作的。)</p><p id="b7da" class="jc jd je jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">- <a class="ae kc" href="https://reactjs.org/docs/hooks-reference.html#usereducer" rel="noopener ugc nofollow" target="_blank"> React文档</a></p></blockquote><figure class="lk ll lm ln fd is"><div class="bz dy l di"><div class="ms mt l"/></div><figcaption class="lo lp et er es lq lr bd b be z dx">Fig 5: Store.js</figcaption></figure><h2 id="509b" class="mf ke hi bd kf mg mh mi kj mj mk ml kn ld mm mn kr lf mo mp kv lh mq mr kz ho bi translated">将缩减器绑定到存储提供程序</h2><p id="07f7" class="pw-post-body-paragraph jc jd hi jf b jg lb ji jj jk lc jm jn ld le jq jr lf lg ju jv lh li jy jz ka hb bi translated">创建一个StoreProvider组件，然后在其中初始化useReducer()，将应用程序Reducer和初始状态解析为props。</p><p id="af23" class="pw-post-body-paragraph jc jd hi jf b jg jh ji jj jk jl jm jn ld jp jq jr lf jt ju jv lh jx jy jz ka hb bi translated">最后，析构useReducer响应以公开应用程序状态和动作分派方法。</p><figure class="lk ll lm ln fd is"><div class="bz dy l di"><div class="ms mt l"/></div><figcaption class="lo lp et er es lq lr bd b be z dx">Fig 6: Store.js</figcaption></figure><h2 id="0bd7" class="mf ke hi bd kf mg mh mi kj mj mk ml kn ld mm mn kr lf mo mp kv lh mq mr kz ho bi translated">正在完成StoreProvider组件</h2><p id="a56b" class="pw-post-body-paragraph jc jd hi jf b jg lb ji jj jk lc jm jn ld le jq jr lf lg ju jv lh li jy jz ka hb bi translated">使用初始化的存储上下文，我们可以用JSX语法定义存储提供者。</p><p id="c183" class="pw-post-body-paragraph jc jd hi jf b jg jh ji jj jk jl jm jn ld jp jq jr lf jt ju jv lh jx jy jz ka hb bi translated">将状态和调度作为对象传递给提供程序的value属性。</p><p id="6af4" class="pw-post-body-paragraph jc jd hi jf b jg jh ji jj jk jl jm jn ld jp jq jr lf jt ju jv lh jx jy jz ka hb bi translated">最后，这个组件必须支持子组件。</p><figure class="lk ll lm ln fd is"><div class="bz dy l di"><div class="ms mt l"/></div><figcaption class="lo lp et er es lq lr bd b be z dx">Fig 7: index.js</figcaption></figure><h2 id="9892" class="mf ke hi bd kf mg mh mi kj mj mk ml kn ld mm mn kr lf mo mp kv lh mq mr kz ho bi translated">初始化StoreProvider</h2><p id="d8ba" class="pw-post-body-paragraph jc jd hi jf b jg lb ji jj jk lc jm jn ld le jq jr lf lg ju jv lh li jy jz ka hb bi translated">为了让一切工作，我们必须让我们的应用程序访问StoreProvider。转到index.js文件。</p><p id="7d46" class="pw-post-body-paragraph jc jd hi jf b jg jh ji jj jk jl jm jn ld jp jq jr lf jt ju jv lh jx jy jz ka hb bi translated">从store.js导入StoreProvider，然后将StoreProvider包装在App组件周围。</p></div><div class="ab cl lt lu gp lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="hb hc hd he hf"><h1 id="7cad" class="kd ke hi bd kf kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la bi translated">定义减速器</h1><p id="2e95" class="pw-post-body-paragraph jc jd hi jf b jg lb ji jj jk lc jm jn ld le jq jr lf lg ju jv lh li jy jz ka hb bi translated">类似于Redux，我们的reducer是一个switch语句，它根据动作类型和有效负载改变状态。</p><p id="185a" class="pw-post-body-paragraph jc jd hi jf b jg jh ji jj jk jl jm jn ld jp jq jr lf jt ju jv lh jx jy jz ka hb bi translated">对于我们的应用程序，我们需要处理两个用户操作。</p><ol class=""><li id="9e4e" class="my mz hi jf b jg jh jk jl ld na lf nb lh nc ka nd ne nf ng bi translated">创建新列表项</li><li id="6899" class="my mz hi jf b jg nh jk ni ld nj lf nk lh nl ka nd ne nf ng bi translated">删除列表项目</li></ol><figure class="lk ll lm ln fd is"><div class="bz dy l di"><div class="ms mt l"/></div><figcaption class="lo lp et er es lq lr bd b be z dx">Fig 8: reducer.js</figcaption></figure><h2 id="3a48" class="mf ke hi bd kf mg mh mi kj mj mk ml kn ld mm mn kr lf mo mp kv lh mq mr kz ho bi translated">创建新列表项</h2><p id="1ce1" class="pw-post-body-paragraph jc jd hi jf b jg lb ji jj jk lc jm jn ld le jq jr lf lg ju jv lh li jy jz ka hb bi translated">我们的reducer通过将新列表项连接到现有列表状态来处理<em class="je"> CREATE_NEW_LIST_ITEM </em>动作。</p><p id="b862" class="pw-post-body-paragraph jc jd hi jf b jg jh ji jj jk jl jm jn ld jp jq jr lf jt ju jv lh jx jy jz ka hb bi translated">每个列表项都被表示为一个对象的一部分，该对象包含它自己的通用唯一标识符(UUID)。</p><h2 id="8922" class="mf ke hi bd kf mg mh mi kj mj mk ml kn ld mm mn kr lf mo mp kv lh mq mr kz ho bi translated">删除列表项目</h2><p id="bf57" class="pw-post-body-paragraph jc jd hi jf b jg lb ji jj jk lc jm jn ld le jq jr lf lg ju jv lh li jy jz ka hb bi translated">我们的reducer通过过滤掉匹配UUID的列表项来处理DELETE_LIST_ITEM处理程序。</p></div><div class="ab cl lt lu gp lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="hb hc hd he hf"><h1 id="b5c6" class="kd ke hi bd kf kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la bi translated">定义动作创建者</h1><p id="6c80" class="pw-post-body-paragraph jc jd hi jf b jg lb ji jj jk lc jm jn ld le jq jr lf lg ju jv lh li jy jz ka hb bi translated">当被调用时，reducer将使用分派的动作来更新状态。</p><figure class="lk ll lm ln fd is"><div class="bz dy l di"><div class="ms mt l"/></div><figcaption class="lo lp et er es lq lr bd b be z dx">Fig 9: actions.js</figcaption></figure><p id="99f0" class="pw-post-body-paragraph jc jd hi jf b jg jh ji jj jk jl jm jn ld jp jq jr lf jt ju jv lh jx jy jz ka hb bi translated">创建和删除列表项的操作创建器很简单。</p><h2 id="8f47" class="mf ke hi bd kf mg mh mi kj mj mk ml kn ld mm mn kr lf mo mp kv lh mq mr kz ho bi translated">参数化调度程序</h2><p id="9e33" class="pw-post-body-paragraph jc jd hi jf b jg lb ji jj jk lc jm jn ld le jq jr lf lg ju jv lh li jy jz ka hb bi translated">与redux略有不同的是，这些动作的创建者期望一个有效负载和dispatch方法作为参数。</p></div><div class="ab cl lt lu gp lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="hb hc hd he hf"><h1 id="facb" class="kd ke hi bd kf kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la bi translated">将商店与景观连接起来</h1><p id="9a30" class="pw-post-body-paragraph jc jd hi jf b jg lb ji jj jk lc jm jn ld le jq jr lf lg ju jv lh li jy jz ka hb bi translated">让我们探索用另一个名为<a class="ae kc" href="https://reactjs.org/docs/hooks-reference.html#usecontext" rel="noopener ugc nofollow" target="_blank"> useContext() </a>的钩子向应用程序视图公开商店的状态。</p><h2 id="9d1e" class="mf ke hi bd kf mg mh mi kj mj mk ml kn ld mm mn kr lf mo mp kv lh mq mr kz ho bi translated">React.useContext()</h2><blockquote class="iz ja jb"><p id="f2f7" class="jc jd je jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">接受一个上下文对象(从<code class="du mu mv mw mx b"><em class="hi">React.createContext</em></code>返回的值)并返回该上下文的当前上下文值。当前上下文值由树中调用组件上方最近的<code class="du mu mv mw mx b"><em class="hi">&lt;MyContext.Provider&gt;</em></code>的<code class="du mu mv mw mx b"><em class="hi">value</em></code>属性决定。</p><p id="6865" class="jc jd je jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">- <a class="ae kc" href="https://reactjs.org/docs/hooks-reference.html#usecontext" rel="noopener ugc nofollow" target="_blank"> React文档</a></p></blockquote><figure class="lk ll lm ln fd is"><div class="bz dy l di"><div class="ms mt l"/></div><figcaption class="lo lp et er es lq lr bd b be z dx">Fig 10: App.jsx</figcaption></figure><h2 id="c2d7" class="mf ke hi bd kf mg mh mi kj mj mk ml kn ld mm mn kr lf mo mp kv lh mq mr kz ho bi translated">应用程序标记</h2><p id="a125" class="pw-post-body-paragraph jc jd hi jf b jg lb ji jj jk lc jm jn ld le jq jr lf lg ju jv lh li jy jz ka hb bi translated">在一个功能性的React组件中定义应用程序的静态标记，我们可以将这个组件分开，但是对于这个练习，一个组件就足够了。</p><h2 id="322c" class="mf ke hi bd kf mg mh mi kj mj mk ml kn ld mm mn kr lf mo mp kv lh mq mr kz ho bi translated">绑定存储上下文</h2><p id="0824" class="pw-post-body-paragraph jc jd hi jf b jg lb ji jj jk lc jm jn ld le jq jr lf lg ju jv lh li jy jz ka hb bi translated">以商店为参数调用useContext() hook赋予组件<strong class="jf kb"> <em class="je"> </em> </strong>访问商店内部状态属性和分派方法。</p><h2 id="eb9a" class="mf ke hi bd kf mg mh mi kj mj mk ml kn ld mm mn kr lf mo mp kv lh mq mr kz ho bi translated">遍历列表状态</h2><p id="5e31" class="pw-post-body-paragraph jc jd hi jf b jg lb ji jj jk lc jm jn ld le jq jr lf lg ju jv lh li jy jz ka hb bi translated">最后，我们现在可以通过遍历列表状态来呈现列表项。</p></div><div class="ab cl lt lu gp lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="hb hc hd he hf"><h1 id="dd4a" class="kd ke hi bd kf kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la bi translated">从视图调度操作</h1><p id="03f5" class="pw-post-body-paragraph jc jd hi jf b jg lb ji jj jk lc jm jn ld le jq jr lf lg ju jv lh li jy jz ka hb bi translated">很好，我们正在从商店读取状态，但是更新商店怎么样？</p><p id="d492" class="pw-post-body-paragraph jc jd hi jf b jg jh ji jj jk jl jm jn ld jp jq jr lf jt ju jv lh jx jy jz ka hb bi translated">让我们探索一下从表单字段中读取值，然后将这些值传递给我们的动作调度程序。</p><h2 id="379a" class="mf ke hi bd kf mg mh mi kj mj mk ml kn ld mm mn kr lf mo mp kv lh mq mr kz ho bi translated">用React.useRef()钩子引入引用</h2><blockquote class="iz ja jb"><p id="0064" class="jc jd je jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated"><code class="du mu mv mw mx b"><em class="hi">useRef</em></code>返回一个可变的ref对象，其<code class="du mu mv mw mx b"><em class="hi">.current</em></code>属性被初始化为传递的参数(<code class="du mu mv mw mx b"><em class="hi">initialValue</em></code>)。返回的对象将在组件的整个生存期内保持不变。</p><p id="6e91" class="jc jd je jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">- <a class="ae kc" href="https://reactjs.org/docs/hooks-reference.html#useref" rel="noopener ugc nofollow" target="_blank"> React文档</a></p></blockquote><figure class="lk ll lm ln fd is"><div class="bz dy l di"><div class="ms mt l"/></div><figcaption class="lo lp et er es lq lr bd b be z dx">Fig 11: App.jsx</figcaption></figure><h2 id="aada" class="mf ke hi bd kf mg mh mi kj mj mk ml kn ld mm mn kr lf mo mp kv lh mq mr kz ho bi translated">正在初始化React.useRef()</h2><p id="6ec6" class="pw-post-body-paragraph jc jd hi jf b jg lb ji jj jk lc jm jn ld le jq jr lf lg ju jv lh li jy jz ka hb bi translated">在App.jsx的顶部包含useRef依赖项。</p><p id="dc04" class="pw-post-body-paragraph jc jd hi jf b jg jh ji jj jk jl jm jn ld jp jq jr lf jt ju jv lh jx jy jz ka hb bi translated">在你的应用组件中初始化useRef钩子。</p><p id="0499" class="pw-post-body-paragraph jc jd hi jf b jg jh ji jj jk jl jm jn ld jp jq jr lf jt ju jv lh jx jy jz ka hb bi translated">将响应保存到一个名为input的属性中(参见图11，第10行)。</p><figure class="lk ll lm ln fd is"><div class="bz dy l di"><div class="ms mt l"/></div><figcaption class="lo lp et er es lq lr bd b be z dx">Fig 12: App.jsx</figcaption></figure><h2 id="a76e" class="mf ke hi bd kf mg mh mi kj mj mk ml kn ld mm mn kr lf mo mp kv lh mq mr kz ho bi translated">将useRef绑定到DOM</h2><p id="7b6f" class="pw-post-body-paragraph jc jd hi jf b jg lb ji jj jk lc jm jn ld le jq jr lf lg ju jv lh li jy jz ka hb bi translated">最后，将输入传递给想要引用的HTML元素上的<em class="je"> ref </em>属性(参见图12，第5行)。</p><figure class="lk ll lm ln fd is"><div class="bz dy l di"><div class="ms mt l"/></div><figcaption class="lo lp et er es lq lr bd b be z dx">Fig 13: App.jsx</figcaption></figure><h2 id="4b5b" class="mf ke hi bd kf mg mh mi kj mj mk ml kn ld mm mn kr lf mo mp kv lh mq mr kz ho bi translated">向商店提交表单数据。</h2><p id="06c4" class="pw-post-body-paragraph jc jd hi jf b jg lb ji jj jk lc jm jn ld le jq jr lf lg ju jv lh li jy jz ka hb bi translated">在创建处理程序之前，在App.jsx的顶部导入createNewListItem操作。</p><p id="c18c" class="pw-post-body-paragraph jc jd hi jf b jg jh ji jj jk jl jm jn ld jp jq jr lf jt ju jv lh jx jy jz ka hb bi translated">定义调用createNewListItem操作调度程序的提交处理程序，防止默认的表单操作。</p><p id="0a07" class="pw-post-body-paragraph jc jd hi jf b jg jh ji jj jk jl jm jn ld jp jq jr lf jt ju jv lh jx jy jz ka hb bi translated">调用createNewListItem，解析从useContext()返回的调度，以及输入的当前值。</p><p id="aa98" class="pw-post-body-paragraph jc jd hi jf b jg jh ji jj jk jl jm jn ld jp jq jr lf jt ju jv lh jx jy jz ka hb bi translated">最后，将onFormSubmit绑定到表单上(参见图13，第18行)。</p><figure class="lk ll lm ln fd is"><div class="bz dy l di"><div class="ms mt l"/></div><figcaption class="lo lp et er es lq lr bd b be z dx">Fig 14: App.jsx</figcaption></figure><h2 id="3874" class="mf ke hi bd kf mg mh mi kj mj mk ml kn ld mm mn kr lf mo mp kv lh mq mr kz ho bi translated">删除列表项目</h2><p id="9f1a" class="pw-post-body-paragraph jc jd hi jf b jg lb ji jj jk lc jm jn ld le jq jr lf lg ju jv lh li jy jz ka hb bi translated">让我们添加删除列表项的处理程序。</p><p id="f2f2" class="pw-post-body-paragraph jc jd hi jf b jg jh ji jj jk jl jm jn ld jp jq jr lf jt ju jv lh jx jy jz ka hb bi translated">在App.jsx顶部导入deleteListItem操作。</p><p id="7142" class="pw-post-body-paragraph jc jd hi jf b jg jh ji jj jk jl jm jn ld jp jq jr lf jt ju jv lh jx jy jz ka hb bi translated">定义调用onDeleteListItem操作调度程序的click处理程序。</p><p id="7861" class="pw-post-body-paragraph jc jd hi jf b jg jh ji jj jk jl jm jn ld jp jq jr lf jt ju jv lh jx jy jz ka hb bi translated">调用onDeleteListItem，解析从useContext()返回的调度，并列出UUID项。</p><p id="9618" class="pw-post-body-paragraph jc jd hi jf b jg jh ji jj jk jl jm jn ld jp jq jr lf jt ju jv lh jx jy jz ka hb bi translated">最后，使用一个匿名函数，将deleteListItem处理程序绑定到列表项删除按钮上(参见图14，第23行)。</p></div><div class="ab cl lt lu gp lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="hb hc hd he hf"><h1 id="3f39" class="kd ke hi bd kf kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la bi translated">完整的应用</h1><figure class="lk ll lm ln fd is er es paragraph-image"><div class="er es nm"><img src="../Images/fa91358425719881914e923427cd45e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*Sc-i1d2C3U84ZxTunlRlxg.gif"/></div><figcaption class="lo lp et er es lq lr bd b be z dx">Fig 15. Completed App</figcaption></figure><p id="c16f" class="pw-post-body-paragraph jc jd hi jf b jg jh ji jj jk jl jm jn ld jp jq jr lf jt ju jv lh jx jy jz ka hb bi translated">就这样，我们已经使用React钩子实现了一个待办事项列表。请随意访问存储库、克隆、派生或提交PR——自从撰写本文以来，我已经对repo做了一些改进……请前往<a class="ae kc" href="https://github.com/greaveselliott/medium/tree/master/reduxless" rel="noopener ugc nofollow" target="_blank"> Github </a>查看它们。</p><p id="6147" class="pw-post-body-paragraph jc jd hi jf b jg jh ji jj jk jl jm jn ld jp jq jr lf jt ju jv lh jx jy jz ka hb bi translated">如果你有兴趣阅读更多类似的文章，请关注我的<a class="ae kc" rel="noopener" href="/@elliott.greaves">媒体</a>、<a class="ae kc" href="https://twitter.com/greaveselliott?lang=en" rel="noopener ugc nofollow" target="_blank">推特</a>、<a class="ae kc" href="https://github.com/greaveselliott" rel="noopener ugc nofollow" target="_blank"> GitHub </a>或<a class="ae kc" href="https://www.linkedin.com/in/elliottgreaves/" rel="noopener ugc nofollow" target="_blank">链接</a>。</p><p id="4d1a" class="pw-post-body-paragraph jc jd hi jf b jg jh ji jj jk jl jm jn ld jp jq jr lf jt ju jv lh jx jy jz ka hb bi translated">感谢阅读，</p><p id="ae4d" class="pw-post-body-paragraph jc jd hi jf b jg jh ji jj jk jl jm jn ld jp jq jr lf jt ju jv lh jx jy jz ka hb bi translated"><em class="je">——艾略特</em></p></div></div>    
</body>
</html>