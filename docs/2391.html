<html>
<head>
<title>Angular 7 models</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Angular 7款</h1>
<blockquote>原文：<a href="https://medium.com/swlh/angular-7-models-cd0cd80f5e33#2019-04-18">https://medium.com/swlh/angular-7-models-cd0cd80f5e33#2019-04-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/0ac7b2d1aaa21e4693592b5c7b8c86ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y9_BdXg-L4OrXnKxKjNWqA.jpeg"/></div></div></figure><p id="a447" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">由于我的<a class="ae jo" href="https://nehalist.io/working-with-models-in-angular/" rel="noopener ugc nofollow" target="_blank">上一篇关于Angular模型的指南</a>是在2017年9月写的，现在肯定是更新Angular最新版本的时候了。关于实现的一些事情已经改变了，特别是在如何创建我们的类(现在通过Angular CLI完成)、<code class="du jp jq jr js b">HttpClient</code>如何工作(已经变得通用)以及如何将我们的响应映射到我们的模型(通过管道)方面。</p><p id="998a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">此外，本指南将尝试涵盖上一指南中出现的一些问题。</p><p id="3791" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于TL；这个帖子的DR版本见<a class="ae jo" href="https://github.com/nehalist/angular7-models" rel="noopener ugc nofollow" target="_blank"> GitHub资源库</a>。</p><h1 id="d0fd" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">计算机网络服务器</h1><p id="0886" class="pw-post-body-paragraph iq ir hi is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hb bi translated">对于本指南，我们将创建一个<em class="kw">非常</em>小的<a class="ae jo" href="https://express.js.com" rel="noopener ugc nofollow" target="_blank"> expressjs </a>服务器来服务我们的数据。这个服务器(用普通JavaScript实现)将返回简单的JSON，然后映射到Angular中的模型。</p><pre class="kx ky kz la fd lb js lc ld aw le bi"><span id="9cd5" class="lf ju hi js b fi lg lh l li lj">// server.js<br/><br/>// Our users which will be queried by their index<br/>const users = [<br/>  {<br/>    firstName: "Jesse",<br/>    lastName: "Pinkman",<br/>    position: "Manufacturer",<br/>    cars: [<br/>      {<br/>        brand: "BMW",<br/>        model: "M3",<br/>        kW: 338,<br/>      },<br/>    ],<br/>  },<br/>  {<br/>    firstName: "Walter",<br/>    lastName: "White",<br/>    position: "CEO",<br/>    cars: [<br/>      {<br/>        brand: "BMW",<br/>        model: "335i",<br/>        kW: 225,<br/>      },<br/>      {<br/>        brand: "Lamborghini",<br/>        model: "Aventador",<br/>        kW: 566,<br/>      }<br/>    ],<br/>  },<br/>];<br/><br/>// Allow cross-origin requests<br/>app.use(function(req, res, next) {<br/>  res.header("Access-Control-Allow-Origin", "*");<br/>  res.header("Access-Control-Allow-Headers", "Origin, X-Requested-With, Content-Type, Accept");<br/>  next();<br/>});<br/><br/>app.get("/users", (req, res) =&gt; {<br/>  return res.json(users);<br/>});<br/><br/>app.get("/user/:id", (req, res) =&gt; {<br/>  // To prevent the ID "0" we'll simply subtract by one. This way we can query for id = 2 which will serve us 1, etc.<br/>  const idx = req.params.id - 1;<br/><br/>  if (!users[idx]) {<br/>    return res.status(404).json({ error: "User not found" });<br/>  }<br/><br/>  return res.json(users[idx]);<br/>});<br/><br/>app.listen(3000, () =&gt; {<br/>  console.log("Server running on port 3000");<br/>});</span></pre><p id="d71a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">服务器以<code class="du jp jq jr js b">node server.js</code>启动，将提供API来根据两个不同用户的ID查询他们。例如<code class="du jp jq jr js b">http://localhost:3000/2</code>会输出:</p><pre class="kx ky kz la fd lb js lc ld aw le bi"><span id="1b50" class="lf ju hi js b fi lg lh l li lj">{<br/>  "firstName": "Walter",<br/>  "lastName": "White",<br/>  "position": "CEO",<br/>  "cars": [<br/>    {<br/>      "brand": "BMW",<br/>      "model": "335i",<br/>      "kW": 225<br/>    },<br/>    {<br/>      "brand": "Lamborghini",<br/>      "model": "Aventador",<br/>      "kW": 566<br/>    }<br/>  ]<br/>}</span></pre><p id="0931" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">前往<code class="du jp jq jr js b">http://localhost:3000/users</code>将返回所有用户的列表。</p><p id="3688" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们这里有两个对象，它们将被映射到适当的模型对象；用户本身及其汽车<strong class="is lk"> s </strong> ( <em class="kw">复数！</em>)。</p><h1 id="8e63" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">角度应用</h1><p id="6b4c" class="pw-post-body-paragraph iq ir hi is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hb bi translated">让我们从最底层开始，使用Angular CLI创建新的Angular应用程序:</p><pre class="kx ky kz la fd lb js lc ld aw le bi"><span id="24ea" class="lf ju hi js b fi lg lh l li lj">ng g angular7-models <br/>cd angular7-models</span></pre><p id="91ea" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们需要一个对我们的用户和两个模型负责的服务，一个代表用户，一个代表汽车。</p><pre class="kx ky kz la fd lb js lc ld aw le bi"><span id="7b9d" class="lf ju hi js b fi lg lh l li lj">ng g service services/user <br/>ng g class models/user.model <br/>ng g class models/car.model</span></pre><p id="a274" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这(以及已经存在的应用程序组件)是我们在本指南中需要的所有东西的基础。</p><h1 id="bec7" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">模型和反序列化</h1><p id="4de2" class="pw-post-body-paragraph iq ir hi is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hb bi translated">当从我们的API查询时，我们所有的模型都需要被反序列化。这只是指定了来自API的数据映射到模型类的方式。</p><p id="8351" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">正如在<a class="ae jo" href="https://nehalist.io/working-with-models-in-angular/#deserialization" rel="noopener ugc nofollow" target="_blank">之前的指南</a>中一样，我们将简单地实现一个<code class="du jp jq jr js b">Deserializable</code>接口，该接口将由我们的模型在之后实现:</p><pre class="kx ky kz la fd lb js lc ld aw le bi"><span id="ca04" class="lf ju hi js b fi lg lh l li lj">// src/app/models/deserializable.model.ts<br/><br/>export interface Deserializable {<br/>  deserialize(input: any): this;<br/>}</span></pre><p id="5818" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个接口将由我们的模型实现；<code class="du jp jq jr js b">deserialize</code>将负责将我们的数据映射到我们的对象。</p><h1 id="4db2" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">汽车模型</h1><p id="66cc" class="pw-post-body-paragraph iq ir hi is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hb bi translated">因为我们的汽车模型没有任何关系(这使得<em class="kw">更容易</em>模型实现),让我们从这个模型开始。</p><pre class="kx ky kz la fd lb js lc ld aw le bi"><span id="3037" class="lf ju hi js b fi lg lh l li lj">// src/app/models/car.model.ts<br/><br/>import {Deserializable} from './deserializable.model';<br/><br/>export class Car implements Deserializable {<br/>  public brand: 'BMW' | 'Audi' | 'Lamborghini' | 'Mercedes';<br/>  public model: string;<br/>  public kW: number;<br/><br/>  deserialize(input: any): this {<br/>    return Object.assign(this, input);<br/>  }<br/>  <br/>  getHp() {<br/>    return this.kW * 1.36;<br/>  }<br/>}</span></pre><p id="1a14" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这种情况下，<code class="du jp jq jr js b">Object.assign</code>是一个简单的助手，<em class="kw">将</em>我们的输入分配给我们的对象——由于我们不需要任何分配逻辑(比如从我们的API转换或修改数据),这就足够了。</p><p id="b704" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">此外，出于演示的目的，这个模型有一个实用程序方法，将我们汽车的千瓦数转换为马力——我们将在稍后的UI中使用这个实用程序。</p><h1 id="576a" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">用户模型</h1><p id="0203" class="pw-post-body-paragraph iq ir hi is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hb bi translated">我们的用户模型将与我们的汽车模型相关联；一个用户可以拥有<em class="kw">多辆</em>汽车。这要求我们在用户模型中进行反序列化，以额外处理汽车的反序列化；</p><pre class="kx ky kz la fd lb js lc ld aw le bi"><span id="7379" class="lf ju hi js b fi lg lh l li lj">// src/app/models/user.model.ts<br/><br/>import {Deserializable} from './deserializable.model';<br/>import {Car} from './car.model';<br/><br/>export class User implements Deserializable {<br/>  public id: number;<br/>  public firstName: string;<br/>  public lastName: string;<br/>  public position: string;<br/>  public cars: Car[];<br/><br/>  deserialize(input: any): this {<br/>    // Assign input to our object BEFORE deserialize our cars to prevent already deserialized cars from being overwritten.<br/>    Object.assign(this, input);<br/><br/>    // Iterate over all cars for our user and map them to a proper `Car` model<br/>    this.cars = input.cars.map(car =&gt; new Car().deserialize(car));<br/><br/>    return this;<br/>  }<br/>  <br/>  getFullName() {<br/>    return this.firstName + ' ' + this.lastName;<br/>  }<br/>}</span></pre><p id="3dbc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个反序列化方法的工作方式<em class="kw">与我们的car略有不同；在</em>将我们的输入分配给用户模型之后，我们需要反序列化我们的汽车<em class="kw">，以防止输入覆盖我们的汽车属性。</em></p><p id="11e5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因为我们知道<code class="du jp jq jr js b">input.cars</code>是一个数组，所以我们使用了<code class="du jp jq jr js b"><a class="ae jo" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map" rel="noopener ugc nofollow" target="_blank">Array.prototype.map()</a></code>。这将遍历我们的所有元素(在我们的例子中:我们的汽车)，反序列化它们并返回一个包含反序列化模型的数组。</p><blockquote class="ll lm ln"><p id="ff3c" class="iq ir kw is b it iu iv iw ix iy iz ja lo jc jd je lp jg jh ji lq jk jl jm jn hb bi translated"><strong class="is lk"> <em class="hi">注</em> </strong> <em class="hi">:如果你想知道是否可以用</em> <code class="du jp jq jr js b"><a class="ae jo" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach" rel="noopener ugc nofollow" target="_blank"><em class="hi">Array.prototype.forEach()</em></a></code> <em class="hi"> : </em>不行！<em class="hi"/><code class="du jp jq jr js b"><em class="hi">forEach</em></code><em class="hi">和</em> <code class="du jp jq jr js b"><em class="hi">map</em></code> <em class="hi">的最大区别在于</em> <code class="du jp jq jr js b"><em class="hi">map</em></code> <em class="hi"> </em>返回一个新数组<em class="hi">而</em> <code class="du jp jq jr js b"><em class="hi">forEach</em></code> <em class="hi">只是将提供的回调应用于我们所有的数组项——但不返回一个新数组。</em></p></blockquote><p id="1f14" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们再次实现了一个实用方法来直接获取用户的全名。</p><p id="41cc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这就是我们的模型。让我们通过我们的服务来查询它们吧！</p><h1 id="9d5f" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">用户服务程序</h1><p id="a3cf" class="pw-post-body-paragraph iq ir hi is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hb bi translated">自从我的上一篇指南以来，一个主要的变化是<code class="du jp jq jr js b">HttpClient</code>的工作方式。它已经变得通用了，这意味着我们可以告诉它，我们期望什么类型的反应。</p><pre class="kx ky kz la fd lb js lc ld aw le bi"><span id="cf0b" class="lf ju hi js b fi lg lh l li lj">// src/app/services/user.service.ts<br/><br/>import {Injectable} from '@angular/core';<br/>import {HttpClient} from '@angular/common/http';<br/>import {Observable} from 'rxjs';<br/>import {User} from '../models/user.model';<br/>import {map} from 'rxjs/operators';<br/><br/>@Injectable({<br/>  providedIn: 'root'<br/>})<br/>export class UserService {<br/><br/>  constructor(private httpService: HttpClient) {<br/>  }<br/>  <br/>  public getUser(id: number): Observable&lt;User&gt; {<br/>    return this.httpService.get&lt;User&gt;(`http://localhost:3000/user/${id}`).pipe(<br/>      map(data =&gt; new User().deserialize(data)),<br/>      catchError(() =&gt; throwError('User not found'))<br/>    );<br/>  }<br/><br/>  public getAllUsers(): Observable&lt;User[]&gt; {<br/>    return this.httpService.get&lt;User[]&gt;(`http://localhost:3000/users`).pipe(<br/>      map(data =&gt; data.map(data =&gt; new User().deserialize(data)))<br/>    );<br/>  }<br/>}</span></pre><p id="e4db" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里有两个方法:一个用于查询特定用户，另一个用于查询所有用户。</p><p id="abdb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">两种方法都通过from RxJS将它们的响应映射到我们的模型。我们的<code class="du jp jq jr js b">getUser</code>方法额外实现了一些错误处理，这在试图查询一个不存在的用户时很有用。</p><p id="f5e9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这就是我们的服务。我们现在可以通过我们的服务使用我们的模型！</p><h1 id="0030" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">应用程序组件</h1><p id="bcc1" class="pw-post-body-paragraph iq ir hi is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hb bi translated">我们的应用程序组件将有两个非常简单的特性:查询一个特定的用户(使用<code class="du jp jq jr js b">getUser</code>服务方法)和查询所有用户(使用<code class="du jp jq jr js b">getAllUsers</code>服务方法)。为了简单起见，我们将把两个功能的逻辑放在一个组件中。</p><p id="cad5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们从模板开始:</p><pre class="kx ky kz la fd lb js lc ld aw le bi"><span id="8243" class="lf ju hi js b fi lg lh l li lj">&lt;!-- src/app/app.component.html --&gt;<br/><br/>&lt;div style="width: 400px; margin: auto;"&gt;<br/>  &lt;h2&gt;Angular 7 model showcase&lt;/h2&gt;<br/>  &lt;input type="number" [(ngModel)]="userId" placeholder="User ID"&gt;<br/>  &lt;button type="button" (click)="getUser()"&gt;Get user&lt;/button&gt;<br/><br/>  &lt;button type="button" (click)="getAllUsers()"&gt;Get all users&lt;/button&gt;<br/><br/>  &lt;div *ngIf="user"&gt;<br/>    User is called {{user.getFullName()}}. He has the following cars:<br/>    &lt;ul&gt;<br/>      &lt;li *ngFor="let car of user.cars"&gt;<br/>        {{car.brand}} {{car.model}} with {{car.getHp()}} hp.<br/>      &lt;/li&gt;<br/>    &lt;/ul&gt;<br/>  &lt;/div&gt;<br/><br/>  &lt;div *ngIf="users"&gt;<br/>    &lt;hr&gt;<br/><br/>    &lt;ul&gt;<br/>      &lt;li *ngFor="let user of users;"&gt;<br/>        {{user.getFullName()}} is {{user.position}} and has {{user.cars.length}} cars<br/>      &lt;/li&gt;<br/>    &lt;/ul&gt;<br/>  &lt;/div&gt;<br/>&lt;/div&gt;</span></pre><p id="af87" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这将把我们带到这个<em class="kw">非常漂亮的</em>用户界面:</p><figure class="kx ky kz la fd ij er es paragraph-image"><div class="er es lr"><img src="../Images/3809581a92aed204043548187ec6eb0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:776/format:webp/0*Hm7PA88y-K7eXw4p.png"/></div></figure><p id="d300" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在它完全工作之前，我们需要实现附加在按钮上的点击事件；</p><pre class="kx ky kz la fd lb js lc ld aw le bi"><span id="75ec" class="lf ju hi js b fi lg lh l li lj">import {Component} from '@angular/core';<br/>import {UserService} from './services/user.service';<br/>import {User} from './models/user.model';<br/><br/>@Component({<br/>  selector: 'app-root',<br/>  templateUrl: './app.component.html',<br/>  styleUrls: ['./app.component.css']<br/>})<br/>export class AppComponent {<br/>  public userId: number;<br/><br/>  public user: User;<br/><br/>  public users: User[];<br/><br/>  constructor(private userService: UserService) {<br/>  }<br/><br/>  public getUser() {<br/>    this.userService.getUser(this.userId).subscribe(user =&gt; this.user = user);<br/>  }<br/><br/>  public getAllUsers() {<br/>    this.userService.getAllUsers().subscribe(users =&gt; this.users = users);<br/>  }<br/>}</span></pre><p id="947f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">瞧，我们完成了:</p><figure class="kx ky kz la fd ij er es paragraph-image"><div class="er es ls"><img src="../Images/474bccf82ada47d6354a51de3659f31f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/0*Rdim5UXDkjyiL8Z1.gif"/></div></figure><p id="506d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="kw">惊讶于我们</em> <code class="du jp jq jr js b"><em class="kw">getHp</em></code> <em class="kw">方法的这种近乎疯狂的kW到HP的转换，因为我已经忘记四舍五入了！</em></p><p id="c8ec" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们模板中的所有用户交互现在都是我们的<code class="du jp jq jr js b">User</code>对象的一个实例(每个用户的汽车都是<code class="du jp jq jr js b">Car</code>的一个实例)——这意味着我们可以使用所有的助手工具并与真正的对象一起工作。</p><h1 id="9067" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">结论</h1><p id="5204" class="pw-post-body-paragraph iq ir hi is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hb bi translated">处理真实的对象而不是原始的JSON会让你的生活变得容易得多(参见我之前的关于这种方法的优点的指南)。</p><p id="6d3d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">和往常一样，你可以在GitHub 上找到该指南的完整源代码。</p></div><div class="ab cl lt lu gp lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="hb hc hd he hf"><p id="f1ee" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你喜欢这篇文章，请留下👏，关注我上 <a class="ae jo" href="https://twitter.com/nehalist" rel="noopener ugc nofollow" target="_blank"> <em class="kw">推特</em> </a> <em class="kw">并订阅</em> <a class="ae jo" href="https://nehalist.io/newsletter/" rel="noopener ugc nofollow" target="_blank"> <em class="kw">我的快讯</em> </a> <em class="kw">。原载于2019年4月18日</em><a class="ae jo" href="https://nehalist.io/angular-7-models/" rel="noopener ugc nofollow" target="_blank"><em class="kw">https://nehalist . io</em></a><em class="kw">。</em></p></div></div>    
</body>
</html>