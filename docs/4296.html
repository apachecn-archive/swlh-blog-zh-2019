<html>
<head>
<title>Implementing a hexagonal architecture</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">实现六边形架构</h1>
<blockquote>原文：<a href="https://medium.com/swlh/implementing-a-hexagonal-architecture-bcfbe0d63622?source=collection_archive---------7-----------------------#2019-05-30">https://medium.com/swlh/implementing-a-hexagonal-architecture-bcfbe0d63622?source=collection_archive---------7-----------------------#2019-05-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/024f6d47b116790f43e647c743632707.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v8JaK0qd1s5cd6mmLH_-Uw.jpeg"/></div></div></figure><div class=""/><p id="3f6a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">六边形架构简化了推迟或更改技术决策。你想换一个不同的框架？编写一个新的适配器。你想使用数据库，而不是在文件中存储数据？同样，为它编写一个适配器。</p><p id="7189" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">围绕业务逻辑画一个边界。六边形。六边形内的任何东西都必须与技术无关。<br/>六边形的外部只能通过称为端口的接口与内部通信。反过来也一样。通过改变一个端口的实现，你改变了技术。</p><p id="8afb" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">将业务逻辑隔离在六边形内部还有另一个好处。它支持为业务逻辑编写快速、稳定的测试。例如，他们不依赖网络技术来驱动他们。</p><p id="c56f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是一个示例图。它用虚线框表示Spring MVC技术，用实线框表示端口和适配器，用六边形表示内部结构:</p><figure class="jp jq jr js fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es jo"><img src="../Images/f1235f33f9157dd7643b864199072224.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*-hbEGp40-1cKdpoo.png"/></div></div></figure><p id="0516" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">适配器在特定技术和技术自由端口之间进行转换。左边的<code class="du jt ju jv jw b">PoemController</code>适配器接收请求并向<code class="du jt ju jv jw b">IReactToCommands</code>端口发送命令。<code class="du jt ju jv jw b">PoemController</code>是一个普通的Spring MVC控制器。因为它主动使用端口，所以它被称为驱动程序适配器。</p><p id="fa11" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du jt ju jv jw b">IReactToCommands</code>称为驱动端口。它的实现在六边形内部。图上没有显示出来。</p><p id="f641" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在右侧，<code class="du jt ju jv jw b">SpringMvcPublisher</code>适配器实现了<code class="du jt ju jv jw b">IWriteLines</code>端口。这一次，<em class="jx">六角</em>通过端口调用适配器。这就是为什么<code class="du jt ju jv jw b">SpringMvcPublisher</code>被称为从动适配器。而<code class="du jt ju jv jw b">IWriteLines</code>称为从动端口。</p><p id="e231" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我将向您展示如何实现该应用程序。我们从一个用户故事一直到六边形内部的领域模型。我们从打印到控制台的应用程序的简单版本开始。然后我们切换到Spring Boot和春天MVC。</p><h1 id="8065" class="jy jz ht bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">从用户故事到端口和适配器</h1><p id="5d7e" class="pw-post-body-paragraph iq ir ht is b it kw iv iw ix kx iz ja jb ky jd je jf kz jh ji jj la jl jm jn hb bi translated">FooBars.io公司决定开发一款诗歌应用。产品所有者和开发人员同意以下用户故事:</p><p id="25a3" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">作为一个读者，我想每天至少读一首诗，这样我才能作为一个人茁壮成长</p><p id="bea6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">作为验收标准，团队同意:</p><ul class=""><li id="1ae3" class="lb lc ht is b it iu ix iy jb ld jf le jj lf jn lg lh li lj bi translated">当用户要求一首特定语言的诗时，系统会在控制台中随机显示一首该语言的诗</li><li id="c85c" class="lb lc ht is b it lk ix ll jb lm jf ln jj lo jn lg lh li lj bi translated">一开始“模拟”用户是可以的，即没有真正的用户交互。(这在以后的版本中会有所改变。)</li><li id="80ac" class="lb lc ht is b it lk ix ll jb lm jf ln jj lo jn lg lh li lj bi translated">支持的语言:英语、德语</li></ul><p id="981a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">开发人员会面并绘制了下图:</p><figure class="jp jq jr js fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es jo"><img src="../Images/3ecd2893829f712b7f945f854fec806d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NvAHpj_cd80bUNYP.PNG"/></div></div></figure><p id="58e9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此<code class="du jt ju jv jw b">SimulatedUser</code>向<code class="du jt ju jv jw b">IReactToCommands</code>端口发送命令。它要求用英语和德语写诗。这是代码，可以在<a class="ae lp" href="https://github.com/bertilmuth/poem-hexagon" rel="noopener ugc nofollow" target="_blank"> Github </a>上找到。</p><p id="9593" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jx">诗/简单/驱动_适配器/</em><a class="ae lp" href="https://github.com/bertilmuth/poem-hexagon/blob/master/src/main/java/poem/simple/driver_adapter/SimulatedUser.java" rel="noopener ugc nofollow" target="_blank"><em class="jx">SimulatedUser.java</em></a></p><figure class="jp jq jr js fd hk"><div class="bz dy l di"><div class="lq lr l"/></div></figure><p id="5298" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du jt ju jv jw b">IReactToCommands</code>端口只有一种方法来接收任何类型的命令。</p><p id="9c5d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jx">诗/边界/司机_港口/</em>【IReactToCommands.java】<em class="jx"/></p><figure class="jp jq jr js fd hk"><div class="bz dy l di"><div class="lq lr l"/></div></figure><p id="c4d4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du jt ju jv jw b">AskForPoem</code>是命令。实例是简单的、不可变的POJOs。它们带有所要求的诗的语言。</p><p id="baea" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jx">诗/命令/</em><a class="ae lp" href="https://github.com/bertilmuth/poem-hexagon/blob/master/src/main/java/poem/command/AskForPoem.java" rel="noopener ugc nofollow" target="_blank"><em class="jx">AskForPoem.java</em></a></p><figure class="jp jq jr js fd hk"><div class="bz dy l di"><div class="lq lr l"/></div></figure><p id="ea1d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这就是六边形左侧的驾驶员侧。在右侧，从动侧。</p><figure class="jp jq jr js fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es jo"><img src="../Images/95e1ca14346aace4a524e602b2547905.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*A7kKDC-8gBDeHePD.PNG"/></div></div></figure><p id="fc5b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当<code class="du jt ju jv jw b">SimulatedUser</code>向<code class="du jt ju jv jw b">IReactToCommands</code>端口索要一首诗时，六边形:</p><ol class=""><li id="3bf5" class="lb lc ht is b it iu ix iy jb ld jf le jj lf jn ls lh li lj bi translated">联系<code class="du jt ju jv jw b">IObtainPoems</code>港口索取诗集</li><li id="e38a" class="lb lc ht is b it lk ix ll jb lm jf ln jj lo jn ls lh li lj bi translated">从诗集里随机挑选一首诗</li><li id="b21c" class="lb lc ht is b it lk ix ll jb lm jf ln jj lo jn ls lh li lj bi translated">告诉<code class="du jt ju jv jw b">IWriteLines</code>端口将诗写到输出设备</li></ol><p id="2e13" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你还看不到第二步。在领域模型中，它发生在六边形内部。这就是示例的业务逻辑。所以我们先关注第一步和第三步。</p><p id="bf44" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在步骤1中，诗集是一个依赖于语言的硬编码数组。它由实现<code class="du jt ju jv jw b">IObtainPoems</code>端口的<code class="du jt ju jv jw b">HardcodedPoemLibrary</code>适配器提供。</p><p id="eae2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jx">诗/边界/驱动_端口/</em><a class="ae lp" href="https://github.com/bertilmuth/poem-hexagon/blob/master/src/main/java/poem/boundary/driven_port/IObtainPoems.java" rel="noopener ugc nofollow" target="_blank"><em class="jx">IObtainPoems.java</em></a></p><figure class="jp jq jr js fd hk"><div class="bz dy l di"><div class="lq lr l"/></div></figure><p id="d6c0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jx">诗/简单/驱动_适配器/</em><a class="ae lp" href="https://github.com/bertilmuth/poem-hexagon/blob/master/src/main/java/poem/simple/driven_adapter/HardcodedPoemLibrary.java" rel="noopener ugc nofollow" target="_blank"><em class="jx">HardcodedPoemLibrary.java</em></a></p><figure class="jp jq jr js fd hk"><div class="bz dy l di"><div class="lq lr l"/></div></figure><p id="9af7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在步骤3中，<code class="du jt ju jv jw b">ConsoleWriter</code>适配器将诗歌的行写入输出设备，即控制台。</p><p id="57dc" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jx">诗/边界/驱动_端口/</em><a class="ae lp" href="https://github.com/bertilmuth/poem-hexagon/blob/master/src/main/java/poem/boundary/driven_port/IWriteLines.java" rel="noopener ugc nofollow" target="_blank"><em class="jx">IWriteLines.java</em></a></p><figure class="jp jq jr js fd hk"><div class="bz dy l di"><div class="lq lr l"/></div></figure><p id="75bd" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jx">诗/简单/驱动_适配器/</em><a class="ae lp" href="https://github.com/bertilmuth/poem-hexagon/blob/master/src/main/java/poem/simple/driven_adapter/ConsoleWriter.java" rel="noopener ugc nofollow" target="_blank"><em class="jx">ConsoleWriter.java</em></a></p><figure class="jp jq jr js fd hk"><div class="bz dy l di"><div class="lq lr l"/></div></figure><p id="036f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们已经创建了所有的端口，以及所有适配器的简单实现。到目前为止，六角形的内部仍然是一个谜。接下来就是了。</p><figure class="jp jq jr js fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es jo"><img src="../Images/805005e3e0c26def965105f1dea07c23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*oIeS3RCV_0jY5oGm.PNG"/></div></div></figure><h1 id="e164" class="jy jz ht bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">命令处理程序(在六边形内部)</h1><p id="fd4e" class="pw-post-body-paragraph iq ir ht is b it kw iv iw ix kx iz ja jb ky jd je jf kz jh ji jj la jl jm jn hb bi translated">当用户要求一首诗时，系统会显示一首随机的诗。<br/>代码类似:当<code class="du jt ju jv jw b">IReactToCommands</code>端口收到一个<code class="du jt ju jv jw b">AskForPoem</code>命令时，hexagon调用一个<code class="du jt ju jv jw b">DisplayRandomPoem</code>命令处理程序。</p><p id="789e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du jt ju jv jw b">DisplayRandomPoem</code>命令处理器获得一个诗歌列表，随机挑选一首，并将其写入输出设备。这正是我们在上一个条款中谈到的步骤列表。</p><p id="09d3" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jx">诗/边界/内部/命令_处理程序/【DisplayRandomPoem.java】<a class="ae lp" href="https://github.com/bertilmuth/poem-hexagon/blob/master/src/main/java/poem/boundary/internal/command_handler/DisplayRandomPoem.java" rel="noopener ugc nofollow" target="_blank"><em class="jx"/></a></em></p><figure class="jp jq jr js fd hk"><div class="bz dy l di"><div class="lq lr l"/></div></figure><p id="25e3" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在域模型数据和端口接口中使用的数据之间进行转换也是命令处理程序的工作。</p><h1 id="ae3f" class="jy jz ht bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">将命令绑定到命令处理程序</h1><p id="001b" class="pw-post-body-paragraph iq ir ht is b it kw iv iw ix kx iz ja jb ky jd je jf kz jh ji jj la jl jm jn hb bi translated">在我的六边形架构的实现中，只有一个驱动程序端口，<code class="du jt ju jv jw b">IReactToCommands</code>。它对所有类型的命令都有反应。</p><figure class="jp jq jr js fd hk"><div class="bz dy l di"><div class="lq lr l"/></div></figure><p id="2d4f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du jt ju jv jw b">Boundary</code>类是<code class="du jt ju jv jw b">IReactToCommands</code>端口的实现。它使用<a class="ae lp" href="https://github.com/bertilmuth/requirementsascode" rel="noopener ugc nofollow" target="_blank">库</a>创建一个行为模型。行为模型将每种命令类型映射到一个命令处理程序。然后，一个行为基于该行为模型调度命令。</p><p id="6422" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jx">诗/界/</em><a class="ae lp" href="https://github.com/bertilmuth/poem-hexagon/blob/master/src/main/java/poem/boundary/Boundary.java" rel="noopener ugc nofollow" target="_blank"><em class="jx">Boundary.java</em></a></p><figure class="jp jq jr js fd hk"><div class="bz dy l di"><div class="lq lr l"/></div></figure><h1 id="fdee" class="jy jz ht bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">领域模型</h1><p id="0f68" class="pw-post-body-paragraph iq ir ht is b it kw iv iw ix kx iz ja jb ky jd je jf kz jh ji jj la jl jm jn hb bi translated">这个例子的领域模型没有非常有趣的功能。随机挑选者从列表中随机挑选一首诗。</p><p id="2882" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一首<a class="ae lp" href="https://github.com/bertilmuth/poem-hexagon/blob/master/src/main/java/poem/boundary/internal/domain/Poem.java" rel="noopener ugc nofollow" target="_blank">诗</a>有一个构造函数，它接受一个包含行分隔符的字符串，并把它分成几节。</p><p id="8476" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">关于示例域模型真正有趣的一点是:它不涉及数据库或任何其他技术，甚至不涉及接口！</p><p id="8fc5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这意味着你可以用<a class="ae lp" href="https://github.com/bertilmuth/poem-hexagon/blob/master/src/test/java/poem/boundary/internal/domain/RandomPoemPickerTest.java" rel="noopener ugc nofollow" target="_blank">简单的单元测试</a>来测试领域模型。你不需要嘲笑任何东西。</p><p id="e5a9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这种纯域模型不是实现六边形架构的应用程序的必要属性。但是我喜欢它提供的解耦和可测试性。</p><h1 id="fe04" class="jy jz ht bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">将适配器插入端口，就这样</h1><p id="0df0" class="pw-post-body-paragraph iq ir ht is b it kw iv iw ix kx iz ja jb ky jd je jf kz jh ji jj la jl jm jn hb bi translated">最后一步是让应用程序工作。应用程序需要一个主类来创建驱动适配器。它将它们注入边界。<br/>然后它为边界创建驱动程序适配器，并运行它。</p><p id="8d29" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jx">诗/简单/</em><a class="ae lp" href="https://github.com/bertilmuth/poem-hexagon/blob/master/src/main/java/poem/simple/Main.java" rel="noopener ugc nofollow" target="_blank"><em class="jx">Main.java</em></a></p><figure class="jp jq jr js fd hk"><div class="bz dy l di"><div class="lq lr l"/></div></figure><p id="9a7d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">就是这样！团队向产品负责人展示结果。她对进展很满意。是时候小小庆祝一下了。</p><figure class="jp jq jr js fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es jo"><img src="../Images/07676f11610cfa75894a8365172c83a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*q186zfScRX58ewXz.PNG"/></div></div></figure><h1 id="8bd7" class="jy jz ht bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">切换到Spring</h1><p id="6d02" class="pw-post-body-paragraph iq ir ht is b it kw iv iw ix kx iz ja jb ky jd je jf kz jh ji jj la jl jm jn hb bi translated">该团队决定将poem应用程序转变为web应用程序。并将诗歌储存在真实的数据库中。他们同意使用Spring框架来实现它。<br/>在开始编码之前，团队开会并绘制了下图:</p><figure class="jp jq jr js fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es jo"><img src="../Images/30ac796452e7b3040778c9c8bad94dc9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*GFfA3aOKzXoDxAv7.png"/></div></div></figure><p id="161e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在有一个<code class="du jt ju jv jw b">PoemController</code>代替了<code class="du jt ju jv jw b">SimulatedUser</code>，它向六边形发送命令。</p><p id="a893" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jx">诗/跳靴/驱动_适配器/</em><a class="ae lp" href="https://github.com/bertilmuth/poem-springboot/blob/master/src/main/java/poem/springboot/driver_adapter/PoemController.java" rel="noopener ugc nofollow" target="_blank">【PoemController.java】T21</a></p><figure class="jp jq jr js fd hk"><div class="bz dy l di"><div class="lq lr l"/></div></figure><p id="35f8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当收到命令时，<code class="du jt ju jv jw b">PoemController</code>调用<code class="du jt ju jv jw b">springMvcBoundary.basedOn(webModel)</code>。这将基于请求的<code class="du jt ju jv jw b">webModel</code>创建一个新的<code class="du jt ju jv jw b">Boundary</code>实例:</p><p id="e61a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jx">诗/步/界/</em><a class="ae lp" href="https://github.com/bertilmuth/poem-springboot/blob/master/src/main/java/poem/springboot/boundary/SpringMvcBoundary.java" rel="noopener ugc nofollow" target="_blank"><em class="jx">SpringMvcBoundary.java</em></a></p><figure class="jp jq jr js fd hk"><div class="bz dy l di"><div class="lq lr l"/></div></figure><p id="874d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">像以前一样，对<code class="du jt ju jv jw b">reactTo()</code>的调用将命令发送到边界。在六边形的右边，<code class="du jt ju jv jw b">SpringMvcPublisher</code>向Spring MVC模型添加了一个属性<code class="du jt ju jv jw b">lines</code>。这是百里香用来将行插入网页的值。</p><p id="fc07" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jx">诗/跳靴/从动_适配器/</em><a class="ae lp" href="https://github.com/bertilmuth/poem-springboot/blob/master/src/main/java/poem/springboot/driven_adapter/SpringMvcPublisher.java" rel="noopener ugc nofollow" target="_blank"><em class="jx">SpringMvcPublisher.java</em></a></p><figure class="jp jq jr js fd hk"><div class="bz dy l di"><div class="lq lr l"/></div></figure><p id="0cf9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">团队还实现了一个<code class="du jt ju jv jw b">PoemRepositoryAdapter</code>来访问<code class="du jt ju jv jw b">PoemRepository</code>。适配器从数据库中获取<code class="du jt ju jv jw b">Poem</code>对象。它以字符串数组的形式返回所有诗歌的文本。</p><p id="e563" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jx">诗/跳靴/从动_适配器/</em><a class="ae lp" href="https://github.com/bertilmuth/poem-springboot/blob/master/src/main/java/poem/springboot/driven_adapter/PoemRepositoryAdapter.java" rel="noopener ugc nofollow" target="_blank"><em class="jx">PoemRepositoryAdapter.java</em></a></p><figure class="jp jq jr js fd hk"><div class="bz dy l di"><div class="lq lr l"/></div></figure><p id="baa5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后，团队实现了<a class="ae lp" href="https://github.com/bertilmuth/poem-springboot/blob/master/src/main/java/poem/springboot/Application.java" rel="noopener ugc nofollow" target="_blank">应用程序</a>类，该类建立了一个示例存储库并将适配器插入端口。</p><p id="6c05" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">仅此而已。切换到Spring已完成。</p><h1 id="1f6e" class="jy jz ht bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">结论</h1><p id="432e" class="pw-post-body-paragraph iq ir ht is b it kw iv iw ix kx iz ja jb ky jd je jf kz jh ji jj la jl jm jn hb bi translated">有许多方法可以实现六边形架构。我向您展示了一种简单的方法，它为hexagon提供了一个易于使用的命令驱动的API。它减少了需要实现的接口数量。这导致了一个纯粹的领域模型。</p><p id="34c3" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你想获得更多关于这个话题的信息，读一读阿利斯泰尔·考克伯恩关于这个话题的原创文章。</p><p id="5678" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这篇文章中的例子是受阿利斯泰尔·考克伯恩关于这个主题的三部分系列讲座<a class="ae lp" href="https://www.youtube.com/playlist?list=PLGl1Jc8ErU1w27y8-7Gdcloy1tHO7NriL" rel="noopener ugc nofollow" target="_blank">的启发。</a></p><p id="ce03" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后编辑于2021年7月30日。你有问题吗？ <a class="ae lp" href="https://gitter.im/requirementsascode/community" rel="noopener ugc nofollow" target="_blank"> <strong class="is lt"> <em class="jx">和我在Gitter上聊天</em> </strong> </a> <strong class="is lt"> <em class="jx">。</em> </strong></p><p id="461e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jx">如果你想了解我正在做的事情或给我留言，请在</em> <a class="ae lp" href="https://www.linkedin.com/in/bertilmuth/" rel="noopener ugc nofollow" target="_blank"> <em class="jx"> LinkedIn </em> </a> <em class="jx">或</em><a class="ae lp" href="https://twitter.com/BertilMuth" rel="noopener ugc nofollow" target="_blank"><em class="jx">Twitter</em></a><em class="jx">上关注我。或者访问我的</em> <a class="ae lp" href="https://github.com/bertilmuth/requirementsascode" rel="noopener ugc nofollow" target="_blank"> <em class="jx"> GitHub项目</em> </a> <em class="jx">。要了解敏捷软件开发，</em> <a class="ae lp" href="https://skl.sh/2Cq497P" rel="noopener ugc nofollow" target="_blank"> <em class="jx">请访问我的在线课程</em> </a> <em class="jx">。</em></p></div></div>    
</body>
</html>