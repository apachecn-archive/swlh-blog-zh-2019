<html>
<head>
<title>The What and Why of the MVC App Design Philosophy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">MVC应用程序设计理念的内容和原因</h1>
<blockquote>原文：<a href="https://medium.com/swlh/the-what-and-why-of-the-mvc-app-design-philosophy-a08db0e8c028?source=collection_archive---------69-----------------------#2019-05-21">https://medium.com/swlh/the-what-and-why-of-the-mvc-app-design-philosophy-a08db0e8c028?source=collection_archive---------69-----------------------#2019-05-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="a858" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在过去的7天左右，我被介绍了一个叫做Ruby on Rails (Rails)的“网络应用框架”。从本质上来说，Rails是一个工具的集合，它消除了构建网站的大量重复性工作:生成文件和文件夹，给事物起适当的名字并把它们链接在一起，这太棒了。</p><h2 id="9d58" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">Rails功能强大，但令人望而生畏(起初)</h2><p id="dfd2" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">但是，有很多文件！以及如何将不同类型的代码分成不同类型的许多规则。这让我想知道Rail的核心设计理念(被称为“MVC”或模型-视图-控制器)从何而来。为了找到更多关于MVC的信息，我看了一个由<a class="ae kd" href="https://devmarketer.io/learn/category/code/" rel="noopener ugc nofollow" target="_blank"> J. Alexander Curtis </a>制作的很棒的<a class="ae kd" href="https://www.youtube.com/watch?v=1IsL6g2ixak" rel="noopener ugc nofollow" target="_blank">视频</a>。我会试着从这篇文章中提取关键要点，并加入一些我自己的见解，但是如果你有24分钟左右的时间，我鼓励你去<a class="ae kd" href="https://www.youtube.com/watch?v=1IsL6g2ixak" rel="noopener ugc nofollow" target="_blank">看看。</a></p><figure class="kf kg kh ki fd kj er es paragraph-image"><div class="er es ke"><img src="../Images/02abce5b6975d62695ceb18db688acb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*fhyRfUnyD0LDP_Cn.gif"/></div><figcaption class="km kn et er es ko kp bd b be z dx">A file structure built by Rails: building this common structure from scratch, app after app, would be tedious to say the least.</figcaption></figure><h2 id="3042" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">MVC比Rails大</h2><p id="0d7b" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">因此，需要澄清的是，MVC并不是一个像Rails一样的框架，而只是一个用于构建web应用程序的方法论，因此被许多框架使用。事实上，MVC是如此成功，以至于现在它被用在许多流行的应用程序框架中，包括:</p><ul class=""><li id="f005" class="kr ks hi ih b ii ij im in iq kt iu ku iy kv jc kw kx ky kz bi translated">Cake(用PHP编写的框架)</li><li id="5c91" class="kr ks hi ih b ii la im lb iq lc iu ld iy le jc kw kx ky kz bi translated">Django (Python)</li><li id="3563" class="kr ks hi ih b ii la im lb iq lc iu ld iy le jc kw kx ky kz bi translated">Laravel (PHP)</li><li id="50d0" class="kr ks hi ih b ii la im lb iq lc iu ld iy le jc kw kx ky kz bi translated">Zen (PHP)</li><li id="9995" class="kr ks hi ih b ii la im lb iq lc iu ld iy le jc kw kx ky kz bi translated">代码点火器(PHP)</li><li id="60bc" class="kr ks hi ih b ii la im lb iq lc iu ld iy le jc kw kx ky kz bi translated">iOS(目标C和Swift)</li></ul><h2 id="f77e" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">好吧，这很常见，可能相当重要，但为什么要麻烦<strong class="ak">？</strong></h2><p id="20aa" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">MVC与许多编码实践有着共同的准则——全能的<strong class="ih lf">关注点分离(SoC) </strong>。简而言之，这要求文件(或类、方法或任何代码集合)应该尽可能缩小责任范围。例如，在最小的尺度上，方法(又名“函数”)应该<em class="kq">理想地</em>只解决一个单一的任务。如果这个任务可以分成更小的任务，你应该把它分成更小的方法。首先，这种方法意味着调试要简单得多:错误消息倾向于指向更小的代码部分，帮助您更快地找到错误。</p><p id="0df1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为MVC采用了这种SoC原则，它继承了这种调试优势，但这并不是以这种方式构建应用程序的唯一好处:</p><ol class=""><li id="0482" class="kr ks hi ih b ii ij im in iq kt iu ku iy kv jc lg kx ky kz bi translated"><strong class="ih lf">并行开发</strong>:许多开发人员可以轻松地在同一个项目上工作，因为任何应用程序的某些功能的位置都有明确的定义。</li><li id="3b16" class="kr ks hi ih b ii la im lb iq lc iu ld iy le jc lg kx ky kz bi translated">不重复自己更容易:另一个核心开发原则是DRY(或者“不重复自己”)，清晰地组织你的代码有利于方法被<em class="kq">重用</em>，而不是<em class="kq">重写</em>。</li><li id="6079" class="kr ks hi ih b ii la im lb iq lc iu ld iy le jc lg kx ky kz bi translated"><strong class="ih lf">更容易修改:</strong>(这确实是MVC采用关注点分离的另一个优势)当你知道它的组件只在需要时相互依赖才能运行，而不是像<em class="kq">纸牌屋一样相互连接，你就可以更容易地添加或更改应用程序的特性:</em></li></ol><figure class="kf kg kh ki fd kj er es paragraph-image"><div class="er es lh"><img src="../Images/803321f2b55bcf7432fe0cb0e6ddfd1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:560/0*e_PwfqILWGpr4KnV.gif"/></div><figcaption class="km kn et er es ko kp bd b be z dx">An almost perfect metaphor for all of my early code.</figcaption></figure><h2 id="3d63" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">MVC的架构从何而来？</h2><figure class="kf kg kh ki fd kj er es paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="er es li"><img src="../Images/36755d55122d84acb448e553b009585e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z_rePCnReMXmBTTqrqZYGQ.png"/></div></div><figcaption class="km kn et er es ko kp bd b be z dx">The real world structure that inspired the MVC file structure. Credit: DevMarketer (YouTube)</figcaption></figure><p id="6a23" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我第一次听说MVC时没有注意到的一个核心问题是，它的结构是基于现实世界的，也就是说，甚至在一位挪威计算机科学家发明MVC之前，硬件是如何建立的。该结构来自于数据如何在三台计算机之间流动(如上)，每台计算机有不同的工作。在web-app上下文中，这三台计算机之间有严格的数据流:</p><ol class=""><li id="bd63" class="kr ks hi ih b ii ij im in iq kt iu ku iy kv jc lg kx ky kz bi translated">“客户端”:(你典型的家用电脑，运行你的网络浏览器，向你展示《权力的游戏》的结局)<strong class="ih lf">向“服务器”发出请求</strong>。</li><li id="feaa" class="kr ks hi ih b ii la im lb iq lc iu ld iy le jc lg kx ky kz bi translated">“服务器”(知道数据库语言并具有安全访问权)向数据库请求<strong class="ih lf">适当的数据以满足请求</strong>。</li><li id="8829" class="kr ks hi ih b ii la im lb iq lc iu ld iy le jc lg kx ky kz bi translated">“数据库”找到合适的数据，然后<strong class="ih lf">将其发送回</strong>；这可能是来自一个地方的一个东西(“可爱的小猫图片#12请”)，也可能是来自数据库中许多位置的许多东西(“所有毛绒绒的小猫图片请”)。</li><li id="4bb4" class="kr ks hi ih b ii la im lb iq lc iu ld iy le jc lg kx ky kz bi translated">然后，服务器使用这些数据以客户端可以理解的语言填充网页，并将其发送回客户端。</li><li id="283c" class="kr ks hi ih b ii la im lb iq lc iu ld iy le jc lg kx ky kz bi translated">客户端(你的笔记本电脑/浏览器)<strong class="ih lf">然后呈现</strong>你想看的任何东西！</li></ol></div><div class="ab cl ln lo gp lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="hb hc hd he hf"><h2 id="a5c4" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">我被卖了，那MVC怎么分东西？</h2><p id="084c" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">因此，MVC采用上述信息流的结构，并将其映射到应用程序的文件结构上。上述三台计算机中的每一台都有一个与之交互的代码对应文件:数据库获取“模型”文件夹中的代码，客户端相关代码在“视图”中，服务器获取“控制器”文件夹:</p><p id="c1ea" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih lf">数据库→模型:</strong>“模型”文件夹包含与数据库交互相关的代码，它:</p><ul class=""><li id="352d" class="kr ks hi ih b ii ij im in iq kt iu ku iy kv jc kw kx ky kz bi translated">从数据库中添加和检索项目</li><li id="dd4d" class="kr ks hi ih b ii la im lb iq lc iu ld iy le jc kw kx ky kz bi translated">处理数据库中的数据</li><li id="e17a" class="kr ks hi ih b ii la im lb iq lc iu ld iy le jc kw kx ky kz bi translated"><em class="kq">只有</em>与控制器对话</li></ul><p id="ceef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih lf">客户端→视图:</strong>“视图”文件夹包含发送给客户端的代码</p><ul class=""><li id="f6c4" class="kr ks hi ih b ii ij im in iq kt iu ku iy kv jc kw kx ky kz bi translated">用户直接与之交互的唯一代码</li><li id="e172" class="kr ks hi ih b ii la im lb iq lc iu ld iy le jc kw kx ky kz bi translated">代码<strong class="ih lf">只听</strong>控制器(如下):也就是说，它不做自己的决定(但是发回用户输入)</li></ul><p id="eadf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih lf">服务器→控制器:</strong>‘控制器’文件夹包含代码，这些代码是<em class="kq">处理来自数据库的信息。并在数据发送到视图之前对其进行处理。</em></p><ul class=""><li id="3ed3" class="kr ks hi ih b ii ij im in iq kt iu ku iy kv jc kw kx ky kz bi translated">实际上，这是谁(或什么)在负责</li></ul><figure class="kf kg kh ki fd kj er es paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="er es lu"><img src="../Images/dad3566f4ee4a3d14d3506c5e2c9ebde.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*V3V4QZIMZaCPbaJb"/></div></div><figcaption class="km kn et er es ko kp bd b be z dx">Database = Model Folder; Server = Controller; Client = View {Credit: DevMarketer (YouTube)}*</figcaption></figure><p id="1565" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一个附带说明是，Rails和所有框架都有“路由处理”(见上图)。这选择了向哪个“控制器】发送请求的<em class="kq">。事实上，每个模型(read: type或<em class="kq"> Class </em> of data)都有自己的控制器；是的，这是更多的<strong class="ih lf">关注点分离</strong>。在Rails中，这个路由处理被指定到一个名为“routes.rb”的文件中，它包含在MVC结构之外(在Rails的“config”文件夹中)，只有在找出哪个控制器(以及相应的模型)应该用于任何给定的请求时才会被引用。</em></p><p id="4114" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，路由处理器可能会将<a class="ae kd" href="http://www.mywebsite.com/blog" rel="noopener ugc nofollow" target="_blank">www.mywebsite.com/blog</a>发送到一个名为“BlogPostsContoller”的控制器，该控制器只会与一个名为“Posts”的模型对话，而后者本身只关心处理文本、gif等内容的代码。这一切是如此奇妙的分离，不是吗？</p></div></div>    
</body>
</html>