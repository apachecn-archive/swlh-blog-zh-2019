<html>
<head>
<title>C++ Rvalues, Move Semantics, and Copy Elision.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C++右值，移动语义，复制省略。</h1>
<blockquote>原文：<a href="https://medium.com/swlh/c-rvalues-move-semantics-and-copy-elision-36d492da5446?source=collection_archive---------22-----------------------#2019-05-30">https://medium.com/swlh/c-rvalues-move-semantics-and-copy-elision-36d492da5446?source=collection_archive---------22-----------------------#2019-05-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="0ca8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我写了第一篇关于c++的文章<a class="ae jd" rel="noopener" href="/@yang.kevvy/c-pass-by-value-pointer-reference-ddc3780d907c">通过值、指针和引用传递参数</a>之后，我收到了许多关于<em class="je">右值</em>、<em class="je">移动语义</em>和<em class="je">复制省略</em>的请求。对于使用其他编程语言的人来说，这些很可能是新的术语，即使是长期的C++程序员也可能从未听说过这些术语。本文将通过一些简单明了的例子来解释这些术语的含义。</p></div><div class="ab cl jf jg gp jh" role="separator"><span class="ji bw bk jj jk jl"/><span class="ji bw bk jj jk jl"/><span class="ji bw bk jj jk"/></div><div class="hb hc hd he hf"><h1 id="b2d9" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">右值</h1><p id="bdd9" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">右值是临时值。右值之所以这样叫是因为它们通常位于赋值的右侧。它们可以被赋给其他变量，但不能被赋值。例子包括非字符串文字和函数调用。在下面的例子中，<code class="du kp kq kr ks b">1</code>和<code class="du kp kq kr ks b">foo()</code>是右值。它们用于初始化变量<code class="du kp kq kr ks b">a</code>和<code class="du kp kq kr ks b">b</code>。<code class="du kp kq kr ks b">a</code>和<code class="du kp kq kr ks b">b</code>被称为左值(“左”值)。</p><pre class="kt ku kv kw fd kx ks ky kz aw la bi"><span id="5039" class="lb jn hi ks b fi lc ld l le lf">int a = 1;<br/>int b = foo();</span></pre><p id="03dc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下列语句无法编译。<code class="du kp kq kr ks b">1</code>和<code class="du kp kq kr ks b">foo()</code>是临时的。不可能给它们赋值，也没有语义意义。</p><pre class="kt ku kv kw fd kx ks ky kz aw la bi"><span id="f972" class="lb jn hi ks b fi lc ld l le lf">1 = c; // error<br/>foo() = d; // error</span></pre><p id="bf84" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如何判断一个值是否是临时的？根据一般经验，如果一个值没有标识符或名称，它就是临时的。所以如果一个值被一个变量捕获，它就不是一个右值。举个例子，</p><pre class="kt ku kv kw fd kx ks ky kz aw la bi"><span id="df98" class="lb jn hi ks b fi lc ld l le lf">int bar = 1; // bar is a name, so it is an lvalue.<br/>2; // 2 is an integer literal, it has no name (no identifier). It is<br/>   // an rvalue.</span></pre><p id="ef6c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以做的另一个测试是使用地址操作符(&amp;)。不可能获取右值的地址。</p><pre class="kt ku kv kw fd kx ks ky kz aw la bi"><span id="a9fb" class="lb jn hi ks b fi lc ld l le lf">int a = 1;<br/>&amp;a; // Works, a is a stack-allocated variable.<br/>&amp;1; // Error, 1 is an integer literal.<br/>&amp;foo(); // Error, cannot take address of the temporary result of a <br/>        // function call.</span></pre><p id="1025" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">右值是C++语言的一个重要补充，因为它们允许所谓的<strong class="ih lg">移动</strong>。</p></div><div class="ab cl jf jg gp jh" role="separator"><span class="ji bw bk jj jk jl"/><span class="ji bw bk jj jk jl"/><span class="ji bw bk jj jk"/></div><div class="hb hc hd he hf"><h1 id="3f19" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">移动语义</h1><p id="3e75" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">假设有一个大对象，它的数据正在被转移到同类型的另一个对象。在C++和许多其他编程语言中，这可以通过昂贵的拷贝来实现。</p><pre class="kt ku kv kw fd kx ks ky kz aw la bi"><span id="89cf" class="lb jn hi ks b fi lc ld l le lf">SomeBigObject obj1;<br/>SomeBigObject obj2 = obj1; // Expensive copy.</span></pre><p id="b718" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">C++11引入了移动的概念，使这种操作更加有效。移动允许一个对象“接管”或“窃取”另一个对象的数据。</p><pre class="kt ku kv kw fd kx ks ky kz aw la bi"><span id="0e09" class="lb jn hi ks b fi lc ld l le lf">SomeBigObject obj1;<br/>SomeBigObject obj2 = std::move(obj1); // Efficient move.</span></pre><p id="3839" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在<code class="du kp kq kr ks b">obj2</code>与<code class="du kp kq kr ks b">obj1</code>相同，没有复制任何数据，导致<code class="du kp kq kr ks b">obj2</code>非常有效的初始化。问题是<code class="du kp kq kr ks b">obj1</code>现在处于无效状态，因为它的数据成员刚刚被窃取。例如:</p><pre class="kt ku kv kw fd kx ks ky kz aw la bi"><span id="df6f" class="lb jn hi ks b fi lc ld l le lf">struct SomeBigObject {<br/>  // Constructor and other methods.<br/>  ...</span><span id="8436" class="lb jn hi ks b fi lh ld l le lf">  // Copy constructor.<br/>  SomeBigObject(const SomeBigObject&amp; other) {<br/>    *foo = *other.foo;<br/>  }</span><span id="e1bc" class="lb jn hi ks b fi lh ld l le lf">  // Move constructor.<br/>  SomeBigObject(SomeBigObject&amp;&amp; other) {<br/>    foo = other.foo;<br/>    other.foo = nullptr;<br/>  }</span><span id="b118" class="lb jn hi ks b fi lh ld l le lf">  // Data members. Foo is allocated on the heap and could be large.<br/>  Foo* foo;<br/>}</span></pre><p id="e089" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当一个类型为<code class="du kp kq kr ks b">SomeBigObject</code>的对象通过移动另一个相同类型的对象进行初始化时，调用<em class="je">移动构造函数</em>。<em class="je">移动构造函数</em>从源对象中窃取<code class="du kp kq kr ks b">Foo</code>指针，并将源对象的<code class="du kp kq kr ks b">Foo</code>指针设置为<code class="du kp kq kr ks b">nullptr</code>。这是一个<code class="du kp kq kr ks b">O(1)</code>操作，使源对象处于无效状态，其中<code class="du kp kq kr ks b">foo</code>为<code class="du kp kq kr ks b">nullptr</code>。<code class="du kp kq kr ks b">other</code>的<code class="du kp kq kr ks b">foo</code>对象被‘偷’了。</p><p id="f026" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这不同于复制同类型的另一个对象，后者调用<em class="je">复制构造函数</em>。在<em class="je">复制构造函数</em>中，源对象的整个<code class="du kp kq kr ks b">Foo</code>成员被复制到目标对象的<code class="du kp kq kr ks b">foo</code>成员变量中，这可能是一个非常昂贵的复制。</p><p id="090d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在某些情况下，让源对象处于无效状态是不可取的，但是如果源对象是一个临时的右值，这就不是问题。移动右值非常有用。其他一些类型，如<code class="du kp kq kr ks b">std::unique_ptr</code> s，只允许移动。</p></div><div class="ab cl jf jg gp jh" role="separator"><span class="ji bw bk jj jk jl"/><span class="ji bw bk jj jk jl"/><span class="ji bw bk jj jk"/></div><div class="hb hc hd he hf"><h1 id="62a8" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">复制省略</h1><p id="0cda" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">假设有一个大对象从一个构造函数中返回。</p><pre class="kt ku kv kw fd kx ks ky kz aw la bi"><span id="6864" class="lb jn hi ks b fi lc ld l le lf">SomeBigObject BuildBigObject(){<br/>  SomeBigObject foo;<br/>  // Initialize foo...<br/>  return foo;<br/>}</span><span id="5d7d" class="lb jn hi ks b fi lh ld l le lf">SomeBigObject bar = BuildBigObject();</span></pre><p id="8402" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了初始化<code class="du kp kq kr ks b">bar</code>,函数作用域的<code class="du kp kq kr ks b">foo</code>必须从函数的堆栈框架中复制到外部作用域的<code class="du kp kq kr ks b">bar</code>变量中，这是一个昂贵的复制。如果有一种方法可以让<code class="du kp kq kr ks b">bar</code>成为函数作用域的<code class="du kp kq kr ks b">foo</code>(也就是说，每当使用<code class="du kp kq kr ks b">foo</code>时，就用<code class="du kp kq kr ks b">bar</code>来代替)会怎么样？).这种优化称为复制省略，与移动类似，但不完全相同。</p><p id="7844" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">记住<code class="du kp kq kr ks b">BuildBigObject</code>的返回值是一个临时的右值。弹出<code class="du kp kq kr ks b">BuildBigObject</code>的栈框就会消失。编译器可以检测到<code class="du kp kq kr ks b">foo</code>是一个临时的，它不会丢弃它，而是在<code class="du kp kq kr ks b">BuildBigObject</code>的调用中让<code class="du kp kq kr ks b">bar</code>和<code class="du kp kq kr ks b">foo</code>引用同一个内存位置。这意味着当<code class="du kp kq kr ks b">BuildBigOjbect</code>初始化<code class="du kp kq kr ks b">foo</code>时，它实际上是在外部作用域<code class="du kp kq kr ks b">bar</code>上工作。这种魔力被称为命名返回值优化(NRVO ),它是复制省略的一个具体应用。更多关于复制埃利斯，RVO，和NRVO <a class="ae jd" href="https://en.cppreference.com/w/cpp/language/copy_elision" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><p id="2f2d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">分解实际发生的事情，程序首先为<code class="du kp kq kr ks b">bar</code>分配内存，并将<code class="du kp kq kr ks b">bar</code>的指针传递给<code class="du kp kq kr ks b">BuildBigObject</code>，后者使用内存而不是<code class="du kp kq kr ks b">foo</code>。现在，每当<code class="du kp kq kr ks b">BuildBigObject</code>引用<code class="du kp kq kr ks b">foo</code>时，实际上都是在解引用<code class="du kp kq kr ks b">bar</code>。这在逻辑上等同于移动，但是编译器在幕后执行的复杂细节使它不完全相同。</p><p id="c516" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于复制省略的发生，<code class="du kp kq kr ks b">BuildBigObject</code>必须遵循一些规则，这超出了本文的范围。一个简单的没有任何分支的构建函数，就像上面显示的那样，应该可以满足复制省略的需要。</p></div></div>    
</body>
</html>