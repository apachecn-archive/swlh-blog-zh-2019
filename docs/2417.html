<html>
<head>
<title>A short intro to GraphQL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">GraphQL简介</h1>
<blockquote>原文：<a href="https://medium.com/swlh/short-intro-to-graphql-d00036bc8121?source=collection_archive---------9-----------------------#2019-04-19">https://medium.com/swlh/short-intro-to-graphql-d00036bc8121?source=collection_archive---------9-----------------------#2019-04-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/c58ccb6396c00b300cd544e956fd6b84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-MdM3Mplhlnz7hFyBt4vXQ.png"/></div></div></figure><p id="4762" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">GraphQL是一种获取数据的方法，旨在通过使用REST APIs解决现代应用程序开发中的问题。从前端的角度来看，这就像发送一个对您想要接收的数据的查询，而不是要求预定义的实体。</p></div><div class="ab cl jo jp gp jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="hb hc hd he hf"><h2 id="84d5" class="jv jw hi bd jx jy jz ka kb kc kd ke kf jb kg kh ki jf kj kk kl jj km kn ko kp bi translated">GraphQL到底想解决什么？</h2><p id="e0d1" class="pw-post-body-paragraph iq ir hi is b it kq iv iw ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn hb bi translated">GraphQL的目的是能够查询您需要的数据。作为一个例子，让我们看看当代的应用程序设置，前端通常与后端分离，这可能导致密集的请求周期。多个前端也可能调用同一个后端。</p><p id="3cea" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了获取数据，通常在REST之后获取数据，请求到达一个端点，并接收一个包含后端预先定义的数据的响应。这种数据的结构通常松散地基于前端的视图。视图需要一些相同的数据，然后它们可能还需要一些特定的数据。如果我们将一个端点与一个视图紧密地绑定在一起，我们就不能以有效的方式将该端点重用于其他目的。这通常以前端提取数据不足或过量而告终。我们可能会发出一个请求，并使用视图中的一些数据，然后我们发送另一个请求来获取剩余的数据，我们最终得到的数据比我们需要的多。这就是GraphQL试图解决的问题。</p><h2 id="77f0" class="jv jw hi bd jx jy jz ka kb kc kd ke kf jb kg kh ki jf kj kk kl jj km kn ko kp bi translated">GraphQL查询</h2><p id="bd8a" class="pw-post-body-paragraph iq ir hi is b it kq iv iw ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn hb bi translated">当用GraphQL获取数据时，我们定义我们需要的结构，它看起来像JSON，但它只包含键，不包含值。</p><p id="4d6a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下面是一个使用<a class="ae kv" href="https://www.gatsbyjs.org/" rel="noopener ugc nofollow" target="_blank"> Gatsby </a> (Gatsby是一个your React应用程序的框架)和WordPress的站点的例子，这是查询中使用的结构。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="a2bd" class="jv jw hi lb b fi lf lg l lh li">{<br/>  allWordpressWpTestimonial(sort: {fields: [date]}) {<br/>    edges {<br/>      node {<br/>        id<br/>        title<br/>        excerpt<br/>        slug<br/>        date(formatString: "YYYY/MM/DD")<br/>        type<br/>      }<br/>    }<br/>  }<br/>}</span></pre><p id="ce55" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">以下是回应。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="dfd3" class="jv jw hi lb b fi lf lg l lh li">{<br/>  "data": {<br/>    "allWordpressWpTestimonial": {<br/>      "edges": [<br/>        {<br/>          "node": {<br/>            "id": "824f9166-4768-5dc2-a2be-52217865854c",<br/>            "title": "Title to Testimonial #1",<br/>            "excerpt": "&lt;p&gt;Excerpt of Testimonial #1&lt;/p&gt;\n",<br/>            "slug": "testimonial-1",<br/>            "date": "2019/04/19",<br/>            "type": "testimonial"<br/>          }<br/>        },<br/>        {<br/>          "node": {<br/>            "id": "c032fd34-6af4-5bcd-b185-e64057647cc2",<br/>            "title": "Title to Testimonial #2",<br/>            "excerpt": "&lt;p&gt;Excerpt of Testimonial #2&lt;/p&gt;\n",<br/>            "slug": "testimonial-2",<br/>            "date": "2019/04/19",<br/>            "type": "testimonial"<br/>          }<br/>        }<br/>      ]<br/>    }<br/>  }<br/>}</span></pre><p id="c687" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">而不是用REST向WordPress REST API发送一个请求，后者会用比需要更多的数据来响应。GraphQL查询准确地接收到了所请求的数据。</p><p id="d0c0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">与REST API相比，选择需要哪些数据是一件好事。在基于REST的API中，我通常用Postman发送一些请求，并查看响应来找出我需要什么。使用GraphQL还有其他工具，我在使用Gatsby时使用的一个工具是Graph <em class="lj"> i </em> QL，它可以让你测试一个查询，看看你得到什么。图<em class="lj"> i </em> QL也有很好的智能感知能力来帮助你找到可用的钥匙。</p><figure class="kw kx ky kz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/c58ccb6396c00b300cd544e956fd6b84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-MdM3Mplhlnz7hFyBt4vXQ.png"/></div></div></figure><p id="c094" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当执行查询时，您会得到响应。</p><figure class="kw kx ky kz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lk"><img src="../Images/4b91e386f36835e9772dac076e49f560.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SLfNCMHubQtnQ0t6hOyBZg.png"/></div></div></figure><p id="7197" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我所做的就是暂时在图<em class="lj">I</em>QL中玩一会儿，直到我决定我需要什么。然后，我只需复制我创建的查询，并将其粘贴到Gatsby中包含的graphql方法中。</p><p id="90b5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用GraphQL，您只需点击一个端点，该端点根据您的查询提供数据。要进行更有选择性的查询，可以使用过滤器，就像这样。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="f29b" class="jv jw hi lb b fi lf lg l lh li">{<br/>  allWordpressWpTestimonial<strong class="lb ll">(filter: {slug:{eq: "testimonial-2"}})</strong> {<br/>    edges {<br/>      node {<br/>        id<br/>        title<br/>        excerpt<br/>        slug<br/>        date(formatString: "YYYY/MM/DD")<br/>      }<br/>    }<br/>  }<br/>}</span></pre><p id="2699" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">该查询返回的推荐文章类型具有等于“推荐-2”的slug。slug嵌套在node属性中，假设我们必须查询嵌套更深一层的内容，我们可以重写过滤器，如下所示。</p><p id="76a1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="lj">附带说明:ACF是高级定制字段的缩写，它是WordPress的一个插件，可以进一步增强你的数据</em>。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="e7c1" class="jv jw hi lb b fi lf lg l lh li">{<br/>  allWordpressWpTestimonial<strong class="lb ll">(filter: {acf:{grade: {eq: "2"}}})</strong> {<br/>    edges {<br/>      node {<br/>        id<br/>        title<br/>        excerpt<br/>        slug<br/>        date(formatString: "YYYY/MM/DD")        <br/>        acf {<br/>          grade<br/>        }<br/>      }<br/>    }<br/>  }<br/>}</span></pre><p id="428e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你想查询一个以上的文章类型，可以连接另一个查询，只要把它放在外面的括号里。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="2159" class="jv jw hi lb b fi lf lg l lh li">{<br/>  allWordpressWpTestimonial {<br/>    edges {<br/>      node {<br/>        id<br/>      }<br/>    }<br/>  }<br/>  allWordpressWpPortfolio {<br/>    edges {<br/>      node {<br/>        id<br/>      }<br/>    }<br/>  }<br/>}</span></pre><p id="301a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个查询类似于向两个不同的端点发出两个HTTP请求。</p><p id="63bf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果我们想选择两个特定的证明，我们可以编写如下查询。为了避免名称冲突，我们需要使用一种叫做<strong class="is ll">别名的东西，</strong>注意，推荐被重命名为<code class="du lm ln lo lb b">firstTestimonial</code>和<code class="du lm ln lo lb b">secondTestimonial</code>，否则，我们将会遇到名称冲突。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="0cdc" class="jv jw hi lb b fi lf lg l lh li">{<br/>  <strong class="lb ll">firstTestimonial</strong>: allWordpressWpTestimonial(filter: {slug: {eq: "testimonial-1"}}) {<br/>    edges {<br/>      node {<br/>        id<br/>        slug<br/>      }<br/>    }<br/>  }<br/>  <strong class="lb ll">secondTestimonial</strong>: allWordpressWpTestimonial(filter: {slug: {eq: "testimonial-2"}}) {<br/>    edges {<br/>      node {<br/>        id<br/>        slug<br/>      }<br/>    }<br/>  }<br/>}</span></pre><p id="cafa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是这一次我们重复我们自己，我们为每一个证明选择钥匙。为了解决这个问题，我们可以使用一个叫做<strong class="is ll">的片段</strong>，看起来像这样。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="6285" class="jv jw hi lb b fi lf lg l lh li">{<br/>  firstTestimonial: allWordpressWpTestimonial(filter: {slug: {eq: "testimonial-1"}}) {<br/>    edges {<br/>      node {<br/>       <strong class="lb ll">...testimonialDetails</strong><br/>      }<br/>    }<br/>  }<br/>  secondTestimonial: allWordpressWpTestimonial(filter: {slug: {eq: "testimonial-2"}}) {<br/>    edges {<br/>      node {<br/>        <strong class="lb ll">...testimonialDetails</strong><br/>      }<br/>    }<br/>  }<br/>}</span><span id="602f" class="jv jw hi lb b fi lp lg l lh li"><strong class="lb ll">fragment</strong> testimonialDetails on wordpress__wp_testimonial {<br/>  id<br/>  slug<br/>}</span></pre><p id="d933" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du lm ln lo lb b">wordpress__wp_testimonial</code>指奖状帖式。使用片段时，它看起来类似于ECMAScript中的spread操作符。</p><h2 id="ff02" class="jv jw hi bd jx jy jz ka kb kc kd ke kf jb kg kh ki jf kj kk kl jj km kn ko kp bi translated">概括起来</h2><p id="02a8" class="pw-post-body-paragraph iq ir hi is b it kq iv iw ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn hb bi translated">GraphQL是一种查询所需数据的方法。它解决了欠取和过取数据的问题。</p><p id="1666" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有一些非常方便的工具来处理查询，我使用了Graph <em class="lj"> i </em> QL，它帮助我找到了我可以使用的键。这个数据结构看起来像一个“只有键的JSON”。在REST中，使用GraphQL请求资源，基于查询请求数据。</p><p id="52e5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了避免名称冲突，我们可以使用别名来重命名项目。为了避免重复的键，我们可以使用片段。片段是一个模板，其中包含我们希望在查询中使用的键。</p><p id="a7da" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一个误解是，GraphQL只适用于React和JavaScript，但也有其他语言的实现，前端不必用React构建。</p></div></div>    
</body>
</html>