<html>
<head>
<title>Javascript Baker’s Dozen</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Javascript贝克的一打</h1>
<blockquote>原文：<a href="https://medium.com/swlh/javascript-bakers-dozen-ce2fc192f9b5#2019-06-12">https://medium.com/swlh/javascript-bakers-dozen-ce2fc192f9b5#2019-06-12</a></blockquote><div><div class="dt gx gy gz ha hb"/><div class="hc hd he hf hg"><div class=""/><figure class="ew ey ih ii ij ik es et paragraph-image"><div role="button" tabindex="0" class="il im di in bf io"><div class="es et ig"><img src="../Images/f1f007ee063c1e37d993cc7325b09709.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CeO6obxDoXPLG3YPdTPffQ.jpeg"/></div></div><figcaption class="ir is eu es et it iu bd b be z dy">Photo by <a class="ae iv" href="https://unsplash.com/@florenciaviadana?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Florencia Viadana</a> on <a class="ae iv" href="https://unsplash.com/search/photos/bread?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="3e55" class="pw-post-body-paragraph iw ix hj iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hc bi translated">在编写Javascript代码的几十年中，随着它从一种前端脚本语言发展成为一个真正的发电站，我学到了一些很棒的一行程序。不，不是那些一行程序，而是一段非常简洁的代码，你会惊讶于它们的强大。但是随着强大的能力而来的是巨大的责任——谨慎地使用它，以避免将代码混淆成不可读的意大利面条。</p><p id="9c0a" class="pw-post-body-paragraph iw ix hj iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hc bi translated">以下是我最喜欢的13个Javascript一行程序，排名不分先后。</p><p id="037b" class="pw-post-body-paragraph iw ix hj iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hc bi translated"><em class="ju">*所有使用Node.js v11.x的示例，您的用法可能因客户端浏览器而异。</em></p><h2 id="3ff7" class="jv jw hj bd jx jy jz ka kb kc kd ke kf jh kg kh ki jl kj kk kl jp km kn ko kp bi translated">1.转换为布尔值</h2><p id="170e" class="pw-post-body-paragraph iw ix hj iy b iz kq jb jc jd kr jf jg jh ks jj jk jl kt jn jo jp ku jr js jt hc bi translated">要将变量转换成一个<em class="ju">布尔</em>值而不改变原始值:</p><pre class="kv kw kx ky fe kz la lb lc aw ld bi"><span id="b2f9" class="jv jw hj la b fj le lf l lg lh">const myBoolean = !!myVariable;</span></pre><p id="79d9" class="pw-post-body-paragraph iw ix hj iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hc bi translated">双NOTs(！！)来保持布尔值的意图并防止它翻转真值。<strong class="iy li"> <em class="ju"> myVariable </em> </strong>不会改变，但是转换会作为一个布尔型赋值给<strong class="iy li"> <em class="ju"> myBoolean </em> </strong>。</p><h2 id="1ab1" class="jv jw hj bd jx jy jz ka kb kc kd ke kf jh kg kh ki jl kj kk kl jp km kn ko kp bi translated">2.重复数据删除</h2><p id="816b" class="pw-post-body-paragraph iw ix hj iy b iz kq jb jc jd kr jf jg jh ks jj jk jl kt jn jo jp ku jr js jt hc bi translated">要从数组中删除重复项，请执行以下操作:</p><pre class="kv kw kx ky fe kz la lb lc aw ld bi"><span id="3d37" class="jv jw hj la b fj le lf l lg lh">const deDupe = [...new Set(myArray)];</span></pre><p id="d0fc" class="pw-post-body-paragraph iw ix hj iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hc bi translated">要求集合中的每个值都是唯一的，将其与spread运算符结合将从<strong class="iy li"> <em class="ju"> myArray </em> </strong>中产生一个重复数据删除数组。</p><h2 id="1a22" class="jv jw hj bd jx jy jz ka kb kc kd ke kf jh kg kh ki jl kj kk kl jp km kn ko kp bi translated">3.条件属性</h2><p id="e054" class="pw-post-body-paragraph iw ix hj iy b iz kq jb jc jd kr jf jg jh ks jj jk jl kt jn jo jp ku jr js jt hc bi translated">要在对象上有条件地设置属性，请在对象上使用spread运算符:</p><pre class="kv kw kx ky fe kz la lb lc aw ld bi"><span id="009e" class="jv jw hj la b fj le lf l lg lh">const myObject = { ...myProperty &amp;&amp; { propName: myValue } };</span></pre><p id="95dc" class="pw-post-body-paragraph iw ix hj iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hc bi translated">如果分摊结果为空，则<strong class="iy li"> <em class="ju"> &amp; &amp; </em> </strong>失败，不设置新属性；否则，如果<strong class="iy li"> <em class="ju"> &amp; &amp; </em> </strong>不为空，将覆盖并设置该属性。</p><p id="8795" class="pw-post-body-paragraph iw ix hj iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hc bi translated">使用布尔表达式有条件地设置对象属性的另一种方法是:</p><pre class="kv kw kx ky fe kz la lb lc aw ld bi"><span id="1d8a" class="jv jw hj la b fj le lf l lg lh">const myObj = { propOne: "a", ...(booleanExpr &amp;&amp; { propTwo: "b" })}</span></pre><h2 id="db88" class="jv jw hj bd jx jy jz ka kb kc kd ke kf jh kg kh ki jl kj kk kl jp km kn ko kp bi translated">4.合并对象</h2><p id="9aa2" class="pw-post-body-paragraph iw ix hj iy b iz kq jb jc jd kr jf jg jh ks jj jk jl kt jn jo jp ku jr js jt hc bi translated">要合并对象:</p><pre class="kv kw kx ky fe kz la lb lc aw ld bi"><span id="2351" class="jv jw hj la b fj le lf l lg lh">const mergedObject = { ...objectOne, ...objectTwo };</span></pre><p id="c068" class="pw-post-body-paragraph iw ix hj iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hc bi translated">支持无限制的合并，但是如果对象之间有共享属性，具有重复属性名称的最右边的对象将覆盖另一个对象的属性。<em class="ju">*注意这仅用于浅层合并。</em></p><h2 id="3fc3" class="jv jw hj bd jx jy jz ka kb kc kd ke kf jh kg kh ki jl kj kk kl jp km kn ko kp bi translated">5.交换变量</h2><p id="f336" class="pw-post-body-paragraph iw ix hj iy b iz kq jb jc jd kr jf jg jh ks jj jk jl kt jn jo jp ku jr js jt hc bi translated">要在不使用中介的情况下交换两个变量的值:</p><pre class="kv kw kx ky fe kz la lb lc aw ld bi"><span id="c745" class="jv jw hj la b fj le lf l lg lh">[varA, varB] = [varB, varA];</span></pre><p id="ca79" class="pw-post-body-paragraph iw ix hj iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hc bi translated"><strong class="iy li"> <em class="ju"> varA </em> </strong>的值现在是<strong class="iy li"> <em class="ju"> varB </em> </strong>的值，反之亦然。析构允许这在内部机制中发生。</p><h2 id="cc11" class="jv jw hj bd jx jy jz ka kb kc kd ke kf jh kg kh ki jl kj kk kl jp km kn ko kp bi translated">6.移除虚假值</h2><p id="40ed" class="pw-post-body-paragraph iw ix hj iy b iz kq jb jc jd kr jf jg jh ks jj jk jl kt jn jo jp ku jr js jt hc bi translated">要从数组中删除所有falsy值，请执行以下操作:</p><pre class="kv kw kx ky fe kz la lb lc aw ld bi"><span id="9168" class="jv jw hj la b fj le lf l lg lh">const clean = dirty.filter(Boolean);</span></pre><p id="eb16" class="pw-post-body-paragraph iw ix hj iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hc bi translated">这将删除等同于布尔假的任何内容，包括:<em class="ju">空、未定义、假、零(0)和空字符串</em>。</p><h2 id="a44e" class="jv jw hj bd jx jy jz ka kb kc kd ke kf jh kg kh ki jl kj kk kl jp km kn ko kp bi translated">7.转换元素类型</h2><p id="490f" class="pw-post-body-paragraph iw ix hj iy b iz kq jb jc jd kr jf jg jh ks jj jk jl kt jn jo jp ku jr js jt hc bi translated">要将<em class="ju">数字</em>元素转换为<em class="ju">字符串</em>元素:</p><pre class="kv kw kx ky fe kz la lb lc aw ld bi"><span id="fdf4" class="jv jw hj la b fj le lf l lg lh">const stringArray = numberArray.map(String);</span></pre><p id="ff8d" class="pw-post-body-paragraph iw ix hj iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hc bi translated">如果数组包含一个字符串，它将保持为一个字符串。<br/>这也可用于将<em class="ju">字符串</em>元素转换为<em class="ju">数字</em>类型:</p><pre class="kv kw kx ky fe kz la lb lc aw ld bi"><span id="9802" class="jv jw hj la b fj le lf l lg lh">const numberArray = stringArray.map(Number);</span></pre><h2 id="7b55" class="jv jw hj bd jx jy jz ka kb kc kd ke kf jh kg kh ki jl kj kk kl jp km kn ko kp bi translated">8.析构属性别名</h2><p id="896a" class="pw-post-body-paragraph iw ix hj iy b iz kq jb jc jd kr jf jg jh ks jj jk jl kt jn jo jp ku jr js jt hc bi translated">将属性值从一个对象重新指定给另一个对象:</p><pre class="kv kw kx ky fe kz la lb lc aw ld bi"><span id="0ddf" class="jv jw hj la b fj le lf l lg lh">const { original: newName } = myObject;</span></pre><p id="8389" class="pw-post-body-paragraph iw ix hj iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hc bi translated">这将初始化一个名为<strong class="iy li"> <em class="ju">新名称</em> </strong>的新变量，并将其赋以来自<strong class="iy li"><em class="ju">my object . original .</em></strong>的值</p><h2 id="b87c" class="jv jw hj bd jx jy jz ka kb kc kd ke kf jh kg kh ki jl kj kk kl jp km kn ko kp bi translated">9.格式化JSON代码</h2><p id="e7c6" class="pw-post-body-paragraph iw ix hj iy b iz kq jb jc jd kr jf jg jh ks jj jk jl kt jn jo jp ku jr js jt hc bi translated">以人类可读的格式显示JSON代码:</p><pre class="kv kw kx ky fe kz la lb lc aw ld bi"><span id="e3d6" class="jv jw hj la b fj le lf l lg lh">const formatted = JSON.stringify(myObj, null, 2);</span></pre><p id="46e4" class="pw-post-body-paragraph iw ix hj iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hc bi translated"><em class="ju"> stringify </em>命令有三个参数。第一个是Javascript对象。第二个是可选函数，可以在JSON被字符串化时对其进行操作。最后一个参数指示要添加多少空格作为缩进来格式化JSON。省略最后一个参数，JSON将作为一个长行返回。如果<strong class="iy li"> <em class="ju"> myObj </em> </strong>中有循环引用，此操作将失败。</p><h2 id="cbdd" class="jv jw hj bd jx jy jz ka kb kc kd ke kf jh kg kh ki jl kj kk kl jp km kn ko kp bi translated">10.快速数字阵列</h2><p id="87af" class="pw-post-body-paragraph iw ix hj iy b iz kq jb jc jd kr jf jg jh ks jj jk jl kt jn jo jp ku jr js jt hc bi translated">要创建一个数组并用数字填充，索引为零:</p><pre class="kv kw kx ky fe kz la lb lc aw ld bi"><span id="459f" class="jv jw hj la b fj le lf l lg lh">const numArray = Array.from(new Array(52), (x, i) =&gt; i);</span></pre><p id="c4c9" class="pw-post-body-paragraph iw ix hj iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hc bi translated">数组大小可以是文字或变量。这是一个为一副牌创建52个元素的例子。</p><h2 id="351d" class="jv jw hj bd jx jy jz ka kb kc kd ke kf jh kg kh ki jl kj kk kl jp km kn ko kp bi translated">11.生成2FA代码</h2><p id="d7e5" class="pw-post-body-paragraph iw ix hj iy b iz kq jb jc jd kr jf jg jh ks jj jk jl kt jn jo jp ku jr js jt hc bi translated">要生成2FA的六位数代码或其他验证码:</p><pre class="kv kw kx ky fe kz la lb lc aw ld bi"><span id="c1dc" class="jv jw hj la b fj le lf l lg lh">const code = Math.floor(Math.random() * 1000000).toString().padStart(6, "0");</span></pre><p id="0050" class="pw-post-body-paragraph iw ix hj iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hc bi translated">用<strong class="iy li"><em class="ju">pad start</em></strong><em class="ju">target length</em>参数匹配随机范围内的零的数量。</p><h2 id="66ef" class="jv jw hj bd jx jy jz ka kb kc kd ke kf jh kg kh ki jl kj kk kl jp km kn ko kp bi translated">12.洗牌阵列</h2><p id="38c5" class="pw-post-body-paragraph iw ix hj iy b iz kq jb jc jd kr jf jg jh ks jj jk jl kt jn jo jp ku jr js jt hc bi translated">在不知道值的上下文的情况下打乱数组:</p><pre class="kv kw kx ky fe kz la lb lc aw ld bi"><span id="e00b" class="jv jw hj la b fj le lf l lg lh">myArray.sort(() =&gt; { return Math.random() - 0.5});</span></pre><p id="b8a0" class="pw-post-body-paragraph iw ix hj iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hc bi translated">一个更好的排序算法是我在我的<a class="ae iv" rel="noopener" href="/swlh/the-javascript-shuffle-62660df19a5d"> Javascript Shuffle </a>文章中提到的Fisher-Yates shuffle。</p><h2 id="4575" class="jv jw hj bd jx jy jz ka kb kc kd ke kf jh kg kh ki jl kj kk kl jp km kn ko kp bi translated">13.深层克隆</h2><p id="6f0f" class="pw-post-body-paragraph iw ix hj iy b iz kq jb jc jd kr jf jg jh ks jj jk jl kt jn jo jp ku jr js jt hc bi translated">这种方法的性能不是很好，但是如果您需要一个快速的一行程序，那么这种克隆方法可以用来深度复制一个对象:</p><pre class="kv kw kx ky fe kz la lb lc aw ld bi"><span id="cd86" class="jv jw hj la b fj le lf l lg lh">const myClone = JSON.parse(JSON.stringify(originalObject));</span></pre><p id="7ff2" class="pw-post-body-paragraph iw ix hj iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hc bi translated">如果<strong class="iy li"><em class="ju">original object</em></strong>有循环引用，那么这个会失败。在您自己创建的简单对象上使用这种技术。</p><p id="dbac" class="pw-post-body-paragraph iw ix hj iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hc bi translated">使用扩展运算符可以创建浅层克隆:</p><pre class="kv kw kx ky fe kz la lb lc aw ld bi"><span id="33cb" class="jv jw hj la b fj le lf l lg lh">const myClone = { ...orignalObject };</span></pre><h2 id="2073" class="jv jw hj bd jx jy jz ka kb kc kd ke kf jh kg kh ki jl kj kk kl jp km kn ko kp bi translated">组合和扩展</h2><p id="5c21" class="pw-post-body-paragraph iw ix hj iy b iz kq jb jc jd kr jf jg jh ks jj jk jl kt jn jo jp ku jr js jt hc bi translated">有许多方法可以将这些一行程序结合起来，用很少的代码完成神奇的壮举。Javascript将继续发展，拥有额外的超级能力，允许开发人员减少他们代码库的大小。使用这些一行程序来扩展您的技能并更快地编写代码。</p></div></div>    
</body>
</html>