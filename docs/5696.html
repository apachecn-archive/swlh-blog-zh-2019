<html>
<head>
<title>Javascript: The Hidden Parts (Implicit and Automatic)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Javascript:隐藏部分(隐式和自动)</h1>
<blockquote>原文：<a href="https://medium.com/swlh/javascript-the-hidden-parts-implicit-and-automatic-6dcd505f153d#2019-06-13">https://medium.com/swlh/javascript-the-hidden-parts-implicit-and-automatic-6dcd505f153d#2019-06-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/7c505cedf433220f16c03cdfd6ab9e60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7huWMEIuXtZJq57H"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Photo by <a class="ae iu" href="https://unsplash.com/@isisfra?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Isis França</a> on <a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="d8a6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">有相当多的Javascript代码你不需要输入。从分号到隐式参数。本文将展示一些例子，这些例子要么是被设计遗漏的，要么是为了帮助编码者而被纠正的。</p><h2 id="1a18" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">自动分号插入</h2><p id="7822" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">不仅仅是你！其他Javascript开发人员也很懒。尽管；不是每个人都想在每一行结束时都输入。所以ECMA国际在制作ES5的过程中决定消除这种压力。这些规则后来在ES2015 (ES6)中得到扩展，如果需要，可以在这里阅读<a class="ae iu" href="https://www.ecma-international.org/ecma-262/6.0/index.html#sec-automatic-semicolon-insertion" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="776c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于那些不想阅读他们所分解的规则的人来说:</p><ol class=""><li id="6eb6" class="kt ku hi ix b iy iz jc jd jg kv jk kw jo kx js ky kz la lb bi translated">它将被插入到一个有效代码段的行结束符之前(就在您点击return换一个新行之前)</li><li id="999b" class="kt ku hi ix b iy lc jc ld jg le jk lf jo lg js ky kz la lb bi translated">如果需要，它将在}之前插入</li><li id="9f63" class="kt ku hi ix b iy lc jc ld jg le jk lf jo lg js ky kz la lb bi translated">下一行的开头不是(或许多其他免除之一</li></ol><p id="4007" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">规则一免除了一些事情，比如当你在回车之后有一个{ right，即使在它自己的行上。然而，如果没有像(或{。这样做的实际效果是，您最终可能会键入:</p><p id="cd54" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du lh li lj lk b">return<br/> a+b</code></p><p id="8f98" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">并添加分号作为</p><pre class="ll lm ln lo fd lp lk lq lr aw ls bi"><span id="4d10" class="jt ju hi lk b fi lt lu l lv lw">return;<br/>a+b; </span></pre><p id="ec60" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">还有更复杂的例外情况，例如，当有else时，if/else语句不会在if的{}后面插入分号，因为这会违反if/else的工作方式。ECMAscript中有有效语法这种东西，自动分号不会违反它。</p><p id="2683" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae iu" href="http://www.bradoncode.com/blog/2015/08/26/javascript-semi-colon-insertion/" rel="noopener ugc nofollow" target="_blank">布拉德利·布莱斯维特</a>就此写了一篇很棒的文章，其中包括整个事情的奇妙图表。我强烈推荐通读并关注他关于依赖自动逗号插入的警告。</p><h2 id="44bf" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">隐性强制</h2><p id="57bd" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">您可能知道，JS中没有显式类型。如果你愿意，你的变量可以是一个字符串，下一个是一个数字。我建议不要选择这样做，因为这会让大多数参与者感到困惑。</p><p id="f1de" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">那么什么是隐性强制呢？大致是这样的:</p><pre class="ll lm ln lo fd lp lk lq lr aw ls bi"><span id="7207" class="jt ju hi lk b fi lt lu l lv lw">"2" + 1 = "21"<br/>"2" - 1 = 1<br/>1 + 1 + "2" = "12"<br/>true + true = 2<br/>3 + [1] = "31"<br/>3 * [ 1 ] = 3<br/>3 * [ 1, 2] = NaN</span></pre><p id="8516" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您可能以前在一些关于Javascript怪癖的恶魔中，或者在您自己的工作中见过类似的东西。这是有原因的，那就是Javascript真的很想工作。它希望通过忽略当您试图对两个不同的类型(如string和number)进行操作时出现的问题来帮助您。</p><p id="f553" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在Javascript中,+操作符被称为<a class="ae iu" href="https://en.wikipedia.org/wiki/Operator_overloading" rel="noopener ugc nofollow" target="_blank">重载</a>,这意味着它根据周围的情况做不同的事情。这种特殊的重载并不是Javascript独有的，我试图找出它的来源却一无所获。如果有人知道，评论或给我发消息，我会更新信用。因此，这种混乱的本质部分在于，如果你使用+的话，它在默认情况下不会被认为是一个数学运算符，而像-、*和/则是。</p><p id="6eae" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">不过回到手头的话题。为了向您展示这里发生了什么，让我用Javascript实际上在做什么来重写上面的内容:</p><pre class="ll lm ln lo fd lp lk lq lr aw ls bi"><span id="1171" class="jt ju hi lk b fi lt lu l lv lw">"2" + String(1) = "21"<br/>Number("2") - 1 = 1<br/>String(1 + 1) + "2" = "22"<br/>String(3) +[ 1 ].join() = "31" <br/>3 * Number([ 1 ].join()) = 3<br/>3 * Number([ 1, 2 ].join()) = NaN //this comes from Number("1,2") which equals NaN</span></pre><p id="007d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里还有另一个潜在的逻辑。Truthy/Falsy是Javascript值被强制转换为布尔值时的描述。Javascript中的一切都是真实的，除此之外:</p><ul class=""><li id="a4a7" class="kt ku hi ix b iy iz jc jd jg kv jk kw jo kx js lx kz la lb bi translated">错误的</li><li id="b38f" class="kt ku hi ix b iy lc jc ld jg le jk lf jo lg js lx kz la lb bi">0</li><li id="3852" class="kt ku hi ix b iy lc jc ld jg le jk lf jo lg js lx kz la lb bi translated">空</li><li id="8848" class="kt ku hi ix b iy lc jc ld jg le jk lf jo lg js lx kz la lb bi">“”</li><li id="05f4" class="kt ku hi ix b iy lc jc ld jg le jk lf jo lg js lx kz la lb bi translated">不明确的</li><li id="b37f" class="kt ku hi ix b iy lc jc ld jg le jk lf jo lg js lx kz la lb bi translated">圆盘烤饼</li><li id="3203" class="kt ku hi ix b iy lc jc ld jg le jk lf jo lg js lx kz la lb bi">-0</li></ul><p id="2be7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你可能已经用过了。例如，如果你检查某个未定义的东西，你可以写:</p><pre class="ll lm ln lo fd lp lk lq lr aw ls bi"><span id="358a" class="jt ju hi lk b fi lt lu l lv lw">if(testVal){<br/>  throw error<br/>}</span></pre><p id="e276" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是通过转换值<code class="du lh li lj lk b">boolean(testVal)</code>将值与<code class="du lh li lj lk b">true</code>进行==比较，因为等式是一个布尔运算符。早些时候我举了一个例子<code class="du lh li lj lk b">true + true = 2</code>，它就像写作<code class="du lh li lj lk b">Number(true) + Number (true) = 2</code>。加号将它们转换成数字，以便进行加法运算。要了解更多这种疯狂，请看这张<a class="ae iu" href="https://dorey.github.io/JavaScript-Equality-Table/" rel="noopener ugc nofollow" target="_blank">图</a>，它展示了如何将所有值与a ==进行比较。</p><h2 id="a8b7" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">隐性回报</h2><p id="30b9" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">在ES2015(ES6)中引入了箭头功能的概念。除了看起来非常酷(主观)和减少你需要绑定<code class="du lh li lj lk b">this</code>的次数，特别是在React中，他们还引入了隐性回报的概念。</p><p id="a3f6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">它们是这样写的:</p><pre class="ll lm ln lo fd lp lk lq lr aw ls bi"><span id="7ded" class="jt ju hi lk b fi lt lu l lv lw">const testFunc = () =&gt; 'It worked!';</span></pre><p id="0037" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">= &gt;也是不会应用隐式分号的情况之一。一旦添加了该字符串，它就会。有几种方法可以打破这一点:</p><pre class="ll lm ln lo fd lp lk lq lr aw ls bi"><span id="acd2" class="jt ju hi lk b fi lt lu l lv lw">const testFunc2 = () =&gt; {'It worked!'};</span><span id="2033" class="jt ju hi lk b fi ly lu l lv lw">const testFunc3 = () =&gt; {return 'It worked!'};</span></pre><p id="def2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里添加的括号({})改变了函数的处理方式。一旦它们被添加，返回必须被添加，否则返回将是未定义的。不过，这里还有其他问题:</p><pre class="ll lm ln lo fd lp lk lq lr aw ls bi"><span id="78cb" class="jt ju hi lk b fi lt lu l lv lw">const testFunc4 = () =&gt; {workingVal:'It worked!'};</span><span id="0fc5" class="jt ju hi lk b fi ly lu l lv lw">const testFunc5 = () =&gt; ({workingVal:'It worked!'});</span></pre><p id="f8e1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">猜猜这些函数在哪个位置实际上会返回一个对象，哪个函数在被调用时会返回未定义的对象。答案是testFunc5。括号被误认为是函数体的开口。圆括号防止了这种情况。</p><p id="3c4e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">要使隐式返回生效，箭头后的值必须是一个表达式。Javascript中的表达式在使用时会产生一个值。1 + 1是一个计算结果为2的表达式。语句有点不同，比如<code class="du lh li lj lk b">if/else</code>是一个语句。没有回报的运行之后就没有价值了。使用if永远不会允许隐式返回工作。但是三元表达式确实有效，因为它们的结果是一个表达式。</p><p id="b3fd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">箭头函数还有一个小的遗漏。如果只有一个参数，可以省略括号。拥有0或2+意味着它们是必需的。例外情况是，如果您为参数设置了默认值。</p><h2 id="1a96" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">隐函数参数</h2><p id="c8b6" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">当你创建一个函数时，即使没有定义参数，仍然有一些参数可以在函数中调用。最明显的一个是<code class="du lh li lj lk b">this</code>,它根据被调用的方式而变化。在一个被调用来返回<code class="du lh li lj lk b">this</code>的标准函数中，它将返回全局范围，即浏览器中的<code class="du lh li lj lk b">window </code>和节点中的<code class="du lh li lj lk b">global</code>。Call、apply和bind都可以改变<code class="du lh li lj lk b">this</code>引用的范围，就像调用它作为对象上的方法一样。</p><p id="db00" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">箭头方法也改变了<code class="du lh li lj lk b">this</code>的处理方式。关于<code class="du lh li lj lk b">this</code>如何工作的完整范围有点超出了本文的范围，但是如果你想了解更多，我建议你或者去<a class="ae iu" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this" rel="noopener ugc nofollow" target="_blank"> MDN页面</a>或者其他人写的大量文章中的一篇。</p><p id="1718" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">虽然<code class="du lh li lj lk b">this</code>是相当普遍的知识，但<code class="du lh li lj lk b">arguments</code>就不那么普遍了。在任何函数中<code class="du lh li lj lk b">arguments</code>都是存在的，允许你调用数组中的参数。即使没有任何东西被声明为参数，这也是有效的。例如:</p><pre class="ll lm ln lo fd lp lk lq lr aw ls bi"><span id="b9e8" class="jt ju hi lk b fi lt lu l lv lw">function arguementTest () {<br/>  return arguments.length<br/>}</span><span id="6c1d" class="jt ju hi lk b fi ly lu l lv lw">arguementTest(0,1,2,3) // this will return 4</span></pre><p id="8272" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">假设这是一个数组，也可以通过数字调用参数。在上面的例子中，如果我调用了<code class="du lh li lj lk b">arguments[1]</code>,我会得到一个1作为第二个值。应该注意，它并不是真正的数组。它可以像一个一样被访问，并且有一个长度属性，但是<code class="du lh li lj lk b">forEach()</code>或<code class="du lh li lj lk b">pop()</code>不起作用。运行<code class="du lh li lj lk b">typeof</code>将显示<code class="du lh li lj lk b">arguments </code>是一个对象。也不可能在箭头功能中访问<code class="du lh li lj lk b">arguments</code>。</p><p id="9451" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">MDN指出，您实际上不应该在ES2015(ES6)+代码中使用它。相反，你应该更喜欢所谓的<code class="du lh li lj lk b">rest parameter</code>。这基本上是一个扩展运算符，作为最后一个参数添加，如下所示:</p><pre class="ll lm ln lo fd lp lk lq lr aw ls bi"><span id="1aa9" class="jt ju hi lk b fi lt lu l lv lw">function restOp ( one, two, ...rest){<br/>  return rest<br/>}</span><span id="eb25" class="jt ju hi lk b fi ly lu l lv lw">restOp (0,1,2,3,4) // this will return [2,3,4]</span></pre><p id="59e8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">它的优点是不必考虑命名参数，并且实际上是一个包含所有完整数组方法的数组。rest参数可以随意命名，但必须始终是最后指定的参数。</p><h2 id="c9b4" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">结尾部分</h2><p id="c469" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">希望这能启发你一些你可以从JS中忽略的东西，或者那些你从未意识到的东西。像往常一样，如果我错过了什么或做错了什么，给我发消息。如果我发现了新的东西或者发现我已经忘记了，我会试着更新这篇文章。</p></div></div>    
</body>
</html>