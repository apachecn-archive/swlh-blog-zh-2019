# 构成与继承

> 原文：<https://medium.com/swlh/composition-vs-inheritance-74eed3147f89>

![](img/7815d04cc15491929539366bd600fc2c.png)

## 这甚至不是一场公平的比赛

任何过去使用过面向对象语言的人可能都熟悉继承的概念，即让子类继承父类的方法和实例变量。通常，父类和子类之间的关系被定义为“是”关系。因为父类定义了其子类的超集。例如，水果的父类将有苹果的子类，因为苹果**是**水果。这是代码中这种关系的另一个例子。

C#

这里我们可以看到`BassetHound`类从`Dog`类继承了`Bark()`方法。通过允许多个子类继承它的方法，继承对于减少代码中的重复非常有用。然而，这就是继承的好处所在，因为组合可以做到这一点，甚至更多！

组合是定义可以跨多个不同类使用的功能块，而不需要父类的思想。例如拿一个`Airplane`类和一个`Helicopter`类来说，它们都需要有`Fly()`的方法。当考虑继承时，你可能会想到创建一个`Aircraft`的父类来保存`Fly()`方法。然而，如果你需要创建一个`Canary`类呢？现在你要做一个决定。你是否创建了另一个父类来定义鸟和飞机之间的关系？你只是在两个类上复制 fly 方法吗？就我个人而言，这两个听起来都不是好的选择，因为它们只会把我们的代码搞得一团糟。

这就是为什么构图效果如此之好。组合允许您在`Airplane`、`Helicopter`或`Canary`之外定义`Fly()`，并让它们都由和`Fly()`组合成*。组合定义了“有”的关系类型，就像飞机、直升机或金丝雀一样，它们都有飞行的能力。这里有一个类似的代码示例。*

C#

在这个例子中，我们从我们的任何类中单独创建了`Fly()`，然后将它注入到我们的`Airplane`和`Canary`的创建中。这不仅减少了重复，还减少了使用继承实现类似功能的复杂性。在这里使用 composition 还允许我们在需要测试时轻松地注入一个模拟的`Fly()`。

几乎在每一种情况下，使用组合都是更好的选择，因为它提供了继承的所有好处，提供了比继承更大的灵活性和更大的清晰度，同时也避免了使用继承的任何缺点。

所以我希望你能从这篇文章中学到一些东西，甚至可能学到一些东西。如果您有任何问题，请务必在下面留下您的评论。感谢阅读！