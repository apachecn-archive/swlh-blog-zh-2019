<html>
<head>
<title>Brute Force behind the Observer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">观察者背后的蛮力</h1>
<blockquote>原文：<a href="https://medium.com/swlh/brute-force-behind-the-observer-c150aedb9210#2019-06-07">https://medium.com/swlh/brute-force-behind-the-observer-c150aedb9210#2019-06-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/f3d0994794ef71135c203bc06273e7e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y58I4ZvvzWfjYElTUNgOUQ.jpeg"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">Photo by <a class="ae hv" href="https://unsplash.com/@darshan394?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Deva Darshan</a> on <a class="ae hv" href="https://unsplash.com/search/photos/cars-theme-park?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><div class=""/><div class=""><h2 id="435d" class="pw-subtitle-paragraph iv hx hy bd b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm dx translated">如何构建具有观察者模式的微型机器，能够解决最复杂的问题。</h2></div><p id="1374" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">搜索时轻视蛮力的力量是相当普遍的。它给人的印象是，解决问题的最好方法是通过一些合适的和谨慎的方法。然而，代码越复杂，交互性越差，效率就越受限制。另一方面，如果我们担心实现更动态的东西，那么公式对每种情况的适用性就会提高。</p><p id="a65a" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">因此，对于非常复杂的问题和不是非常大的条目，使用迭代器为我们提供最快的解决方案可能是明智的。</p><h1 id="7257" class="kj kk hy bd kl km kn ko kp kq kr ks kt je ku jf kv jh kw ji kx jk ky jl kz la bi translated">时间表上的蛮力</h1><p id="64a3" class="pw-post-body-paragraph jn jo hy jp b jq lb iz js jt lc jc jv jw ld jy jz ka le kc kd ke lf kg kh ki hb bi translated">假设我们想要实现一个简单的学校时间表。为此，我们必须将教师、课程、教室结合起来……但课程表至少能识别出一种对应关系，这种对应关系指定了哪节课、哪一天、哪一天的什么时间、教师、科目和课程。所以我们可以准备这个初始化:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="f288" class="lp kk hy ll b fi lq lr l ls lt">def test1(days, hours, clrooms, courses, teachs, subjs):<br/>    D = ['d' + str(X) for X in range(days)]<br/>    H = ['h' + str(X) for X in range(hours)]<br/>    R = ['r' + str(X) for X in range(clrooms)]<br/>    C = ['c' + str(X) for X in range(courses)]<br/>    T = ['t' + str(X) for X in range(teachs)]<br/>    S = ['s' + str(X) for X in range(subjs)]<br/>    return ((R, H, D), (S, T, C))</span></pre><p id="b424" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">如果我们想要迭代列表的组合(天、小时和教室；或者课程，老师，科目)，首先要把列表组合起来，这样才能很好的编码，所以我可以提出这个类:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="ddce" class="lp kk hy ll b fi lq lr l ls lt">class Combine:<br/>    def __init__(self, domains):<br/>        self.D = domains<br/>        self.len = self._calculateLen()</span><span id="59e7" class="lp kk hy ll b fi lu lr l ls lt">def _calculateLen(self):<br/>        R = 1<br/>        for X in self.D:<br/>            R*= len(X)<br/>        return R</span><span id="ce06" class="lp kk hy ll b fi lu lr l ls lt">def __getitem__(self, item):<br/>        R = []<br/>        for dom in self.D:<br/>            R.append(dom[item % len(dom)])<br/>            item //= len(dom)<br/>        return tuple(R)</span></pre><p id="14b5" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">您可以用这种方式测试上面的代码:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="9faf" class="lp kk hy ll b fi lq lr l ls lt">&gt;&gt;&gt; c = Combine([('a', 'b'), ('1', '2', '3')])<br/>&gt;&gt;&gt; for i in range(125, 136):<br/> print(''.join(c[i]), end=' ')</span><span id="8f81" class="lp kk hy ll b fi lu lr l ls lt">b3 a1 b1 a2 b2 a3 b3 a1 b1 a2 b2</span></pre><p id="7fd8" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">Combine类的目的是提供一种技术，允许我们在没有任何误差的情况下遍历每一种可能性(暴力)。另一方面，我们能够用一个大数字来索引任何可能性。因此我们可以使用的迭代器如下。</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="4f35" class="lp kk hy ll b fi lq lr l ls lt">def corresp (dom, im, ini = 0):<br/>    'Returns the iterator'<br/>    'For every item in dom there is no more than one item in im'<br/>    X = Combine(dom)<br/>    Y = Combine(im)<br/>    while True:<br/>        C = {}<br/>        index = ini<br/>        for j in range(X.len):<br/>            C[X[ini + j]] = Y[index]<br/>            index //= Y.len<br/>        yield C<br/>        ini += 1</span></pre><p id="0996" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">这个迭代器最初是专门为考虑所有匹配而准备的。因此，如果只有一个对应关系作为约束，就很容易建立一个时间表。</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="7c29" class="lp kk hy ll b fi lq lr l ls lt">&gt;&gt;&gt; for X in corresp(*test1(3, 4, 2, 2, 5, 5)):<br/> print(X)<br/> break</span><span id="cc6c" class="lp kk hy ll b fi lu lr l ls lt">{('r0', 'h0', 'd0'): ('s0', 't0', 'c0'), ('r1', 'h0', 'd0'): ('s0', 't0', 'c0'), ('r0', 'h1', 'd0'): ('s0', 't0', 'c0'), ('r1', 'h1', 'd0'): ('s0', 't0', 'c0'), ('r0', 'h2', 'd0'): ('s0', 't0', 'c0'), ('r1', 'h2', 'd0'): ('s0', 't0', 'c0'), ('r0', 'h3', 'd0'): ('s0', 't0', 'c0'), ('r1', 'h3', 'd0'): ('s0', 't0', 'c0'), ('r0', 'h0', 'd1'): ('s0', 't0', 'c0'), ('r1', 'h0', 'd1'): ('s0', 't0', 'c0'), ('r0', 'h1', 'd1'): ('s0', 't0', 'c0'), ('r1', 'h1', 'd1'): ('s0', 't0', 'c0'), ('r0', 'h2', 'd1'): ('s0', 't0', 'c0'), ('r1', 'h2', 'd1'): ('s0', 't0', 'c0'), ('r0', 'h3', 'd1'): ('s0', 't0', 'c0'), ('r1', 'h3', 'd1'): ('s0', 't0', 'c0'), ('r0', 'h0', 'd2'): ('s0', 't0', 'c0'), ('r1', 'h0', 'd2'): ('s0', 't0', 'c0'), ('r0', 'h1', 'd2'): ('s0', 't0', 'c0'), ('r1', 'h1', 'd2'): ('s0', 't0', 'c0'), ('r0', 'h2', 'd2'): ('s0', 't0', 'c0'), ('r1', 'h2', 'd2'): ('s0', 't0', 'c0'), ('r0', 'h3', 'd2'): ('s0', 't0', 'c0'), ('r1', 'h3', 'd2'): ('s0', 't0', 'c0')}</span></pre><p id="5b6a" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">但我们不能忘记，在时间表中，它很重要:</p><ul class=""><li id="0c7f" class="lv lw hy jp b jq jr jt ju jw lx ka ly ke lz ki ma mb mc md bi translated">受试者一周内出现的次数，</li><li id="8550" class="lv lw hy jp b jq me jt mf jw mg ka mh ke mi ki ma mb mc md bi translated">受试者每天有多少不连续的小时，以及</li><li id="0973" class="lv lw hy jp b jq me jt mf jw mg ka mh ke mi ki ma mb mc md bi translated">一个老师每天有多少不连续的小时。</li></ul><p id="bdef" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">所以这段代码很可能是第一近似值。虽然这篇文章的目的不是讨论如何生成时间表。</p><h1 id="8a82" class="kj kk hy bd kl km kn ko kp kq kr ks kt je ku jf kv jh kw ji kx jk ky jl kz la bi translated">逻辑上的暴力</h1><p id="2ccf" class="pw-post-body-paragraph jn jo hy jp b jq lb iz js jt lc jc jv jw ld jy jz ka le kc kd ke lf kg kh ki hb bi translated">当一个小孩子在逻辑上有问题时，他似乎不会应用克莱尼的公理来解决它；或者是某个聪明人的正式系统产品。</p><figure class="lg lh li lj fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mj"><img src="../Images/f9b5cf601b339afbde7c88dce4e5a3c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U3uH89SM4RQJToEcLrFsPw.jpeg"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">Reducing our axioms to the expression minimum sometimes does not help the resolution of our problems.</figcaption></figure><p id="7511" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">他使用的机制似乎接近<strong class="jp mk">观察者模式</strong>。也就是说，尝试对表达式中的每个幻影应用简单的操作。</p><figure class="lg lh li lj fd hk er es paragraph-image"><div class="er es ml"><img src="../Images/446d89560b7ad353bbe43af831aecd44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*Jhtau0xFtdXyJlOSqNRZhw.png"/></div><figcaption class="hr hs et er es ht hu bd b be z dx">Observer Pattern</figcaption></figure><p id="f36d" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">在非常有序的结构中测试所有可能的组合可能是快速找到解决方案的好方法。但是，首先，<strong class="jp mk">观察者模式</strong>是如何工作的？</p><h2 id="8978" class="lp kk hy bd kl mm mn mo kp mp mq mr kt jw ms mt kv ka mu mv kx ke mw mx kz my bi translated">观察者模式示例</h2><p id="edf2" class="pw-post-body-paragraph jn jo hy jp b jq lb iz js jt lc jc jv jw ld jy jz ka le kc kd ke lf kg kh ki hb bi translated">想象一下，你对一件红色的衣服感兴趣，但你不是唯一感兴趣的人。随着时间的推移，这些类型的衣服可能会出现在商店里，所以，为了尽快去买它们，你给商店你的电话号码，以便他们可以打电话给你。</p><figure class="lg lh li lj fd hk er es paragraph-image"><div class="er es mz"><img src="../Images/713fcb73b571cc9e08615c7b6f934599.png" data-original-src="https://miro.medium.com/v2/resize:fit:1052/format:webp/1*jz8G5h1fnmFwbn0wMak-Qg.png"/></div></figure><p id="7b57" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">因此，要应用该模式，我们必须识别用户订阅和通知每个人发生任何变化的机制。</p><p id="81f7" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">这怎么可能适用于逻辑呢？</p><h2 id="cef6" class="lp kk hy bd kl mm mn mo kp mp mq mr kt jw ms mt kv ka mu mv kx ke mw mx kz my bi translated">微型机器的原因</h2><p id="4137" class="pw-post-body-paragraph jn jo hy jp b jq lb iz js jt lc jc jv jw ld jy jz ka le kc kd ke lf kg kh ki hb bi translated">当我提供一个能够满足循环中任何布尔公式的实现时，我要求一个多项式时间，它既不小于也不大于<em class="na"> n </em> ⁵，<em class="na"> n </em>是子句的数量。如下所述:</p><div class="hh hi ez fb hj nb"><a rel="noopener follow" target="_blank" href="/swlh/the-boolean-satisfiability-problem-solved-48ceb5550115"><div class="nc ab dw"><div class="nd ab ne cl cj nf"><h2 class="hz b fi z dy ng ea eb nh ed ef hx bi translated">布尔可满足性问题，解决了吗？</h2><div class="ni l"><h3 class="bd b fi z dy ng ea eb nh ed ef dx translated">在这里，我展示了一些终极技术来制作逻辑运算的强大工具。</h3></div><div class="nj l"><p class="bd b fp z dy ng ea eb nh ed ef dx translated">medium.com</p></div></div><div class="nk l"><div class="nl l nm nn no nk np hp nb"/></div></div></a></div><p id="3bce" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">然而，O(n⁵)和o(n⁵)的意思是，如果对于大小为10(10个子句的布尔公式)的条目，我们需要1秒来求解[10⁵时间标记→ 1秒]，那么对于大小为20的条目，我们将需要:20⁵ = 2⁵ 10⁵ → 2⁵ 1秒= 32秒。这就是为什么，即使代码在未来的机器上会运行得更快，我们也可能对更快的结果感兴趣。</p><h1 id="6a9e" class="kj kk hy bd kl km kn ko kp kq kr ks kt je ku jf kv jh kw ji kx jk ky jl kz la bi translated">准备结构</h1><p id="37f2" class="pw-post-body-paragraph jn jo hy jp b jq lb iz js jt lc jc jv jw ld jy jz ka le kc kd ke lf kg kh ki hb bi translated">为了利用observer模式上的蛮力在记录时间内解决任何布尔公式，我们需要将所有变量放入一个数组中，包括时态变量。</p><p id="4079" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">想象一个数组，它只存储布尔值和<strong class="jp mk"> None </strong>值，当该值不是<strong class="jp mk"> None </strong>时，所有订阅该单元的微电机都将得到通知(<strong class="jp mk">观察者模式</strong>)。</p><p id="9a32" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">事实上，如果我们可以在访问数组的元素时通过索引来计算它的倒数，那么使用这个数组会更容易。也就是做一些类似于:A[-X] = 1- A[X]的性质</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="28cc" class="lp kk hy ll b fi lq lr l ls lt">class DiaconArray:<br/>    def __init__(self, size):<br/>        self.body=[None]*size</span><span id="aaba" class="lp kk hy ll b fi lu lr l ls lt">    def __setitem__(self, position, value):<br/>        if value == None:<br/>            self.body[position] = None<br/>        elif position&lt;0:<br/>            self.body[-position] = 1 - value<br/>        else:<br/>            self.body[position] = value</span><span id="79f3" class="lp kk hy ll b fi lu lr l ls lt">    def __getitem__(self,position):<br/>        if type(position) == slice:<br/>            other = DiaconArray(1)<br/>            other.body = self.body[position]<br/>            return other<br/>        elif self.body[abs(position)] == None:<br/>            return None<br/>        elif position &lt; 0:<br/>            return 1 - self.body[-position]<br/>        else:<br/>            return self.body[position]</span></pre><p id="1e0f" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">你可以在这篇文章的末尾找到代码的链接。</p><p id="dceb" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">观察器按照重复的逻辑运算符模式构造，即所有观察器执行相同的逻辑运算。在这种情况下，我们将使用来自<a class="ae hv" href="https://en.wikipedia.org/wiki/Cryptanalysis" rel="noopener ugc nofollow" target="_blank">密码分析</a>的所谓χ运算符。</p><p id="953e" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">假设我们将χ定义为:<code class="du nq nr ns ll b">chi = lambda x, y, z0: (x &amp; (1^y)) ^ z0 </code>每个观察者将由4个时间变量组成，其中3必须是χ的入口，第四个是输出。也就是说，如果<em class="na"> x </em>、<em class="na"> y </em>和<em class="na"> z0 </em>不是<strong class="jp mk"> None </strong>，那么输出可以通过上面的公式求解。但是，如果输出不是<strong class="jp mk"> None </strong>和<em class="na"> x </em>和<em class="na"> y </em>会发生什么……那么我们就有足够的信息知道<em class="na"> z0 </em>的值。这就是为什么我们要用不同的方式定义我们的微电机。</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="53cf" class="lp kk hy ll b fi lq lr l ls lt">class Chi:<br/>    opChi=[ lambda x,y,z0,z1:z0^z1 if y==0 else None,<br/>            lambda x,y,z0,z1: z0^z1^1 if x==1 else None,<br/>            lambda x,y,z0,z1:(x&amp;(1^y))^z1,<br/>            lambda x,y,z0,z1:(x&amp;(1^y))^z0]</span></pre><p id="7485" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">在这种情况下，我们观察如果我们想要猜测χ( <em class="na"> x，y，z0，z1 </em>)中的参数0、1、2或3，我们必须做的四种操作。</p><p id="80c3" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">但是，如果我们只有一些价值观，而不是所有必要的价值观，我们能做什么呢？下一段代码中的解决方案:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="2335" class="lp kk hy ll b fi lq lr l ls lt">X=["323121323020313010212010",<br/>                    #0000<br/>       "212010",    #0001<br/>       "313010",    #0010<br/>       "10",        #0011<br/>       "323020",    #0100<br/>       "20",        #0101<br/>       "30",        #0110<br/>       "0",         #0111<br/>       "323121",    #1000<br/>       "21",        #1001<br/>       "31",        #1010<br/>       "1",         #1011<br/>       "32",        #1100<br/>       "2",         #1101<br/>       "3",         #1110<br/>       "",          #1111<br/>       ]</span></pre><p id="5e3b" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">如果我们知道χ( <em class="na"> x，y，z0，z1 </em>)中除第四个<code class="du nq nr ns ll b">#1110</code>以外的所有自变量，我们只需找到<em class="na"> opChi </em>中的第四个<code class="du nq nr ns ll b">"3"</code>运算符，如果我们知道除第三个<code class="du nq nr ns ll b">#1101</code>以外的所有自变量，我们只需找到第三个<code class="du nq nr ns ll b">"2"</code>。所以从逻辑上来说，如果我们知道除了第四个和第三个<code class="du nq nr ns ll b">#1100</code>之外的所有论点，我们只需要找到后面的或者第三个或者第四个运算符<code class="du nq nr ns ll b">"32"</code>，这取决于我们之前推导的论点。</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="304e" class="lp kk hy ll b fi lq lr l ls lt">class Chi:<br/>    def __init__(self, n, op=[]):<br/>        'None means indeterminate'<br/>        self.observers=DiaconArray(n)<br/>        self.operators=op[:]<br/>        self.methods=[]         #Invariant of the launchers<br/>                                # [(function, X, Y, Z0, Z1),...]<br/>        self.launchers={}      # observers no observed<br/>                                # {pos:[(posMet, posArg),...],...}<br/>                                # posArg respecting the string<br/>        for K in range(n):<br/>            self.launchers[K]=[]<br/>        for o in op:<br/>            self._generateInvariant(o)</span></pre><p id="d954" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">在<em class="na">方法</em>中我们把推导出来的字符串放到<em class="na">池中。X </em>，以及数组中作为操作参数的位置。在<em class="na">发射器</em>中，我们为每一个<strong class="jp mk">无</strong>位置声明，什么是<em class="na">方法</em>索引，以及那个<strong class="jp mk">无</strong>位置的字符串<em class="na">函数</em>索引。我们将通知观察者<em class="na"> _generateInvariant </em>中的所有操作符。</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="d35a" class="lp kk hy ll b fi lq lr l ls lt">def _generateInvariant(self, operator):<br/>        for op in operator:<br/>            if abs(op)&gt;=len(self.observers):<br/>                n=len(self.observers)<br/>                self.observers+=DiaconArray(abs(op)-n+1)<br/>                for K in range(n,len(self.observers)):<br/>                    self.launchers[K]=[]<br/>        <br/>        px,py,pz0,pz1=operator<br/>        function=Chi.X[Chi.apply(self.observers[px],<br/>                                 self.observers[py],<br/>                                 self.observers[pz0],<br/>                                 self.observers[pz1])]<br/>        if len(function)==0:<br/>            return False<br/>        elif len(function)==1:<br/>            value= Chi.opChi[int(function)](<br/>                            self.observers[px],<br/>                            self.observers[py],<br/>                            self.observers[pz0],<br/>                            self.observers[pz1])<br/>            self[(px,py,pz0,pz1)[int(function)]]=value<br/>            return False<br/>        elif function=="10":<br/>            if not self.observers[pz0]==self.observers[pz1]:<br/>                self[px]=1<br/>                self[py]=0<br/>                return False<br/>        elif function=="20":<br/>            if self.observers[py]==1:<br/>                self[pz0]=self.observers[pz1]<br/>                return False<br/>        elif function=="30":<br/>            if self.observers[py]==1:<br/>                self[pz1]=self.observers[pz0]<br/>                return False<br/>        elif function=="21":<br/>            if self.observers[px]==0:<br/>                self[pz0]=self.observers[pz1]<br/>                return False<br/>        elif function=="31":<br/>            if self.observers[px]==0:<br/>                self[pz1]=self.observers[pz0]<br/>                return False<br/>            <br/>        self.methods.append((function,px,py,pz0,pz1))<br/>        for k in range(4):<br/>            Key=(px,py,pz0,pz1)[k]<br/>            if self.observers[Key]==None:<br/>                self.launchers[abs(Key)].append(<br/>                    (len(self.methods)-1,k))<br/>        return True</span></pre><p id="0444" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">要理解代码，您必须观察某些部分:</p><ul class=""><li id="9021" class="lv lw hy jp b jq jr jt ju jw lx ka ly ke lz ki ma mb mc md bi translated"><em class="na"> apply </em>方法从每个自变量的状态<strong class="jp mk">None</strong>/not-<strong class="jp mk">None</strong>中解码出X索引。</li><li id="6c00" class="lv lw hy jp b jq me jt mf jw mg ka mh ke mi ki ma mb mc md bi translated">如果<code class="du nq nr ns ll b">len(function)==1</code>表示不需要新的<em class="na">观测器</em>。因为有可能直接解决<strong class="jp mk">无</strong>论证。</li><li id="f668" class="lv lw hy jp b jq me jt mf jw mg ka mh ke mi ki ma mb mc md bi translated">有一些例外，不需要新的<em class="na">观察器</em>。</li><li id="72d5" class="lv lw hy jp b jq me jt mf jw mg ka mh ke mi ki ma mb mc md bi translated">最后，在<em class="na">方法</em>中添加操作符，并配置其每个无参数启动器。</li></ul><p id="3876" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">在我的上一个版本中，我实现了不同的方法来确保查询:温度参数<em class="na">越高，给出一致响应的可能性就越大，但是会执行更多的操作。</em></p><h1 id="5d22" class="kj kk hy bd kl km kn ko kp kq kr ks kt je ku jf kv jh kw ji kx jk ky jl kz la bi translated">界面结构</h1><p id="dc5a" class="pw-post-body-paragraph jn jo hy jp b jq lb iz js jt lc jc jv jw ld jy jz ka le kc kd ke lf kg kh ki hb bi translated">构造完结构的内核后，你会注意到使用它很困难:你需要把每一个逻辑公式想象成χ运算符的组合。为了解决测试所有结果的问题，我在同一个文件中实现了<strong class="jp mk"> DiaconChi </strong>类。</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="9850" class="lp kk hy ll b fi lq lr l ls lt">class DiaconChi:<br/>    def __init__(self,n):<br/>        self.C = Chi(2*n)<br/>        self.n = n<br/>        self.auxiliars = 1<br/>        self.C[0] = 0<br/>        self.C[1] = 1</span></pre><p id="b5c4" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">在这种情况下，我们将在数组的奇数位置使用临时变量，在偶数位置使用用户变量。请注意，第一个时间变量是1，第一个用户变量是0。</p><p id="ea84" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">但是我们感兴趣的代码是这个。</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="73c0" class="lp kk hy ll b fi lq lr l ls lt">def _adjustN(self,*secuencia):<br/>        for X in secuencia:<br/>            if abs(X) &gt;= self.n:<br/>                self.n = abs(X) + 1</span><span id="bb06" class="lp kk hy ll b fi lu lr l ls lt">def AND(self, result, *sec):<br/>        self._adjustN(result)<br/>        self._adjustN(*sec)<br/>        R = 2 * sec[0]<br/>        for op in sec[1:-1]:<br/>            auxiliar = 2 * self.auxiliars + 1<br/>            self.auxiliars += 1<br/>            self.C.opera([R,-2*op,0,auxiliar])<br/>            R = auxiliar<br/>        self.C.opera([R,-2*sec[-1],0,2*result])</span><span id="c421" class="lp kk hy ll b fi lu lr l ls lt">def _ANDaux(self, rAux, *sec):<br/>        'rAux is the output'<br/>        self._adjustN(*sec)<br/>        R = sec[0]<br/>        for op in sec[1:-1]:<br/>            auxiliar = 2 * self.auxiliars + 1<br/>            self.auxiliars += 1<br/>            self.C.opera([R, -op, 0, auxiliar])<br/>            R = auxiliar<br/>        self.C.opera([R, -sec[-1], 0, rAux])</span><span id="750c" class="lp kk hy ll b fi lu lr l ls lt">def OR(self, result, *sec):<br/>        self.AND(-result, *tuple([-X for X in sec]))</span><span id="766f" class="lp kk hy ll b fi lu lr l ls lt">def SAT3(self, clauses):<br/>        for c in clauses:<br/>            self._ANDaux(0, -2*c[0], -2*c[1], -2*c[2])</span></pre><p id="cdd8" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">考虑到，</p><ul class=""><li id="6184" class="lv lw hy jp b jq jr jt ju jw lx ka ly ke lz ki ma mb mc md bi translated"><em class="na"> _adjustN </em>是一种方法，如果变量需要，它可以使数组变长。</li><li id="e910" class="lv lw hy jp b jq me jt mf jw mg ka mh ke mi ki ma mb mc md bi translated"><em class="na"> opera </em>是主张χ运算的原生方法。</li><li id="3a25" class="lv lw hy jp b jq me jt mf jw mg ka mh ke mi ki ma mb mc md bi translated">SAT3在数组中实现了三个布尔量之和的布尔积。</li></ul><p id="ae03" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">我们来查一下，(x+y+z)(x+y+z)(x+y+z)= 1；如果<em class="na"> x </em> =1、<em class="na"> z </em> =0，那么<em class="na"> y </em>会怎么样？</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="ad3a" class="lp kk hy ll b fi lq lr l ls lt">&gt;&gt;&gt; C=DiaconChi(23)<br/>&gt;&gt;&gt; C[0]<br/>0<br/>&gt;&gt;&gt; C[1]<br/>&gt;&gt;&gt; C.SAT([(1,2,3),(-1,-2,3),(1,-2,-3)])<br/>&gt;&gt;&gt; C[1]<br/>&gt;&gt;&gt; C[2]<br/>&gt;&gt;&gt; C[3]<br/>&gt;&gt;&gt; C[1]=1<br/>&gt;&gt;&gt; C[3]=0<br/>&gt;&gt;&gt; C[2]<br/>0<br/>&gt;&gt;&gt; C<br/>0100-------------------</span></pre><h1 id="ffe2" class="kj kk hy bd kl km kn ko kp kq kr ks kt je ku jf kv jh kw ji kx jk ky jl kz la bi translated">关于效率和精度</h1><p id="5c24" class="pw-post-body-paragraph jn jo hy jp b jq lb iz js jt lc jc jv jw ld jy jz ka le kc kd ke lf kg kh ki hb bi translated">在这一节中，我将提出一个代码来测试微型机器何时正确工作以及它们在几秒钟内有多快。</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="5ca3" class="lp kk hy ll b fi lq lr l ls lt">from profile import time<br/>from random import randrange<br/>def testGen(clauses, variables):<br/>    cc = DiaconChi(variables)<br/>    SAT3 = [[(randrange(variables)+1) * (2*randrange(2)-1) \<br/>                  for Y in range(3)] \<br/>                     for X in range(clauses)]<br/>    <br/>    cc.SAT(SAT3)<br/>    before = time.time()<br/>    try:<br/>        for V in range(1, variables+1):<br/>            if cc[V] is None:<br/>                cc[V] = 0<br/>    except BadAssignment:<br/>        return round(time.time() - before), False<br/>    elapsedTime = time.time() - before<br/>    for (A, B, C) in SAT3:<br/>        if (cc[A] or cc[B] or cc[C]) == 0:<br/>            raise "Fatal error"</span><span id="1e2e" class="lp kk hy ll b fi lu lr l ls lt">return round(elapsedTime, 4), True</span></pre><p id="466c" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">在前面的代码中，我们可以观察到三种可能的回报:</p><ul class=""><li id="2ff4" class="lv lw hy jp b jq jr jt ju jw lx ka ly ke lz ki ma mb mc md bi translated">如果有一个坏的尝试，它将返回时间浪费和错误。</li><li id="bf2f" class="lv lw hy jp b jq me jt mf jw mg ka mh ke mi ki ma mb mc md bi translated">如果有一个解决方案，它将返回所需的时间和真实值。</li><li id="8f12" class="lv lw hy jp b jq me jt mf jw mg ka mh ke mi ki ma mb mc md bi translated">如果代码中有一个错误(不是预期的)，它将引发一个“致命错误”</li></ul><p id="29f1" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">为了得到一个好的图形，我们需要这样的东西:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="04c4" class="lp kk hy ll b fi lq lr l ls lt">def precision(clauses, variables, lots):<br/>    T = 0<br/>    S = 0<br/>    for i in range(lots):<br/>        time, sucess = testGen(clauses, variables)<br/>        T += time<br/>        S += int(sucess)</span><span id="8ea9" class="lp kk hy ll b fi lu lr l ls lt">return round(T/lots, 4), round(S/lots, 4)</span></pre><p id="70bc" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">这将返回一对值(<em class="na">时间</em>，<em class="na">精度</em>)，进行批量平均。</p><p id="c3ae" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">你可以考虑<em class="na">时间</em>依赖于子句(观察者)的数量，而<em class="na">精度</em>依赖于变量和子句之间的比率(观察者之间的互联性)。</p><figure class="lg lh li lj fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es nt"><img src="../Images/13359d7765f5720eeab317c6e5524c05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pXbf0lnOPNh3l4Cf6XXtVg.jpeg"/></div></div></figure><h1 id="3943" class="kj kk hy bd kl km kn ko kp kq kr ks kt je ku jf kv jh kw ji kx jk ky jl kz la bi translated">守则和他们的结论</h1><p id="5752" class="pw-post-body-paragraph jn jo hy jp b jq lb iz js jt lc jc jv jw ld jy jz ka le kc kd ke lf kg kh ki hb bi translated">考虑到其他操作符还有一些其他版本，理解创建一个提供意想不到的好结果的专用机器是多么容易是很有趣的。人们可以想象在一个网络中通过不同的机器来分配观察器是多么容易。</p><p id="fe18" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">因此，这些应用程序是专为需要快速响应和高效分销网络的情况而设计的。</p><p id="f629" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">你可以测试所有的东西，并在我的书<em class="na">的两个文件中找到代码，这两个文件就是</em> : <a class="ae hv" href="https://archive.org/download/TheTwoExactPhilosophiesFiles" rel="noopener ugc nofollow" target="_blank"> DiaconArray.py和diaconChi.py </a></p></div></div>    
</body>
</html>