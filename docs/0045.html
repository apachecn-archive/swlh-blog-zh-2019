<html>
<head>
<title>Recursive paths with React Router</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React路由器的递归路径</h1>
<blockquote>原文：<a href="https://medium.com/swlh/recursive-paths-with-react-router-3ebddae98f68#2019-01-03">https://medium.com/swlh/recursive-paths-with-react-router-3ebddae98f68#2019-01-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/f1f63195cdda2e9a27346de65ca9af66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P5L0AT5R-AyY3juji5j2jw.jpeg"/></div></div></figure><p id="709c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因为React路由器只是组件，所以您可以做一些疯狂的事情，比如拥有递归路由。在本帖中，我们将通过分解React路由器文档中的“递归路径”示例来了解它们是如何工作的。</p><figure class="jo jp jq jr fd ij"><div class="bz dy l di"><div class="js jt l"/></div></figure><p id="56e7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">递归路由并不是世界上最实用的东西，但它们确实展示了React路由器基于组件的路由方法的好处。</p><p id="e27e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里的主要思想是，由于React路由器只是组件，理论上，您可以创建递归的，因此无限的路由。秘诀在于建立正确的数据结构，这可以导致无限的路线。在这个例子中，我们将使用一组人，他们都有一个id、一个名字和一组朋友。</p><pre class="jo jp jq jr fd ju jv jw jx aw jy bi"><span id="fa0c" class="jz ka hi jv b fi kb kc l kd ke">const users = [<br/>  { id: 0, name: 'Michelle', friends: [ 1, 2, 3 ] },<br/>  { id: 1, name: 'Sean', friends: [ 0, 3 ] },<br/>  { id: 2, name: 'Kim', friends: [ 0, 1, 3 ], },<br/>  { id: 3, name: 'David', friends: [ 1, 2 ] }<br/>]</span></pre><p id="c473" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">通过这样设置数据结构，当我们渲染一个<code class="du kf kg kh jv b">Person</code>时，我们将把他们所有的朋友渲染为<code class="du kf kg kh jv b">Link</code> s。然后，当一个<code class="du kf kg kh jv b">Link</code>被点击时，我们将把那个人的所有朋友渲染为<code class="du kf kg kh jv b">Link</code> s，等等。每点击一次<code class="du kf kg kh jv b">Link</code>，应用程序的路径名就会逐渐变长。</p><p id="0c43" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最初，我们会在<code class="du kf kg kh jv b">/</code>处，用户界面看起来会像这样</p><pre class="jo jp jq jr fd ju jv jw jx aw jy bi"><span id="8506" class="jz ka hi jv b fi kb kc l kd ke">Michelle's Friends</span><span id="0dbc" class="jz ka hi jv b fi ki kc l kd ke">* Sean<br/>  * Kim<br/>  * David</span></pre><p id="3a83" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果<code class="du kf kg kh jv b">Kim</code>被点击，那么URL将变成<code class="du kf kg kh jv b">/2</code> (Kim的ID ),用户界面将如下所示</p><pre class="jo jp jq jr fd ju jv jw jx aw jy bi"><span id="f535" class="jz ka hi jv b fi kb kc l kd ke">Michelle's Friends</span><span id="ddf5" class="jz ka hi jv b fi ki kc l kd ke">* Sean<br/>  * Kim<br/>  * David</span><span id="d2e9" class="jz ka hi jv b fi ki kc l kd ke">Kim's Friends</span><span id="4684" class="jz ka hi jv b fi ki kc l kd ke">* Michelle<br/>  * Sean<br/>  * David</span></pre><p id="8e85" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果点击了<code class="du kf kg kh jv b">David</code>，那么URL将变为<code class="du kf kg kh jv b">/2/3</code> (Kim的id，然后是David的id)，UI将如下所示</p><pre class="jo jp jq jr fd ju jv jw jx aw jy bi"><span id="d262" class="jz ka hi jv b fi kb kc l kd ke">Michelle's Friends</span><span id="2d73" class="jz ka hi jv b fi ki kc l kd ke">* Sean<br/>  * Kim<br/>  * David</span><span id="8cca" class="jz ka hi jv b fi ki kc l kd ke">Kim's Friends</span><span id="d5be" class="jz ka hi jv b fi ki kc l kd ke">* Michelle<br/>  * Sean<br/>  * David</span><span id="d421" class="jz ka hi jv b fi ki kc l kd ke">David's Friends</span><span id="3748" class="jz ka hi jv b fi ki kc l kd ke">* Sean<br/>  * Kim</span></pre><p id="bccc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">并且只要用户想要点击<code class="du kf kg kh jv b">Link</code> s，这个过程就重复</p><p id="9c98" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一旦建立了正确的数据结构，下一个重要的步骤就是不断地渲染一个<code class="du kf kg kh jv b">Route</code>和一些<code class="du kf kg kh jv b">Links</code>,因为我们正在创建无限的路线，所以我们需要确保我们有一个在每次点击<code class="du kf kg kh jv b">Link</code>时都会渲染的<code class="du kf kg kh jv b">Route</code>。如果没有，我们将不会得到更多的匹配，这意味着React路由器将不会渲染任何更多的组件。在我们的<code class="du kf kg kh jv b">Link</code>和<code class="du kf kg kh jv b">Route</code>中，我们都需要知道应用程序的当前路径名，这样我们就可以在每次点击<code class="du kf kg kh jv b">Link</code>时附加到它上面(就像上面的例子，我们从<code class="du kf kg kh jv b">/2</code>到<code class="du kf kg kh jv b">/2/3</code>，等等)。幸运的是，React路由器给了我们带有<code class="du kf kg kh jv b">match.url</code>的路径名。考虑到这一点，我们的<code class="du kf kg kh jv b">Link</code>的初始部分将如下所示</p><pre class="jo jp jq jr fd ju jv jw jx aw jy bi"><span id="c2f9" class="jz ka hi jv b fi kb kc l kd ke">&lt;Link to={`{match.url}/${id}}&gt;</span></pre><p id="6512" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们渲染的<code class="du kf kg kh jv b">Route</code>将匹配相似的模式，然后渲染相同的组件。</p><pre class="jo jp jq jr fd ju jv jw jx aw jy bi"><span id="9e9d" class="jz ka hi jv b fi kb kc l kd ke">&lt;Route path={`${match.url}/:id`} component={Person}/&gt;</span></pre><p id="bd87" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我们已经有了基础，让我们开始构建将要递归渲染的组件，<code class="du kf kg kh jv b">Person</code>。</p><p id="31d8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">记住，这个组件需要负责几件事情。</p><ol class=""><li id="5c46" class="kj kk hi is b it iu ix iy jb kl jf km jj kn jn ko kp kq kr bi translated">它应该为每个特定的人的朋友呈现一个链接组件。</li><li id="305c" class="kj kk hi is b it ks ix kt jb ku jf kv jj kw jn ko kp kq kr bi translated">它应该呈现一个与当前路径名+ /:id匹配的路由组件。</li></ol><p id="91d2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">和所有递归问题一样，我们需要以某种方式“启动”递归。通常这涉及到调用函数，但是如果它是一个被递归调用的组件，我们可以通过简单地创建元素来实现。</p><pre class="jo jp jq jr fd ju jv jw jx aw jy bi"><span id="8a88" class="jz ka hi jv b fi kb kc l kd ke">import React from 'react'<br/>import {<br/>  BrowserRouter as Router,<br/>  Route,<br/>  Link<br/>} from 'react-router-dom'</span><span id="b7fb" class="jz ka hi jv b fi ki kc l kd ke">const users = [<br/>  { id: 0, name: 'Michelle', friends: [ 1, 2, 3 ] },<br/>  { id: 1, name: 'Sean', friends: [ 0, 3 ] },<br/>  { id: 2, name: 'Kim', friends: [ 0, 1, 3 ], },<br/>  { id: 3, name: 'David', friends: [ 1, 2 ] }<br/>]</span><span id="5f2b" class="jz ka hi jv b fi ki kc l kd ke">const Person = ({ match }) =&gt; {<br/>  return (<br/>    &lt;div&gt;<br/>      PERSON<br/>    &lt;/div&gt;<br/>  )<br/>}</span><span id="bd3f" class="jz ka hi jv b fi ki kc l kd ke">class App extends React.Component {<br/>  render() {<br/>    return (<br/>      &lt;Router&gt;<br/>        &lt;Person /&gt;<br/>      &lt;/Router&gt;<br/>    )<br/>  }<br/>}</span><span id="ac66" class="jz ka hi jv b fi ki kc l kd ke">export default App</span></pre><p id="7aa6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我们需要做的是弄清楚如何从我们的<code class="du kf kg kh jv b">users</code>数组中获取特定朋友的信息，这样我们就可以获取他们的名字并呈现他们的朋友。您可能会注意到这里的一个问题。最终<code class="du kf kg kh jv b">Person</code>将由React路由器渲染，因此它将被传递一个<code class="du kf kg kh jv b">match</code>道具。我们将使用这个<code class="du kf kg kh jv b">match</code>道具来获取当前路径名以及(在<code class="du kf kg kh jv b">users</code>的帮助下)这个人的名字和好友列表。问题是我们在主<code class="du kf kg kh jv b">App</code>组件中手工渲染<code class="du kf kg kh jv b">Person</code>来启动递归。这意味着第一次渲染<code class="du kf kg kh jv b">Person</code>时<code class="du kf kg kh jv b">match</code>将是未定义的。这个问题的解决方案比看起来简单。当我们第一次手动渲染<code class="du kf kg kh jv b">&lt;Person /&gt;</code>时，我们需要像React Router一样传递给它一个<code class="du kf kg kh jv b">match</code>属性。</p><pre class="jo jp jq jr fd ju jv jw jx aw jy bi"><span id="9ea1" class="jz ka hi jv b fi kb kc l kd ke">class App extends React.Component {<br/>  render() {<br/>    return (<br/>      &lt;Router&gt;<br/>        &lt;Person match={{ params: { id: 0 }, url: '' }}/&gt;<br/>      &lt;/Router&gt;<br/>    )<br/>  }<br/>}</span></pre><p id="e176" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，每次<code class="du kf kg kh jv b">Person</code>被渲染，包括第一次，它都会被传递一个<code class="du kf kg kh jv b">match</code>道具，其中包含我们需要的两个东西，<code class="du kf kg kh jv b">url</code>用于渲染我们的<code class="du kf kg kh jv b">Route</code>和<code class="du kf kg kh jv b">Link</code> s和<code class="du kf kg kh jv b">params.id</code>，这样我们就可以知道哪个人被渲染了。</p><p id="b8f5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">好吧，回到手头的主要目标。<code class="du kf kg kh jv b">Person</code>需要</p><ol class=""><li id="1916" class="kj kk hi is b it iu ix iy jb kl jf km jj kn jn ko kp kq kr bi translated">它应该为每个特定的人的朋友呈现一个链接组件。</li><li id="c6c0" class="kj kk hi is b it ks ix kt jb ku jf kv jj kw jn ko kp kq kr bi translated">它应该呈现一个与当前路径名+ /:id匹配的路由组件。</li></ol><p id="e033" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们解决第一个问题。在我们可以渲染任何<code class="du kf kg kh jv b">Link</code> s之前，我们需要得到这个人的朋友。我们已经从<code class="du kf kg kh jv b">match.params.id</code>那里知道了这个人的<code class="du kf kg kh jv b">id</code>。将这些知识与<code class="du kf kg kh jv b">Array.find</code>方法结合使用意味着获取朋友信息应该非常简单。我们将为它创建一个助手函数。</p><pre class="jo jp jq jr fd ju jv jw jx aw jy bi"><span id="70f2" class="jz ka hi jv b fi kb kc l kd ke">const users = [<br/>  { id: 0, name: 'Michelle', friends: [ 1, 2, 3 ] },<br/>  { id: 1, name: 'Sean', friends: [ 0, 3 ] },<br/>  { id: 2, name: 'Kim', friends: [ 0, 1, 3 ], },<br/>  { id: 3, name: 'David', friends: [ 1, 2 ] }<br/>]</span><span id="b935" class="jz ka hi jv b fi ki kc l kd ke">const find = (id) =&gt; users.find(p =&gt; p.id == id)</span><span id="5dda" class="jz ka hi jv b fi ki kc l kd ke">const Person = ({ match }) =&gt; {<br/>  const person = find(match.params.id)</span><span id="cf44" class="jz ka hi jv b fi ki kc l kd ke">return (<br/>    &lt;div&gt;<br/>      PERSON<br/>    &lt;/div&gt;<br/>  )<br/>}</span></pre><p id="a6ca" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">慢慢到达那里。现在我们有了这个人，让我们为他们的每个朋友渲染一些UI，包括<code class="du kf kg kh jv b">Link</code>。</p><pre class="jo jp jq jr fd ju jv jw jx aw jy bi"><span id="bccf" class="jz ka hi jv b fi kb kc l kd ke">const users = [<br/>  { id: 0, name: 'Michelle', friends: [ 1, 2, 3 ] },<br/>  { id: 1, name: 'Sean', friends: [ 0, 3 ] },<br/>  { id: 2, name: 'Kim', friends: [ 0, 1, 3 ], },<br/>  { id: 3, name: 'David', friends: [ 1, 2 ] }<br/>]</span><span id="045e" class="jz ka hi jv b fi ki kc l kd ke">const find = (id) =&gt; users.find(p =&gt; p.id == id)</span><span id="d31c" class="jz ka hi jv b fi ki kc l kd ke">const Person = ({ match }) =&gt; {<br/>  const person = find(match.params.id)</span><span id="4e38" class="jz ka hi jv b fi ki kc l kd ke">return (<br/>    &lt;div&gt;<br/>      &lt;h3&gt;{person.name}’s Friends&lt;/h3&gt;<br/>      &lt;ul&gt;<br/>        {person.friends.map((id) =&gt; (<br/>          &lt;li key={id}&gt;<br/>            &lt;Link to={`${match.url}/${id}`}&gt;<br/>              {find(id).name}<br/>            &lt;/Link&gt;<br/>          &lt;/li&gt;<br/>        ))}<br/>      &lt;/ul&gt;<br/>    &lt;/div&gt;<br/>  )<br/>}</span></pre><p id="5d39" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们就要完成了。现在我们已经为这个人的每个朋友准备了一个<code class="du kf kg kh jv b">Link</code>，正如#2中提到的，我们需要确保我们也渲染了一个<code class="du kf kg kh jv b">Route</code>。</p><pre class="jo jp jq jr fd ju jv jw jx aw jy bi"><span id="98ae" class="jz ka hi jv b fi kb kc l kd ke">const Person = ({ match }) =&gt; {<br/>  const person = find(match.params.id)</span><span id="23cb" class="jz ka hi jv b fi ki kc l kd ke">  return (<br/>    &lt;div&gt;<br/>      &lt;h3&gt;{person.name}’s Friends&lt;/h3&gt;<br/>      &lt;ul&gt;<br/>        {person.friends.map((id) =&gt; (<br/>          &lt;li key={id}&gt;<br/>            &lt;Link to={`${match.url}/${id}`}&gt;<br/>              {find(id).name}<br/>            &lt;/Link&gt;<br/>          &lt;/li&gt;<br/>        ))}<br/>      &lt;/ul&gt;<br/>      &lt;Route path={`${match.url}/:id`} component={Person}/&gt;<br/>    &lt;/div&gt;<br/>  )<br/>}</span></pre><p id="df5c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">完整的代码现在看起来像这样</p><pre class="jo jp jq jr fd ju jv jw jx aw jy bi"><span id="dd97" class="jz ka hi jv b fi kb kc l kd ke">import React from 'react'<br/>import {<br/>  BrowserRouter as Router,<br/>  Route,<br/>  Link<br/>} from 'react-router-dom'</span><span id="6d11" class="jz ka hi jv b fi ki kc l kd ke">const find = (id) =&gt; users.find(p =&gt; p.id == id)</span><span id="10c7" class="jz ka hi jv b fi ki kc l kd ke">const users = [<br/>  { id: 0, name: 'Michelle', friends: [ 1, 2, 3 ] },<br/>  { id: 1, name: 'Sean', friends: [ 0, 3 ] },<br/>  { id: 2, name: 'Kim', friends: [ 0, 1, 3 ], },<br/>  { id: 3, name: 'David', friends: [ 1, 2 ] }<br/>]</span><span id="45bb" class="jz ka hi jv b fi ki kc l kd ke">const Person = ({ match }) =&gt; {<br/>  const person = find(match.params.id)</span><span id="e40c" class="jz ka hi jv b fi ki kc l kd ke">  return (<br/>    &lt;div&gt;<br/>      &lt;h3&gt;{person.name}’s Friends&lt;/h3&gt;<br/>      &lt;ul&gt;<br/>        {person.friends.map((id) =&gt; (<br/>          &lt;li key={id}&gt;<br/>            &lt;Link to={`${match.url}/${id}`}&gt;<br/>              {find(id).name}<br/>            &lt;/Link&gt;<br/>          &lt;/li&gt;<br/>        ))}<br/>      &lt;/ul&gt;<br/>      &lt;Route path={`${match.url}/:id`} component={Person}/&gt;<br/>    &lt;/div&gt;<br/>  )<br/>}</span><span id="07ea" class="jz ka hi jv b fi ki kc l kd ke">class App extends React.Component {<br/>  render() {<br/>    return (<br/>      &lt;Router&gt;<br/>        &lt;Person match={{ params: { id: 0 }, url: '' }}/&gt;<br/>      &lt;/Router&gt;<br/>    )<br/>  }<br/>}</span><span id="66d9" class="jz ka hi jv b fi ki kc l kd ke">export default App</span></pre><p id="84cb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">第一次呈现<code class="du kf kg kh jv b">Person</code>时，我们传递给它一个模拟的<code class="du kf kg kh jv b">match</code>对象。然后，<code class="du kf kg kh jv b">Person</code>呈现一个<code class="du kf kg kh jv b">Link</code>列表以及一个与这些<code class="du kf kg kh jv b">Link</code>匹配的<code class="du kf kg kh jv b">Route</code>列表。当点击一个<code class="du kf kg kh jv b">Link</code>时，<code class="du kf kg kh jv b">Route</code>匹配将呈现另一个<code class="du kf kg kh jv b">Person</code>组件，该组件将呈现一个<code class="du kf kg kh jv b">Link</code>列表和一个新的<code class="du kf kg kh jv b">Route</code>。理论上，只要用户继续点击任何<code class="du kf kg kh jv b">Link</code> s，这个过程就会一直持续下去。</p></div><div class="ab cl kx ky gp kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="hb hc hd he hf"><p id="9df1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="le">这篇文章最初发表于</em><a class="ae lf" href="https://tylermcginnis.com/react-router-recursive-paths/" rel="noopener ugc nofollow" target="_blank"><em class="le">tylermcginnis.com</em></a><em class="le">作为他们</em> <a class="ae lf" href="https://tylermcginnis.com/courses/react-router/" rel="noopener ugc nofollow" target="_blank"> <em class="le"> React路由器</em> </a> <em class="le">课程的一部分。</em></p><figure class="jo jp jq jr fd ij er es paragraph-image"><a href="https://medium.com/swlh"><div class="er es lg"><img src="../Images/308a8d84fb9b2fab43d66c117fcc4bb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YqDjlKFwScoQYQ62DWEdig.png"/></div></a></figure><h2 id="c148" class="jz ka hi bd lh li lj lk ll lm ln lo lp jb lq lr ls jf lt lu lv jj lw lx ly lz bi translated">这篇文章发表在<a class="ae lf" href="https://medium.com/swlh" rel="noopener"> The Startup </a>上，这是Medium最大的创业刊物，拥有+408，714名读者。</h2><h2 id="869c" class="jz ka hi bd lh li lj lk ll lm ln lo lp jb lq lr ls jf lt lu lv jj lw lx ly lz bi translated">订阅接收<a class="ae lf" href="http://growthsupply.com/the-startup-newsletter/" rel="noopener ugc nofollow" target="_blank">我们的头条新闻</a>。</h2><figure class="jo jp jq jr fd ij er es paragraph-image"><a href="https://medium.com/swlh"><div class="er es lg"><img src="../Images/b0164736ea17a63403e660de5dedf91a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ouK9XR4xuNWtCes-TIUNAw.png"/></div></a></figure></div></div>    
</body>
</html>