<html>
<head>
<title>The Good/The Bad of React &amp; Redux: And Why Ducks Might Be The Solution</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React &amp; Redux的利与弊:以及为什么鸭子可能是解决方案</h1>
<blockquote>原文：<a href="https://medium.com/swlh/the-good-the-bad-of-react-redux-and-why-ducks-might-be-the-solution-1567d5bdc698#2019-01-19">https://medium.com/swlh/the-good-the-bad-of-react-redux-and-why-ducks-might-be-the-solution-1567d5bdc698#2019-01-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/758f3949865f8331496082c9c09a4b3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S8GuQs4miAzpBbCzwNI4Vw@2x.jpeg"/></div></div></figure><p id="09f7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在我深入React和Redux的世界之前，请允许我提供一些背景信息:</p><p id="35e7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你愿意的话，我的科技之旅是非传统或非传统的。我在大学里没有学过计算机科学，但在开始学习编程之前，我实际上做了7年的英语老师。</p><p id="2e4c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在教室里的那些年里，我花了大量时间讲授结构。我的意思是:</p><ul class=""><li id="616a" class="jp jq hi is b it iu ix iy jb jr jf js jj jt jn ju jv jw jx bi translated">5段短文</li><li id="c126" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">写提纲的艺术</li><li id="7461" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">语法规则</li><li id="efc8" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">&amp;正确的句子结构</li></ul><blockquote class="kd ke kf"><p id="9b99" class="iq ir kg is b it iu iv iw ix iy iz ja kh jc jd je ki jg jh ji kj jk jl jm jn hb bi translated"><em class="hi">谈到高中文学课，基本上所有的东西都是结构和组织。</em></p></blockquote><p id="1f7e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">结合我也是处女座的事实，这意味着我真的很喜欢<em class="kg">这样的结构。<em class="kg">明确地说，有组织的结构。</em></em></p><figure class="kl km kn ko fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kk"><img src="../Images/6b0240704fb9385debc91c3f395f82c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H0hvvXA2vLKwLpesyAdJRw.png"/></div></div><figcaption class="kp kq et er es kr ks bd b be z dx">Hi, my name is Lauren &amp; I’ll never not color code my notes</figcaption></figure><p id="a819" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Ada Developers Academy是一个为期一年的免费项目，旨在培训华盛顿州西雅图的女性和不同性别的人编写代码，我的同事们经常在我的彩色编码笔记上给我出难题。</p><p id="87d7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是在我的辩护中，我刚刚辞去了我的工作，冒着巨大的风险学习编码，这种东西适合我！它带给我平静、快乐和理智。</p><p id="8ae1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在学习编码的时候，就像我以前的教室一样，我喜欢一切都有自己的位置。</p><p id="fb30" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我喜欢精心组织的代码库，它真的能让我微笑。</p><p id="17a7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以，毫不奇怪，后来当我成为亚马逊的一名软件工程师时，我真的深深地爱上了React。</p><p id="988b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我相信很多读者可能已经知道了，但是React有许多强大的功能，包括:</p><ul class=""><li id="31eb" class="jp jq hi is b it iu ix iy jb jr jf js jj jt jn ju jv jw jx bi translated">虚拟世界</li><li id="6db9" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">本机兼容性</li><li id="77f7" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">相对较快的学习曲线</li><li id="6c1b" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">有用的开发工具</li></ul><p id="8f4b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is jo"> <em class="kg">但最重要的是:</em> </strong></p><ul class=""><li id="6ac9" class="jp jq hi is b it iu ix iy jb jr jf js jj jt jn ju jv jw jx bi translated">模块化组件的可重用性</li></ul><p id="e0c2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">自从了解它之后，我就一直被组件驱动架构深深吸引，这是React的基础。</p><blockquote class="kd ke kf"><p id="f6b1" class="iq ir kg is b it iu iv iw ix iy iz ja kh jc jd je ki jg jh ji kj jk jl jm jn hb bi translated"><strong class="is jo">TL；</strong> React博士的模块化组件非常棒，但有时国家管理会变得疯狂</p></blockquote><figure class="kl km kn ko fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ku"><img src="../Images/9c7da72336f57c4340391056e6fd5835.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wIQjDFk4iBryC5k68meTFA.png"/></div></div></figure><p id="8964" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有大量的文章/资源提供了关于<a class="ae kt" href="https://tylermcginnis.com/reactjs-tutorial-a-comprehensive-guide-to-building-apps-with-react/" rel="noopener ugc nofollow" target="_blank"> React的令人敬畏的特性</a>的细节，所以我不会在这里深入探讨这些特性，但是我会暂停一下，以确保我们在模块化和可重用组件方面达成一致。</p><p id="983f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当你用React构建一个应用时，你创建了一堆独立的、隔离的、可重用的组件。</p><p id="a016" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后将它们组合在一起，构建复杂的用户界面。</p><p id="f5dd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我以前是一个沉迷于语法规则遵循的老师，我喜欢这种暗示的鼓励组织和划分的方式。我发现组件的可重用性对工程师很有帮助。另外，在代码中查找东西总是很容易。</p><p id="0511" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了形象化这个概念，这里有一个React应用程序的截图，它聚合了观看数据来创建一个“最疯狂的电视节目”应用程序:</p><figure class="kl km kn ko fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kv"><img src="../Images/f575ad4662438691132e53b49b697104.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0lA0PbRN_sxeeVHjyPsGcA.png"/></div></div></figure><figure class="kl km kn ko fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kw"><img src="../Images/54bf843aa740773a2805c8ff33b46756.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fHfscFb79ksWoPqw01MU8w.png"/></div></div></figure><p id="a787" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">应用程序本身可以分为几个部分:</p><ul class=""><li id="74d9" class="jp jq hi is b it iu ix iy jb jr jf js jj jt jn ju jv jw jx bi translated">导航</li><li id="6f94" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">展示项目</li><li id="6bfb" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">该显示列表全部在一起</li></ul><p id="d0e0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">该应用的架构非常简单，但正如我们<em class="kg">所有人</em>所知，事情可能会变得复杂和棘手，并且很快就会从这个变成这个:</p><figure class="kl km kn ko fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kx"><img src="../Images/45f82f92fee7c3102ceadf1da4accad7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iyVFYdY26nnKMy-PyGs-Kg.png"/></div></div></figure><p id="e830" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，开发人员在这一点上被迫发现React的粘性或<em class="kg">不那么迷人的</em>部分。</p><p id="72b9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">开发人员经常想在应用程序中传递状态作为道具。React提倡单向流，当两个(或更多)组件共享相同的数据时，如果您希望保持数据“同步”,事情会变得混乱。</p><figure class="kl km kn ko fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ky"><img src="../Images/e8e89ccbca4c6206392b50f21f7504d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sQX7BW98hfDW20FonHo8Kg.png"/></div></div></figure><p id="b85a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">理想情况下，数据的真实来源只在一个地方。如果你有两个孩子需要访问相同的数据，React文档鼓励你<a class="ae kt" href="https://reactjs.org/docs/glossary.html#state" rel="noopener ugc nofollow" target="_blank">“提升状态”</a>。这意味着将数据放在这两个组件的最近的祖先中。但是如果这两个组件在树中相距很远，那么“最近的祖先”组件可能位于组件树的顶层。</p><p id="6ad3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让事情变得更加复杂的是，中间的组件可能完全没有被传递的道具的用途，只是刚好卡在中间，不得不传递。<em class="kg">不用了谢谢。</em></p><figure class="kl km kn ko fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kz"><img src="../Images/325b06b141fb812b91d36ae4897ebd4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WxjPzdw-gECIV4VzNkR3Ww.png"/></div></div></figure><p id="9acf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于这个概念，我最喜欢的类比是我想给我的表弟讲一个故事。但是我不能直接告诉她这个故事，我还需要告诉我的阿姨。如果这是一个小的，不尴尬的故事，这很好，但如果是关于一些我不一定想让我阿姨知道的事情呢？</p><p id="5299" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">好吧，扫兴的家伙，不管怎样我还是得通过她。</p><p id="ada2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，顶级祖先必须通过几个中间组件向下传递数据，才能到达正确的组件，就像我们小时候玩的游戏电话一样，这为未来的用户创造了一百万个不同的开发人员错误或不明确的机会。原始故事可能会变得混乱，当有人试图在许多组件之间传递道具时，他们很容易混淆。</p><blockquote class="kd ke kf"><p id="1aa8" class="iq ir kg is b it iu iv iw ix iy iz ja kh jc jd je ki jg jh ji kj jk jl jm jn hb bi translated">-也就是不好意思-</p></blockquote><p id="f5c9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">换个角度来看，一旦状态在组件树之间来回传递，很容易想象事情会变得非常复杂。</p><p id="504b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">雪上加霜的是，我的女儿<a class="ae kt" href="https://www.poodr.com/" rel="noopener ugc nofollow" target="_blank">桑迪·梅茨</a>教我<strong class="is jo">害怕耦合</strong>，这在每个组件及其父组件之间发生了很长时间。所以试着移动一个部件会变得非常复杂。在组件和它的父组件之间，以及在组件的子组件之间，都存在着耦合。</p><p id="3030" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，毫不奇怪，这会影响性能，因为每次数据更新都会导致所有子节点重新渲染——这会导致严重的性能和速度问题！</p><blockquote class="la"><p id="3524" class="lb lc hi hj ld le lf lg lh li lj jn dx translated">🤷🏼‍So:这真的是一种平衡行为。🤷🏼‍</p></blockquote><p id="964e" class="pw-post-body-paragraph iq ir hi is b it lk iv iw ix ll iz ja jb lm jd je jf ln jh ji jj lo jl jm jn hb bi translated">React带来了许多<em class="kg">好东西</em>，但是正如你所看到的，如果你希望构建比任务列表更复杂的东西，找到一个管理应用程序状态的解决方案是很重要的！</p><h2 id="524d" class="lp lq hi bd lr ls lt lu lv lw lx ly lz jb ma mb mc jf md me mf jj mg mh mi mj bi translated">当你处于项目的设计阶段时，通常有几件事是至关重要的:</h2><ul class=""><li id="b3ab" class="jp jq hi is b it mk ix ml jb mm jf mn jj mo jn ju jv jw jx bi translated">为了让应用程序能够扩展</li><li id="d1e7" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">能够创造出在未来几个月或几年都可以维护的东西</li><li id="23d0" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">我敢说，在国家管理方面，保持头脑清醒是件好事！</li></ul><figure class="kl km kn ko fd ij"><div class="bz dy l di"><div class="mp mq l"/></div></figure><h1 id="de15" class="mr lq hi bd lr ms mt mu lv mv mw mx lz my mz na mc nb nc nd mf ne nf ng mi nh bi translated">这让我想起了Redux——拯救世界的国家集装箱超级英雄！</h1><figure class="kl km kn ko fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nq"><img src="../Images/23da666345ad372a9a549cdff0ffc256.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TdBY1lsTYBgLlNChsniNAQ.png"/></div></div></figure><p id="21c6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以，还记得在组件之间传递数据的混乱吗？这就是Redux成功帮助你理解的。</p><p id="9749" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Redux是一个针对JavaScript应用的<strong class="is jo"> <em class="kg">状态管理工具</em> </strong>。这意味着我可以把数据<em class="kg">(或者关于我最近糟糕的约会出轨的尴尬故事)</em>传给我的表妹，而不必告诉我的阿姨。也就是说，我可以避免这个故事在所有组件(<em class="kg">或我的许多疯狂的叔叔们</em>)之间跳跃的混乱，只是为了更新或改变其中的一个。</p><h1 id="8354" class="mr lq hi bd lr ms mt mu lv mv mw mx lz my mz na mc nb nc nd mf ne nf ng mi nh bi translated">这一切之所以成为可能，是因为Redux最重要的原则:全球商店！</h1><p id="c9bb" class="pw-post-body-paragraph iq ir hi is b it mk iv iw ix ml iz ja jb nr jd je jf ns jh ji jj nt jl jm jn hb bi translated">让我们来谈谈这个。需要记住的重要一点是，应用程序的整个状态存储在一个中心位置 ，称为存储。</p><figure class="kl km kn ko fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nu"><img src="../Images/63479d7e5e7c334a996534d0332af634.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2iqyOItGTjw-b5-Kw7Sshw.png"/></div></div></figure><p id="8eeb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这意味着React应用程序的每个组件都可以直接访问应用程序的状态,而不必将道具发送给子组件，或者使用回调函数将数据发送回父组件！这很梦幻。</p><p id="6312" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Redux提供了一个中央存储，可以保存应用程序中任何地方的数据。</p><p id="be3a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">换句话说，Redux完全消除了当您将数据从父组件向下传递到许多不同的子组件并在所有这些地方操作它时可能发生的这种混乱的隧道效应。</p><h1 id="73e1" class="mr lq hi bd lr ms mt mu lv mv mw mx lz my mz na mc nb nc nd mf ne nf ng mi nh bi translated">现在，这是这一切是如何发生的图表:</h1><figure class="kl km kn ko fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nv"><img src="../Images/5372389ed20306880ee19542fe30bddb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VKRRsTEk3A3jM6ZPEBQPBA.png"/></div></div></figure><p id="b8a6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我将展示如何将它的每一部分添加到React应用程序中，以说明它们是如何一起工作的。</p><p id="5d60" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，对于我之前展示的应用程序，您可以想象这里的每种颜色都是不同的React组件。</p><figure class="kl km kn ko fd ij er es paragraph-image"><div class="er es nw"><img src="../Images/e06d2eace1a9b167f54ae89f5a50a3da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1332/format:webp/1*Cz_4jr-pRwXFmVtFiYkOiw.png"/></div></figure><p id="fe43" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">目前，通过just React，该应用中的数据流向如下:</p><figure class="kl km kn ko fd ij er es paragraph-image"><div class="er es nx"><img src="../Images/d4b506ad7969f7cf18903e267606c07c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1128/format:webp/1*Ugr8uwrPQA5vbzww9-u2jQ.png"/></div></figure><p id="6377" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是我想添加redux，以便状态和数据传输看起来更像这样:</p><figure class="kl km kn ko fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ny"><img src="../Images/badb750af88fcad4cb1facbbb88c2b84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tA1pTXB1_IUi6SAp-rjATw.png"/></div></div></figure><p id="78cf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要做到这一点，首先要做的是建立商店。</p></div><div class="ab cl nz oa gp ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="hb hc hd he hf"><h1 id="ac3f" class="mr lq hi bd lr ms og mu lv mv oh mx lz my oi na mc nb oj nd mf ne ok ng mi nh bi translated"><strong class="ak">如何将REDUX添加到REACT应用中</strong></h1><blockquote class="la"><p id="b7a5" class="lb lc hi hj ld le lf lg lh li lj jn dx translated"><strong class="ak">商店</strong></p></blockquote><p id="060a" class="pw-post-body-paragraph iq ir hi is b it lk iv iw ix ll iz ja jb lm jd je jf ln jh ji jj lo jl jm jn hb bi translated">关键是要记住Redux中的商店就像是<strong class="is jo">人类的大脑</strong>。这是绝对基本的:<em class="kg">整个应用程序的状态存在于存储中</em>。因此，首先，您应该创建一个用于包装状态的存储。</p><p id="9562" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在src文件夹中为redux创建一个目录:</p><pre class="kl km kn ko fd ol om on oo aw op bi"><span id="4325" class="lp lq hi om b fi oq or l os ot">src/redux/</span></pre><p id="bcfd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在以下位置创建一个存储文件夹:</p><pre class="kl km kn ko fd ol om on oo aw op bi"><span id="a4c3" class="lp lq hi om b fi oq or l os ot">src/redux/store/</span></pre><p id="6d13" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后创建一个名为<code class="du ou ov ow om b">index.js</code>的新文件，最后初始化存储:</p><pre class="kl km kn ko fd ol om on oo aw op bi"><span id="27f8" class="lp lq hi om b fi oq or l os ot">// src/redux/store/index.js </span><span id="3862" class="lp lq hi om b fi ox or l os ot">import { createStore } from ”redux”;<br/>import rootReducer from “../reducers/index”;</span><span id="87bc" class="lp lq hi om b fi ox or l os ot">const store = createStore(rootReducer);</span><span id="4da8" class="lp lq hi om b fi ox or l os ot">export default store;</span></pre><p id="0a7f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du ou ov ow om b">createStore()</code>是创建Redux存储的函数，虽然您也可以将一个初始状态传递给<code class="du ou ov ow om b">createStore()</code>，但大多数时候您不必这样做。虽然传递一个初始状态对于服务器端的渲染很有用，但是传统上，<strong class="is jo">状态来自reducers </strong>，这就是我在这里所做的——它将一个reducer (rootReducer)作为第一个参数。</p><blockquote class="kd ke kf"><p id="109a" class="iq ir kg is b it iu iv iw ix iy iz ja kh jc jd je ki jg jh ji kj jk jl jm jn hb bi translated">但是等等。我还没有真正解释减速器是做什么的！</p></blockquote><p id="53ac" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">记住，<em class="kg"> </em> <strong class="is jo">状态来自于</strong> <em class="kg">。现在重要的是理解减速器做什么。</em></p><blockquote class="la"><p id="1877" class="lb lc hi hj ld le lf lg lh li lj jn dx translated"><strong class="ak">减速器</strong></p></blockquote><p id="4a57" class="pw-post-body-paragraph iq ir hi is b it lk iv iw ix ll iz ja jb lm jd je jf ln jh ji jj lo jl jm jn hb bi translated">让我们回到我们的图表。</p><figure class="kl km kn ko fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es oy"><img src="../Images/a10ddaf37c96ed973c59dd8b457fdb2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LQhwJC5V8i2_Giaa6XuCQg.png"/></div></div></figure><p id="de8a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在Redux中，<strong class="is jo">减速器产生状态</strong>。国家不是你亲手创造的。</p><p id="ce6b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Reducers指定应用程序的状态如何改变。Redux的一个原则是状态是不可变的，不能原地改变。</p><blockquote class="la"><p id="55f5" class="lb lc hi hj ld le lf lg lh li lj jn dx translated">在plain React中，本地状态通过函数<code class="du ou ov ow om b">setState()</code>就地改变。</p></blockquote><h1 id="9632" class="mr lq hi bd lr ms mt mu lv mv mw mx lz my oz na mc nb pa nd mf ne pb ng mi nh bi translated">但是在Redux中，你不能这样做。</h1><p id="7817" class="pw-post-body-paragraph iq ir hi is b it mk iv iw ix ml iz ja jb nr jd je jf ns jh ji jj nt jl jm jn hb bi translated">reducer只是一个Javascript函数——它接受两个参数:当前状态和一个动作，<em class="kg"> </em>这就是为什么reducer必须是纯的——这意味着它为给定的输入返回完全相同的输出。</p><p id="7721" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">创建一个减速器实际上非常简单。</p><h2 id="6f84" class="lp lq hi bd lr ls lt lu lv lw lx ly lz jb ma mb mc jf md me mf jj mg mh mi mj bi translated">方法如下:</h2><p id="b03c" class="pw-post-body-paragraph iq ir hi is b it mk iv iw ix ml iz ja jb nr jd je jf ns jh ji jj nt jl jm jn hb bi translated">在redux中为根reducer创建一个目录:</p><pre class="kl km kn ko fd ol om on oo aw op bi"><span id="4ac7" class="lp lq hi om b fi oq or l os ot">src/redux/reducers/</span></pre><p id="9c4b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在该文件夹中创建一个新的<code class="du ou ov ow om b">index.js</code>文件。</p><p id="d6cf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在该文件中:</p><pre class="kl km kn ko fd ol om on oo aw op bi"><span id="c1a7" class="lp lq hi om b fi oq or l os ot">// src/redux/reducers/index.js</span><span id="54ad" class="lp lq hi om b fi ox or l os ot">const initialState = {<br/>  shows: []<br/>};</span><span id="3fcf" class="lp lq hi om b fi ox or l os ot">const rootReducer = (state = intitialState, action) =&gt; state;</span><span id="9ad0" class="lp lq hi om b fi ox or l os ot">export default rootReducer;</span></pre><p id="a41b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个减速器有点傻，因为它不做任何事情就返回初始状态。</p><p id="8ee5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是一定要注意初始状态是如何作为<a class="ae kt" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Default_parameters" rel="noopener ugc nofollow" target="_blank">默认参数</a>传递的。</p><h2 id="184f" class="lp lq hi bd lr ls lt lu lv lw lx ly lz jb ma mb mc jf md me mf jj mg mh mi mj bi translated">现在，减速器无疑是Redux中最重要的概念。我再说一遍，<strong class="ak">减速器产生应用状态</strong>。</h2><blockquote class="kd ke kf"><p id="160b" class="iq ir kg is b it iu iv iw ix iy iz ja kh jc jd je ki jg jh ji kj jk jl jm jn hb bi translated">但是这应该引出一个问题，<strong class="is jo">减速器如何知道<em class="hi">何时</em>产生下一个状态</strong>？</p></blockquote><blockquote class="la"><p id="e8d5" class="lb lc hi hj ld le pc pd pe pf pg jn dx translated"><strong class="ak">动作</strong></p></blockquote><p id="4fe1" class="pw-post-body-paragraph iq ir hi is b it lk iv iw ix ll iz ja jb lm jd je jf ln jh ji jj lo jl jm jn hb bi translated">这就是行动的由来！</p><p id="d733" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Redux的一个原则是，改变状态的唯一方法是向商店发送信号。<strong class="is jo">这个信号是一个动作。</strong></p><p id="62a0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is jo">“调度一个动作”</strong>就是发出一个信号的过程。</p><p id="4c28" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你如何改变一个不变的状态？<em class="kg">嗯，你没有。</em>结果状态是当前状态加上新数据的副本。</p><blockquote class="kd ke kf"><p id="3e13" class="iq ir kg is b it iu iv iw ix iy iz ja kh jc jd je ki jg jh ji kj jk jl jm jn hb bi translated">你可能会想，哇，劳伦，要知道的数据太多了。</p></blockquote><p id="8936" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">不过让人放心的是<strong class="is jo"> Redux动作无非就是Javascript对象</strong>！这是一个可能的例子:</p><pre class="kl km kn ko fd ol om on oo aw op bi"><span id="d1af" class="lp lq hi om b fi oq or l os ot">{<br/>  type: 'ADD_SHOW';<br/>  payload: { title: 'Marvelous Mrs. Maisel', rank: 1, picture: 'https://image.jpg' } <br/>}</span></pre><h2 id="13f2" class="lp lq hi bd lr ls lt lu lv lw lx ly lz jb ma mb mc jf md me mf jj mg mh mi mj bi translated">所以让我们开始行动吧</h2><p id="74d7" class="pw-post-body-paragraph iq ir hi is b it mk iv iw ix ml iz ja jb nr jd je jf ns jh ji jj nt jl jm jn hb bi translated">为操作创建一个目录:</p><pre class="kl km kn ko fd ol om on oo aw op bi"><span id="c882" class="lp lq hi om b fi oq or l os ot">src/redux/actions/</span></pre><p id="f061" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在该文件夹中创建一个新的<code class="du ou ov ow om b">index.js</code>文件</p><p id="20a7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在该文件中:</p><pre class="kl km kn ko fd ol om on oo aw op bi"><span id="b036" class="lp lq hi om b fi oq or l os ot">// src/redux/actions/index.js</span><span id="0186" class="lp lq hi om b fi ox or l os ot">export const addShow = show =&gt; ({ type: “ADD_SHOW”, payload: show });</span></pre><p id="b3ef" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">每个<strong class="is jo">动作都需要一个类型属性</strong>来描述状态应该如何变化(它实际上只是一个字符串)。缩减器将使用该字符串来确定如何计算下一个状态。如果你愿意，你可以像我一样指定一个有效载荷。</p><p id="86dc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">回到图中，因为<code class="du ou ov ow om b">types</code>只是字符串，字符串容易出现拼写错误和重复，最好将动作类型声明为常量。</p><figure class="kl km kn ko fd ij er es paragraph-image"><div class="er es ph"><img src="../Images/52906b2df13d7518682caf97114915cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1384/format:webp/1*N1pTYJUamnC22-RThFwncw.png"/></div></figure><blockquote class="la"><p id="3aa1" class="lb lc hi hj ld le pc pd pe pf pg jn dx translated"><strong class="ak">动作类型</strong></p></blockquote><p id="4b8f" class="pw-post-body-paragraph iq ir hi is b it lk iv iw ix ll iz ja jb lm jd je jf ln jh ji jj lo jl jm jn hb bi translated">最佳实践是将每一个动作包装在函数<strong class="is jo"> </strong>中，这无疑有助于避免难以调试的错误。</p><p id="66d8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以让我们也构建一个简单的动作创建器。</p><p id="f690" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在redux中为常量创建一个目录:</p><pre class="kl km kn ko fd ol om on oo aw op bi"><span id="7b42" class="lp lq hi om b fi oq or l os ot">src/redux/constants/</span></pre><p id="776c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在该文件夹中创建一个新的<code class="du ou ov ow om b">action-types.js</code>文件。</p><p id="4e56" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在该文件中:</p><pre class="kl km kn ko fd ol om on oo aw op bi"><span id="8b16" class="lp lq hi om b fi oq or l os ot">// src/redux/constants/action-types.js</span><span id="9065" class="lp lq hi om b fi ox or l os ot">export const ADD_SHOW = “ADD_SHOW”;</span></pre><p id="9d6e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后打开<code class="du ou ov ow om b">src/redux/actions/index.js</code>并更新动作以使用动作类型:</p><pre class="kl km kn ko fd ol om on oo aw op bi"><span id="b5c1" class="lp lq hi om b fi oq or l os ot">// src/redux/actions/index.js</span><span id="6b7f" class="lp lq hi om b fi ox or l os ot">import { ADD_SHOW } from “../constants/action-types”;</span><span id="e0f3" class="lp lq hi om b fi ox or l os ot">export const addShow = show =&gt; ({ type: ADD_SHOW, payload: show });</span></pre><h2 id="628e" class="lp lq hi bd lr ls lt lu lv lw lx ly lz jb ma mb mc jf md me mf jj mg mh mi mj bi translated">等等，让我登记一下。读者们，你们还和我在一起吗？？</h2><figure class="kl km kn ko fd ij"><div class="bz dy l di"><div class="pj mq l"/></div></figure><p id="8f21" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">没有吗？好吧，在继续之前，如果我回顾一下主要的Redux概念和刚刚发生的一切，可能会有所帮助:</p><ul class=""><li id="dfeb" class="jp jq hi is b it iu ix iy jb jr jf js jj jt jn ju jv jw jx bi translated">Redux商店负责协调所有移动部件</li><li id="e6c5" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">所有的状态都作为一个单一的、不变的对象存在</li><li id="fd52" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">只要商店收到一个动作，它就会触发一个缩减器</li><li id="9d4a" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">减速器返回下一个状态</li></ul><h1 id="c817" class="mr lq hi bd lr ms mt mu lv mv mw mx lz my mz na mc nb nc nd mf ne nf ng mi nh bi translated">顺序大概是这样的:</h1><figure class="kl km kn ko fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es pk"><img src="../Images/65dfb0e803f0228c3035e7fe5e50c777.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WDvSOFIRLxJvBEydgdJsLA.png"/></div></div></figure><ol class=""><li id="3bda" class="jp jq hi is b it iu ix iy jb jr jf js jj jt jn pl jv jw jx bi translated">一个动作首先发生在一个组件中，比如有人试图添加一个节目、过滤视图、查看组件的细节、甚至删除一个组件等等。</li><li id="f711" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn pl jv jw jx bi translated">然后调用动作和动作类型</li><li id="718a" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn pl jv jw jx bi translated">然后获取将更新或修改状态的特定缩减器</li><li id="9e57" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn pl jv jw jx bi translated">一旦状态改变，视图就会被重新呈现</li></ol><blockquote class="la"><p id="5d6b" class="lb lc hi hj ld le pc pd pe pf pg jn dx translated">嘣！现在你知道了！Redux就是这么工作的！</p></blockquote><p id="dbc2" class="pw-post-body-paragraph iq ir hi is b it lk iv iw ix ll iz ja jb lm jd je jf ln jh ji jj lo jl jm jn hb bi translated">恭喜你。你现在知道了<em class="kg">关于如何将Redux添加到一个简单的应用程序中的一切</em>，并且应该准备好将其扩展到你自己的应用程序中。<br/>除此之外，<em class="kg">等等</em>，你可能已经注意到，当我刚刚开始搭建Redux架构的时候，我不得不创建一堆<strong class="is jo">额外的文件夹和文件。</strong></p><p id="aa51" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在<strong class="is jo">想象一下添加传统应用</strong>的所有功能。如果我继续沿着这条路走下去，很容易想象事情会变得多么混乱和/或令人困惑。</p><p id="0d65" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您必须在一个文件中编辑常量，然后在另一个文件中编辑reducer，然后在另一个文件中编辑动作，最后在另一个文件中编辑动作创建者。</p><blockquote class="la"><p id="4056" class="lb lc hi hj ld le lf lg lh li lj jn dx translated">这就像一场没人愿意看的无聊的网球比赛！</p></blockquote><p id="780c" class="pw-post-body-paragraph iq ir hi is b it lk iv iw ix ll iz ja jb lm jd je jf ln jh ji jj lo jl jm jn hb bi translated">这意味着，即使只是添加一个小功能，也可能等同于编辑和添加几个不同的文件！这是一个令人头疼的问题。</p><figure class="kl km kn ko fd ij"><div class="bz dy l di"><div class="pm mq l"/></div><figcaption class="kp kq et er es kr ks bd b be z dx">Me bouncing back and forth between all of the different folders and files!</figcaption></figure><p id="26de" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这种组织Redux的方式是最常见的，也是最基本的。</p><p id="f288" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是正如刚才演示的那样，您最终会在文件之间来回跳转以获得一个相关的功能，因为常量、动作和动作创建者被导入到reducer文件中，而动作创建者也被导入到容器中进行调度。所有这些都变得有点烦人，你同意吗？</p><figure class="kl km kn ko fd ij er es paragraph-image"><div class="er es pn"><img src="../Images/77963d6148c3b794672c19c02d4e7fd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:852/format:webp/1*09iYxYBxl5niQnOr-Mx3Hg.png"/></div></figure><p id="63b1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我发现真正疯狂的是，实际上没有一种规定的方式来组织你的Redux文件。这种<code class="du ou ov ow om b">By Type</code>方法非常普遍，在很多教程中都有教授，但是很明显，它有点缺陷。</p><p id="905d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我的理论是，当你学习Redux以及动作和Redux的角色时，你通常会从非常简单的例子开始。大多数教程都不会带你进入下一个阶段。但是如果你正在用Redux构建比待办事项列表更复杂的东西，你会很快意识到，随着时间的推移，你可能需要一种更智能的方式来扩展你的代码库。</p><p id="6772" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这些动作、常量和缩减器都是相关的，但处于不连续状态，老实说，从一个文件切换到下一个文件不仅需要几秒钟，而且会让你的头脑有点模糊，我觉得这真的降低了我的生产效率。</p><blockquote class="kd ke kf"><p id="f889" class="iq ir kg is b it iu iv iw ix iy iz ja kh jc jd je ki jg jh ji kj jk jl jm jn hb bi translated">简单来说就是很难维持！🙅🏼</p></blockquote><p id="3948" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以很明显，当我第一次学习React并以这种方式心不在焉地建立一个应用程序的架构时，我对此感到沮丧。</p><p id="4192" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我所有的英语老师组织习惯都在我脑海中闪现。我知道有一种方法可以对代码库架构的组织进行战略性和深思熟虑。</p><figure class="kl km kn ko fd ij"><div class="bz dy l di"><div class="po mq l"/></div></figure><p id="22e8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我一头扎进研究和媒体的文章中，知道一定有什么东西会给我一些启发。我是对的，有很多关于它的想法。</p><p id="37d2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一些人在网上建议，解决这一问题的方法可能是<strong class="is jo">按照特性组织你的代码。</strong>如在:</p><ul class=""><li id="c482" class="jp jq hi is b it iu ix iy jb jr jf js jj jt jn ju jv jw jx bi translated">封装组件(容器)</li><li id="851c" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">其状态(商店)</li><li id="e3a1" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">和它的行为(动作)放在一个文件夹中</li></ul><p id="fd54" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="kg">全部遵循React的组件概念。</em></p><p id="164a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是这意味着您必须<strong class="is jo">将Redux存储的一部分绑定到一个容器</strong>上，这与Redux推广的核心内容完全违背直觉！</p><blockquote class="la"><p id="1b94" class="lb lc hi hj ld le lf lg lh li lj jn dx translated">所以我不会向你们提倡这种模式。</p></blockquote><p id="07ae" class="pw-post-body-paragraph iq ir hi is b it lk iv iw ix ll iz ja jb lm jd je jf ln jh ji jj lo jl jm jn hb bi translated">所以我回到绘图板，进一步的研究让我最终发现…</p><h1 id="c2da" class="mr lq hi bd lr ms mt mu lv mv mw mx lz my mz na mc nb nc nd mf ne nf ng mi nh bi translated">你们期待已久的时刻到了，根据本文的标题，<em class="pi">鸭子来了！</em></h1><figure class="kl km kn ko fd ij"><div class="bz dy l di"><div class="pp mq l"/></div></figure><blockquote class="la"><p id="43a3" class="lb lc hi hj ld le pc pd pe pf pg jn dx translated">但是鸭子是什么呢？</p></blockquote><p id="e8f1" class="pw-post-body-paragraph iq ir hi is b it lk iv iw ix ll iz ja jb lm jd je jf ln jh ji jj lo jl jm jn hb bi translated">创造了术语的Erik Rasmussen意识到他经常一次创建和编辑一个功能。</p><p id="b465" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">他一直需要为每个用例添加<code class="du ou ov ow om b">{actionTypes, actions, reducer}</code>元组。正如我一样，他将这些保存在单独的文件和文件夹中，然而，95%的时间里，只有一个<code class="du ou ov ow om b">reducer/action</code>对需要它们的相关动作。</p><p id="bd81" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，将这些部分捆绑在一个独立的模块中更有意义，这个模块是自包含的，甚至可以很容易地打包到一个库中。</p><blockquote class="kd ke kf"><p id="1a02" class="iq ir kg is b it iu iv iw ix iy iz ja kh jc jd je ki jg jh ji kj jk jl jm jn hb bi translated">Ducks本质上是一个将reducers、动作类型和动作捆绑到同一个文件中的提议。</p></blockquote><p id="ccd0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是<strong class="is jo">为什么</strong>这个组织结构会是这个架构问题的解决方案呢？</p><h2 id="08a6" class="lp lq hi bd lr ls lt lu lv lw lx ly lz jb ma mb mc jf md me mf jj mg mh mi mj bi translated">或者说，为什么要对鸭子感到兴奋？</h2><p id="ad04" class="pw-post-body-paragraph iq ir hi is b it mk iv iw ix ml iz ja jb nr jd je jf ns jh ji jj nt jl jm jn hb bi translated">除了他们的可爱因素😉</p><figure class="kl km kn ko fd ij"><div class="bz dy l di"><div class="pq mq l"/></div></figure><p id="4e82" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">嗯，Ducks试图解决按类型组织的反复性问题。对于Ducks，我可以将其打包成redux模块，而不是拆分所有相关代码！</p><h2 id="736c" class="lp lq hi bd lr ls lt lu lv lw lx ly lz jb ma mb mc jf md me mf jj mg mh mi mj bi translated">因此，让我们重构您刚刚创建的React应用程序，并将我们的Redux转换为DUCKS。</h2><p id="dd48" class="pw-post-body-paragraph iq ir hi is b it mk iv iw ix ml iz ja jb nr jd je jf ns jh ji jj nt jl jm jn hb bi translated">记住，前面的例子创建了添加一个节目的功能，现在您需要将<code class="du ou ov ow om b">actionTypes, actions,</code>和<code class="du ou ov ow om b">reducers</code>全部移动到一个文件中！</p><h1 id="5389" class="mr lq hi bd lr ms mt mu lv mv mw mx lz my mz na mc nb nc nd mf ne nf ng mi nh bi translated">如何将你的REDUX转换成鸭子</h1><ol class=""><li id="688d" class="jp jq hi is b it mk ix ml jb mm jf mn jj mo jn pl jv jw jx bi translated">在redux中为鸭子创建一个目录:</li></ol><pre class="kl km kn ko fd ol om on oo aw op bi"><span id="7cdb" class="lp lq hi om b fi oq or l os ot">src/redux/ducks/</span></pre><p id="76ee" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">2.在该文件夹中创建一个新的<code class="du ou ov ow om b">index.js</code>文件:</p><p id="754f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">3.从<code class="du ou ov ow om b">constants</code>文件夹中抓取<code class="du ou ov ow om b">actionTypes</code>并放入新的<code class="du ou ov ow om b">ducks</code>文件中:</p><pre class="kl km kn ko fd ol om on oo aw op bi"><span id="fb97" class="lp lq hi om b fi oq or l os ot">// src/redux/ducks/index.js</span><span id="78ce" class="lp lq hi om b fi ox or l os ot">export const actionTypes = {<br/>  addShow: {<br/>    ADD_SHOW = “ADD_SHOW”<br/>  }<br/>};</span></pre><p id="6753" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">4.开始删除并删除整个<code class="du ou ov ow om b">constants</code>文件夹！</p><p id="0aa1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">5.接下来是<code class="du ou ov ow om b">actions</code>文件。抓住行动:</p><pre class="kl km kn ko fd ol om on oo aw op bi"><span id="c72e" class="lp lq hi om b fi oq or l os ot">// src/redux/actions/index.js</span><span id="2cfb" class="lp lq hi om b fi ox or l os ot">addShow = show =&gt; ({ type: “ADD_SHOW”, payload: show });</span></pre><p id="53af" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">6.并将其放入<code class="du ou ov ow om b">ducks</code>文件中:</p><pre class="kl km kn ko fd ol om on oo aw op bi"><span id="faf8" class="lp lq hi om b fi oq or l os ot">// src/redux/ducks/index.js</span><span id="78ca" class="lp lq hi om b fi ox or l os ot">...</span><span id="a578" class="lp lq hi om b fi ox or l os ot">export const actions = {<br/>   addShow = show =&gt; ({type: ADD_SHOW, payload: show});<br/>};</span></pre><p id="69c2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">7.继续乐趣，删除整个<code class="du ou ov ow om b">actions</code>文件夹！</p><p id="fb9e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">8.最后，解决<code class="du ou ov ow om b">reducers</code>。</p><p id="b723" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">9.首先抓住这个减速器:</p><pre class="kl km kn ko fd ol om on oo aw op bi"><span id="4a71" class="lp lq hi om b fi oq or l os ot">// src/redux/reducers/index.js</span><span id="19f9" class="lp lq hi om b fi ox or l os ot">const initialState = {<br/>  shows: []<br/>};</span></pre><p id="c6a7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">10.实际上，让我们改变一下<code class="du ou ov ow om b">reducer</code>，因为第一个例子中的T5除了返回初始状态之外什么也不做，这很容易通过将它变成一个switch语句来解决。</p><p id="d5f3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">11.在<code class="du ou ov ow om b">ducks</code>文件中添加:</p><pre class="kl km kn ko fd ol om on oo aw op bi"><span id="3779" class="lp lq hi om b fi oq or l os ot">// src/redux/ducks/index.js</span><span id="a13c" class="lp lq hi om b fi ox or l os ot">...</span><span id="2083" class="lp lq hi om b fi ox or l os ot">export const rootReducer = (state = initialState, action) =&gt; {<br/>  switch (action.type) {<br/>    case ADD_SHOW:<br/>    return { …state, shows: […state.shows, action.payload] };<br/>    default:<br/>    return state;<br/>  }<br/>}<strong class="om jo">;</strong></span></pre><p id="3cae" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">12.当然，不要忘记删除<code class="du ou ov ow om b">reducer</code>文件夹！</p><h1 id="d7d3" class="mr lq hi bd lr ms mt mu lv mv mw mx lz my mz na mc nb nc nd mf ne nf ng mi nh bi translated">13.哒哒！您刚刚创建了一个模块化的Ducks文件！</h1><figure class="kl km kn ko fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es pr"><img src="../Images/0fd97385e9ce47333550fc749dcf400b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rg3hVhOnazPu6_l7igO0qQ.png"/></div></div><figcaption class="kp kq et er es kr ks bd b be z dx">Your Ducks file should look a little something like this!</figcaption></figure><p id="3f60" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个文件现在正式包含了在之前构建的所有功能。它以完全相同的方式运行，但现在，它被<strong class="is jo">模块化为一个干净、易于理解的文件，<em class="kg">或鸭</em> </strong> <em class="kg">，</em>用于优化状态管理。</p><h2 id="1e20" class="lp lq hi bd lr ls lt lu lv lw lx ly lz jb ma mb mc jf md me mf jj mg mh mi mj bi translated">为了真正把东西带回家，还记得当你创建所有这些文件夹和所有这些文件时，你把它们彼此分开并分成碎片吗？</h2><figure class="kl km kn ko fd ij er es paragraph-image"><div class="er es ps"><img src="../Images/72872e30ad3e55ba9458b24ca5dc57eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1032/format:webp/1*sRkEaK0h0S2e6UZYppfKNQ.png"/></div></figure><p id="e43e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">好吧，比较一下这个新文件，它以清晰的方式包含了所有相同的功能，我称之为胜利！</p><blockquote class="la"><p id="74b8" class="lb lc hi hj ld le lf lg lh li lj jn dx translated">另外，创建它非常容易，而且没有痛苦。</p></blockquote><p id="9316" class="pw-post-body-paragraph iq ir hi is b it lk iv iw ix ll iz ja jb lm jd je jf ln jh ji jj lo jl jm jn hb bi translated">因此，鸭子的艺术是一种构建应用程序变得更加模块化的方式，<em class="kg">是的，这是软件工程世界中一个真正性感的时髦词</em>，但这真的很棒，因为现在已经变得非常明显，哪个Redux处理哪个功能。</p><p id="24ae" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在完全实用的层面上，你不再需要在找到你需要处理的文件之前滚动大量的文件。</p><h1 id="443c" class="mr lq hi bd lr ms mt mu lv mv mw mx lz my mz na mc nb nc nd mf ne nf ng mi nh bi translated">但这只是<strong class="ak"> <em class="pi">构建redux的一种方式</em> </strong>。还有很多其他选择。</h1><p id="9ba5" class="pw-post-body-paragraph iq ir hi is b it mk iv iw ix ml iz ja jb nr jd je jf ns jh ji jj nt jl jm jn hb bi translated">事实上，我鼓励读者探索创造性地定义什么可能最适合你的方法，这可能意味着我曾经是一个痴迷于结构的人，现在正在成为一个接受模糊性的人，并且发现有时你可以定义自己的规则，做任何对你的代码和团队最有利的事情，最终都是正确的选择！</p><h2 id="6ea3" class="lp lq hi bd lr ls lt lu lv lw lx ly lz jb ma mb mc jf md me mf jj mg mh mi mj bi translated">我最喜欢鸭子的是它的干净和清澈。</h2><p id="cb08" class="pw-post-body-paragraph iq ir hi is b it mk iv iw ix ml iz ja jb nr jd je jf ns jh ji jj nt jl jm jn hb bi translated">它删除了许多不必要的样板文件，你可以通过改变一个文件轻松地添加一个简单的动作，甚至是一个应用程序的全部功能。</p><p id="86fe" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我所在的团队采用了这种结构，我们对此非常满意。</p><blockquote class="kd ke kf"><p id="cf3c" class="iq ir kg is b it iu iv iw ix iy iz ja kh jc jd je ki jg jh ji kj jk jl jm jn hb bi translated">也许你也会？！</p></blockquote><figure class="kl km kn ko fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es pt"><img src="../Images/c2121555f2243969cebffeb5a410cb33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l9-p862QALXZEawcfypZcQ.png"/></div></div><figcaption class="kp kq et er es kr ks bd b be z dx">Presenting at CascadiaJS 2018</figcaption></figure><blockquote class="la"><p id="5b2d" class="lb lc hi hj ld le pc pd pe pf pg jn dx translated">试一试，让我知道你的想法。</p></blockquote><p id="c234" class="pw-post-body-paragraph iq ir hi is b it lk iv iw ix ll iz ja jb lm jd je jf ln jh ji jj lo jl jm jn hb bi translated">在Twitter- <strong class="is jo"> @LoLoCoding </strong>上联系我，告诉我所有关于你自己的quacky架构解决方案！</p><p id="97a9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">请务必查看<a class="ae kt" href="https://github.com/erikras/ducks-modular-redux" rel="noopener ugc nofollow" target="_blank">拉斯姆森的</a>原始提案，了解更多信息！</p><p id="01cc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">此外，如果你是一名视觉/听觉学习者，这里有一个我在2018年的 <a class="ae kt" href="https://2018.cascadiajs.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="is jo">卡斯卡迪亚斯</strong> </a> <strong class="is jo">展示这些信息的<a class="ae kt" href="https://www.youtube.com/watch?v=jr7D4VAzNig&amp;t=3s" rel="noopener ugc nofollow" target="_blank">视频</a>。</strong></p><figure class="kl km kn ko fd ij"><div class="bz dy l di"><div class="pu mq l"/></div></figure><figure class="kl km kn ko fd ij er es paragraph-image"><a href="https://medium.com/swlh"><div class="er es pv"><img src="../Images/308a8d84fb9b2fab43d66c117fcc4bb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YqDjlKFwScoQYQ62DWEdig.png"/></div></a></figure><h2 id="c148" class="lp lq hi bd lr ls lt lu lv lw lx ly lz jb ma mb mc jf md me mf jj mg mh mi mj bi translated">这篇文章发表在<a class="ae kt" href="https://medium.com/swlh" rel="noopener"> The Startup </a>上，这是Medium最大的创业刊物，拥有+413，678名读者。</h2><h2 id="869c" class="lp lq hi bd lr ls lt lu lv lw lx ly lz jb ma mb mc jf md me mf jj mg mh mi mj bi translated">在这里订阅接收<a class="ae kt" href="http://growthsupply.com/the-startup-newsletter/" rel="noopener ugc nofollow" target="_blank">我们的头条新闻</a>。</h2><figure class="kl km kn ko fd ij er es paragraph-image"><a href="https://medium.com/swlh"><div class="er es pv"><img src="../Images/b0164736ea17a63403e660de5dedf91a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ouK9XR4xuNWtCes-TIUNAw.png"/></div></a></figure></div></div>    
</body>
</html>