<html>
<head>
<title>Looking for the right Impulse</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">寻找合适的冲动</h1>
<blockquote>原文：<a href="https://medium.com/swlh/looking-for-the-right-impulse-7a8d28b74afb#2019-06-10">https://medium.com/swlh/looking-for-the-right-impulse-7a8d28b74afb#2019-06-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/0c149cfab2f05ac7c19e356e31f0cec5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xd9PslNemQpco79bpCaWsQ.jpeg"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">Photo by <a class="ae hv" href="https://unsplash.com/@austinchan?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Austin Chan</a> on <a class="ae hv" href="https://unsplash.com/search/photos/looking-for-the-right-impulse?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><div class=""/><div class=""><h2 id="556d" class="pw-subtitle-paragraph iv hx hy bd b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm dx translated">线性对于统计大量案例是多么有用。</h2></div><p id="7950" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">有时，我们感兴趣的是从一个更全面的角度对整个系统进行概述。这种观点产生了促使我们做这样或那样事情的一般印象。然而，这些冲动是在对整个环境进行第一次扫描以得出高度复杂的结论之后产生的。</p><p id="9c70" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">在这篇文章中，我将展示一种机制，它将帮助我们理解如何找到几十个相互关联的问题，以及如何处理它们。</p><p id="5c3a" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">首先，这是一个脉冲<em class="kj">X(t)=δ(t)</em>；这意味着:如果<em class="kj"> t </em>等于0，返回1，否则返回0。</p><figure class="kl km kn ko fd hk er es paragraph-image"><div class="er es kk"><img src="../Images/a7914315a2bd2b3d9c62dc7bdef06c44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/1*HeAfFRR-5u9DL0YwgWtwlA.jpeg"/></div></figure><p id="906f" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">我们特别感兴趣的不是处理一个有条件的函数，而是处理一个我们可以<strong class="jp kp">相加</strong>和<strong class="jp kp">相乘</strong>的结构。出于这个原因，我们将把它表示为余弦和，如本书所述[1]:</p><figure class="kl km kn ko fd hk er es paragraph-image"><div class="er es kq"><img src="../Images/78c94347a1373c614e2c9360e0801a48.png" data-original-src="https://miro.medium.com/v2/resize:fit:360/format:webp/1*v15ZE_qAgckQSMm8yOUAVg.jpeg"/></div><figcaption class="hr hs et er es ht hu bd b be z dx">Impulse in a period T</figcaption></figure><p id="423c" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">这意味着我们不能在孤立的冲动下工作…</p><figure class="kl km kn ko fd hk er es paragraph-image"><div class="er es kk"><img src="../Images/a3c796b050411a5a88c14d5918c60a8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/1*JHrSgem2NdWC920pJxgsQg.jpeg"/></div><figcaption class="hr hs et er es ht hu bd b be z dx">A repeated Impulse every 15 minutes</figcaption></figure><p id="6a84" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">我们也不使用可导函数来构建峰值。</p><figure class="kl km kn ko fd hk er es paragraph-image"><div class="er es kr"><img src="../Images/23d95f62290b68cfb264d2dbbede2c5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:592/format:webp/1*jG9EuG1L2niF0-EEMrco_g.jpeg"/></div><figcaption class="hr hs et er es ht hu bd b be z dx">After 4 (yellow), 8 (orange) and 16 (red) summands</figcaption></figure><p id="7e22" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">所以，很容易构造你自己的脉冲函数，</p><pre class="kl km kn ko fd ks kt ku kv aw kw bi"><span id="9a9c" class="kx ky hy kt b fi kz la l lb lc">from math import pi, cos, sin<br/>class Impulse:<br/>    def __init__(self, period, U=0, m=80):<br/>        self.m = m<br/>        self.period = period<br/>        self.sc = {}<br/>        self.ss = {}<br/>        self.sc[0] = -U<br/>        for k in range(1,m):<br/>            self.sc[k] = 1 / (m-1) / (1-U)<br/>            <br/>    def __call__(self, item):<br/>        S = 0.0<br/>        for i in self.sc.keys():<br/>            S += self.sc[i] * cos(i * item * 2*pi  / self.period)<br/>        for i in self.ss.keys():<br/>            S += self.ss[i] * sin(i * item *2*pi / self.period)<br/>        return S</span></pre><p id="cb12" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">我们可以用我添加的新参数玩一玩:</p><pre class="kl km kn ko fd ks kt ku kv aw kw bi"><span id="1717" class="kx ky hy kt b fi kz la l lb lc">&gt;&gt;&gt; X0 = Impulse(20)<br/>&gt;&gt;&gt; X0(0)<br/>0.9999999999999987<br/>&gt;&gt;&gt; X0(1)<br/>-0.012658227848101278<br/>&gt;&gt;&gt; X1 = Impulse(20, U = X0(1))<br/>&gt;&gt;&gt; X1(0)<br/>1.0001582278480998<br/>&gt;&gt;&gt; X1(1)<br/>0.00015822784810127707<br/>&gt;&gt;&gt; [round(X0(t), 2) for t in range(21)]<br/>[1.0, -0.01, -0.01, -0.01, -0.01, -0.01, -0.01, -0.01, -0.01, -0.01, -0.01, -0.01, -0.01, -0.01, -0.01, -0.01, -0.01, -0.01, -0.01, -0.01, 1.0]<br/>&gt;&gt;&gt; [round(X1(t), 2) for t in range(21)]<br/>[1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0]</span></pre><p id="ad4f" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">因此，这意味着我们总是可以根据我们的需要，加入一些有助于改进公式的小改进。</p><h2 id="a91d" class="kx ky hy bd ld le lf lg lh li lj lk ll jw lm ln lo ka lp lq lr ke ls lt lu lv bi translated">合并线性运算</h2><p id="c80a" class="pw-post-body-paragraph jn jo hy jp b jq lw iz js jt lx jc jv jw ly jy jz ka lz kc kd ke ma kg kh ki hb bi translated">真正有趣的是，我们可以将信号乘以一个标度，移动它并添加另一个信号。这里有一个提议:</p><pre class="kl km kn ko fd ks kt ku kv aw kw bi"><span id="c168" class="kx ky hy kt b fi kz la l lb lc">def clone(self):<br/>        result = Impulse(self.period,  m=1)<br/>        result.m = self.m<br/>        result.ss = self.ss.copy()<br/>        result.sc = self.sc.copy()<br/>        return result</span><span id="8698" class="kx ky hy kt b fi mb la l lb lc">def scale(self, value):<br/>        for k in self.ss.keys():<br/>            self.ss[k] *= value<br/>        for k in self.sc.keys():<br/>            self.sc[k] *= value</span><span id="a511" class="kx ky hy kt b fi mb la l lb lc">def shift(self, x=0, y=0):<br/>        factor = 2*pi/self.period<br/>        if not 0 in self.sc.keys():<br/>            self.sc[0] = y<br/>        else:<br/>            self.sc[0] += y<br/>        for k in self.sc.keys() :<br/>            b = self.sc[k]<br/>            a = self.ss[k] if k in self.ss.keys() else 0<br/>            self.ss[k] = a * cos(-k*x*factor) - b * sin(-k*x*factor)<br/>            self.sc[k] = a * sin(-k*x*factor) + b * cos(-k*x*factor)<br/>        for k in self.ss.keys():<br/>            if k in self.sc.keys():<br/>                continue<br/>            self.ss[k] *= cos(-k*x*factor)<br/>            self.sc[k] = self.ss[k] * sin(-k*x*factor)</span><span id="8f49" class="kx ky hy kt b fi mb la l lb lc">def __add__(self, other):<br/>        result=self.clone()<br/>        result.period = self.period<br/>        for k in other.ss.keys():<br/>            if not k in result.ss.keys():<br/>                result.ss[k] = 0<br/>            result.ss[k] += other.ss[k]<br/>        for k in other.sc.keys():<br/>            if not k in result.sc.keys():<br/>                result.sc[k]=0<br/>            result.sc[k] += other.sc[k]<br/>        return result</span></pre><p id="e17e" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">所以现在我们可以这样测试它:</p><pre class="kl km kn ko fd ks kt ku kv aw kw bi"><span id="3a52" class="kx ky hy kt b fi kz la l lb lc">&gt;&gt;&gt; X = Impulse(20)<br/>&gt;&gt;&gt; Y = X.clone()<br/>&gt;&gt;&gt; [round(X(t), 2) for t in range(21)]<br/>[1.0, -0.01, -0.01, -0.01, -0.01, -0.01, -0.01, -0.01, -0.01, -0.01, -0.01, -0.01, -0.01, -0.01, -0.01, -0.01, -0.01, -0.01, -0.01, -0.01, 1.0]<br/>&gt;&gt;&gt; [round(Y(t), 2) for t in range(21)]<br/>[1.0, -0.01, -0.01, -0.01, -0.01, -0.01, -0.01, -0.01, -0.01, -0.01, -0.01, -0.01, -0.01, -0.01, -0.01, -0.01, -0.01, -0.01, -0.01, -0.01, 1.0]<br/>&gt;&gt;&gt; X.scale(2)<br/>&gt;&gt;&gt; Y.shift(1, .01)<br/>&gt;&gt;&gt; [round(X(t), 2) for t in range(21)]<br/>[2.0, -0.03, -0.03, -0.03, -0.03, -0.03, -0.03, -0.03, -0.03, -0.03, -0.03, -0.03, -0.03, -0.03, -0.03, -0.03, -0.03, -0.03, -0.03, -0.03, 2.0]<br/>&gt;&gt;&gt; [round(Y(t), 2) for t in range(21)]<br/>[-0.0, 1.01, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0]</span></pre><p id="1586" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">此时，我们可能会注意到，我们相加的信号必须始终具有相同的周期，因为我们的求和函数不会计算两个周期的最大公约数，也有可能我们感兴趣的是表示方波信号，而不是参考文献中所示的脉冲信号…，但出于本文的目的，我们将留在这里。</p><h2 id="9f90" class="kx ky hy bd ld le lf lg lh li lj lk ll jw lm ln lo ka lp lq lr ke ls lt lu lv bi translated">寻找更多有趣的应用</h2><p id="dcb9" class="pw-post-body-paragraph jn jo hy jp b jq lw iz js jt lx jc jv jw ly jy jz ka lz kc kd ke ma kg kh ki hb bi translated">想象一下，我们想知道有多少种方法可以在一个集合中找到能够恰好相加一个量的数字子集。</p><p id="47dd" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">例如:在[1，1，3，4]中，我们可以达到#{[1，1，3]，[1，4]} = 2种情况，其中它们的集合的元素相加正好是5。</p><p id="a92b" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">在[3]中我们可以看到<strong class="jp kp">背包问题</strong>的定义:</p><figure class="kl km kn ko fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mc"><img src="../Images/f4857cf3602089c5ac23dce9bdd2538a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*btthFP_LmkQx6_oRzdmoGw.jpeg"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">Is there a subset which elemens sum an exact value?</figcaption></figure><p id="3494" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">所以我们看到，与计算结果不同的是，如果有一个案例，当我们考虑计算案例的数量时，它就会出现。当谈到建立差异时，有一个约定，它包括包含符号<strong class="jp kp"> # </strong>，并提到我们计算<em class="kj">锐</em>。</p><p id="a4b6" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">所以，#背包的意思是:<em class="kj">有多少个子集能够恰好相加一个量。</em></p><p id="3b0a" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">在[3]中，我们可以到达其他已知的问题，想象我们有一组数字，我们是否能够将它们分成两部分，其中对每一部分求和，结果是相同的？</p><p id="d61d" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">例如，让我们使用我们的类…</p><pre class="kl km kn ko fd ks kt ku kv aw kw bi"><span id="fd9e" class="kx ky hy kt b fi kz la l lb lc">def sharpPartition(*L):<br/>    X = Impulse(sum(L)+1, m=100)<br/>    for Z in L:<br/>       Y = X.clone()<br/>       Y.shift(Z)<br/>       X.shift(-Z)<br/>       X += Y<br/>    return round(X(0)/2)</span></pre><p id="7cb2" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">在上面的代码中，我们将得到的信号向左向右移动，最后相加。在t=0中，我们将找到分区数量的两倍，就像在#Partitions[1，2，3] = #{({1，2}，{3}，{1，2})}/2 = 1中一样</p><p id="d2bc" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">所以，</p><pre class="kl km kn ko fd ks kt ku kv aw kw bi"><span id="4964" class="kx ky hy kt b fi kz la l lb lc">&gt;&gt;&gt; sharpPartition(1,2,3)<br/>1<br/>&gt;&gt;&gt; sharpPartition(1, 2, 3, 5)<br/>0</span></pre><p id="895a" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">#分区和#背包有什么联系吗？在[3]中我们可以得出这样的关系:</p><figure class="kl km kn ko fd hk er es paragraph-image"><div class="er es md"><img src="../Images/d2c19f7f83c95162bbe023ac342ecbcf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/format:webp/1*sHupEeWA21maXDucnTfwdg.jpeg"/></div><figcaption class="hr hs et er es ht hu bd b be z dx">Implementing Partition we will have constructively the implementation of Knapsack</figcaption></figure><p id="2def" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">所以我们只需要用同样的符号定义分区:</p><figure class="kl km kn ko fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es me"><img src="../Images/9efb70342cef90d8f5875155582f228a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D7xyIYcLnH7ZjHw2xzNmPQ.jpeg"/></div></div></figure><p id="9076" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">所以代码可能是:</p><pre class="kl km kn ko fd ks kt ku kv aw kw bi"><span id="7f60" class="kx ky hy kt b fi kz la l lb lc">def sharpKnapsack(value, *L):<br/>    L2 = list(L[:])<br/>    L2.append(value +1)<br/>    L2.append(sum(L) + 1 - value)<br/>    return sharpPartition(*L2)</span></pre><p id="4883" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">所以我们可以做一些简单的测试…</p><pre class="kl km kn ko fd ks kt ku kv aw kw bi"><span id="589e" class="kx ky hy kt b fi kz la l lb lc">&gt;&gt;&gt; sharpKnapsack(5, 2, 3)<br/>1<br/>&gt;&gt;&gt; sharpKnapsack(3, 2, 3, 1)<br/>2</span></pre><p id="c638" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">除了[3]中暴露的问题，您还可以在[2]中找到更多的等价问题…</p><h2 id="a8f7" class="kx ky hy bd ld le lf lg lh li lj lk ll jw lm ln lo ka lp lq lr ke ls lt lu lv bi translated">如果一切都那么美好…</h2><p id="0973" class="pw-post-body-paragraph jn jo hy jp b jq lw iz js jt lx jc jv jw ly jy jz ka lz kc kd ke ma kg kh ki hb bi translated">正如我在下一篇文章中解释的那样，</p><div class="hh hi ez fb hj mf"><a rel="noopener follow" target="_blank" href="/datadriveninvestor/hard-life-for-a-rebellious-mind-2ea7693ebfe0"><div class="mg ab dw"><div class="mh ab mi cl cj mj"><h2 class="hz b fi z dy mk ea eb ml ed ef hx bi translated">叛逆思想的艰难生活</h2><div class="mm l"><h3 class="bd b fi z dy mk ea eb ml ed ef dx translated">最高效的机器被鄙视。</h3></div><div class="mn l"><p class="bd b fp z dy mk ea eb ml ed ef dx translated">medium.com</p></div></div><div class="mo l"><div class="mp l mq mr ms mo mt hp mf"/></div></div></a></div><p id="6f1e" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">闪光的不都是金子。这就是为什么我们的模型既有好消息也有坏消息。从我自己的符号来看，我们可以像一个手册一样构造指令来解决[2]中的大多数#NP问题，但是我们必须考虑这些事情仅仅是使用本文方法的近似值。</p><p id="2091" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">有一种可能性是，我们可能需要以更精确的方式来表示冲量，以便计数结果会更精确。</p><p id="5109" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">设置固定数量的被加数的优点是它不依赖于输入的大小，但是它依赖于它们使用的值的范围。</p><p id="1e74" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">所以，让我们来研究一下这段代码:</p><pre class="kl km kn ko fd ks kt ku kv aw kw bi"><span id="b888" class="kx ky hy kt b fi kz la l lb lc">def sharpSumZero(summands, *E):<br/>    I = Impulse(2*max(E)*len(E), U = 0, m = summands)<br/>    for X in E:<br/>        I2 = I.clone()<br/>        I2.shift(x = X)<br/>        I += I2  <br/>        I.shift(y = -I(0.5))  #S1<br/>        if round(I(0),0) &gt; 0:<br/>            I.scale(round(I(0), 0) / I(0)) #S2. <br/>        else:<br/>            I.shift(y = 1 - I(0))<br/>    return int(round(I(0),0))</span></pre><p id="9926" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">在这种情况下，我们考虑计算有多少子集的总和正好为零。为此，我们管理了两个特殊区块#S1和#S2，以便更准确地得出结果。</p><p id="e20a" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">所以我们用这个词条来测试一下:<code class="du mu mv mw kt b">L = [1] + [-1]*40 </code>，它是a -1和40种加到零的方法。所以正确结果是41(考虑算空集)。</p><pre class="kl km kn ko fd ks kt ku kv aw kw bi"><span id="991e" class="kx ky hy kt b fi kz la l lb lc">&gt;&gt;&gt; sharpSumZero(800, *([-1]+([1]*40)))<br/>190<br/>&gt;&gt;&gt; sharpSumZero(1600, *([-1]+([1]*40)))<br/>41<br/>&gt;&gt;&gt; sharpSumZero(3200, *([-1]+([1]*40)))<br/>772850686</span></pre><p id="8914" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">正如你所看到的，它有一个完美的工作范围(像过拟合和欠拟合问题)。有必要考虑我们的库工作的误差容限，以及代表脉冲的傅立叶级数工作的误差容限。否则，结果是可以预料的。</p><h1 id="8671" class="mx ky hy bd ld my mz na lh nb nc nd ll je ne jf lo jh nf ji lr jk ng jl lu nh bi translated">参考</h1><p id="484e" class="pw-post-body-paragraph jn jo hy jp b jq lw iz js jt lx jc jv jw ly jy jz ka lz kc kd ke ma kg kh ki hb bi translated">[1] Oppenheim，A. Willsky，a .和Nawab，S. (2016)信号与系统。诺伊达:皮尔森，2016。</p><p id="501c" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">[2] Garey，M .和Johnson，D .(2009)计算机和棘手问题。纽约[美国]:弗里曼，2009年。</p><p id="c336" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">[3]卡普，R. M. (1972)可归约性阿蒙组合问题。米勒和撒切尔。)，计算机计算的复杂性，全会出版社，纽约，85-103。</p></div></div>    
</body>
</html>