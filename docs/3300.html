<html>
<head>
<title>Tips for Unit Testing Vue Components with Jest</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Jest对Vue组件进行单元测试的技巧</h1>
<blockquote>原文：<a href="https://medium.com/swlh/tips-on-unit-testing-vue-components-with-jest-e68ff6a28bb5?source=collection_archive---------0-----------------------#2019-05-19">https://medium.com/swlh/tips-on-unit-testing-vue-components-with-jest-e68ff6a28bb5?source=collection_archive---------0-----------------------#2019-05-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="f0dd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用Jest对Vue.js组件进行单元测试可能会很棘手。我们需要一个单独的<a class="ae jd" href="https://vue-test-utils.vuejs.org" rel="noopener ugc nofollow" target="_blank"> Vue Test Utils </a> <code class="du je jf jg jh b">(@vue/test-utils)</code>范围的包，以便虚拟地挂载我们的组件，并使用<a class="ae jd" href="https://jestjs.io/docs/en/api" rel="noopener ugc nofollow" target="_blank"> Jest </a>来执行测试。因为这两个库一起工作，所以确保我们不会混淆哪个API调用属于哪个库是很重要的。除了这些库，我们还需要注意Jest附带的<a class="ae jd" href="https://github.com/jsdom/jsdom" rel="noopener ugc nofollow" target="_blank"> JSDOM </a>(虚拟浏览器环境)特定方法。不得不处理所有这些可能会令人困惑，并且会阻碍我们编写单元测试。</p><figure class="jj jk jl jm fd jn er es paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="er es ji"><img src="../Images/5f9178cc74dc4baf7e6e9256ceec59e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*PTXpH1wEwDViGKBj24DqUA.gif"/></div></div><figcaption class="ju jv et er es jw jx bd b be z dx">May feel like a juggling jest(er), Credit: <a class="ae jd" href="https://dribbble.com/fedecook" rel="noopener ugc nofollow" target="_blank">https://dribbble.com/fedecook</a></figcaption></figure><p id="c5f3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，<code class="du je jf jg jh b">shallowMount()</code>是创建浅层<code class="du je jf jg jh b">wrapper</code>组件的Vue测试实用程序方法(使用浅层渲染来避免渲染子组件)，而<code class="du je jf jg jh b">beforeEach()</code>是在每次测试之前执行回调参数的Jest方法。我们在<code class="du je jf jg jh b">beforeEach()</code>内部运行<code class="du je jf jg jh b">shallowMount()</code>，因此在每次测试之前都会安装一个组件。</p><p id="9058" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我列出了我的团队用来成功地对我们的Vue组件进行单元测试的常用测试方法。希望这将有助于其他人经历类似的过程。</p></div><div class="ab cl jy jz gp ka" role="separator"><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd"/></div><div class="hb hc hd he hf"><h1 id="24cf" class="kf kg hi bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">初始设置</h1><figure class="jj jk jl jm fd jn er es paragraph-image"><div class="er es ld"><img src="../Images/8dade56360edb6c1342e92749f0e52b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*-kxmKy00NJ1CQXDOLChRFA.gif"/></div></figure><p id="67b2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们从建立Jest开始。将Jest npm包安装为<code class="du je jf jg jh b">devDependencies</code></p><pre class="jj jk jl jm fd le jh lf lg aw lh bi"><span id="3b56" class="li kg hi jh b fi lj lk l ll lm">$ npm i jest -D</span></pre><p id="9eca" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们安装Vue测试工具和其他依赖项，如<code class="du je jf jg jh b">babel-jest</code>、<code class="du je jf jg jh b">vue-jest</code>等。(这直接来自Vue测试工具文档)</p><pre class="jj jk jl jm fd le jh lf lg aw lh bi"><span id="095a" class="li kg hi jh b fi lj lk l ll lm">$ npm i @vue/test-utils vue-jest babel-jest -D</span></pre><p id="bb82" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦我们设置好所有的包，在我们项目的根文件夹中创建一个Jest配置文件<code class="du je jf jg jh b">jest.config.js</code>。作为替代，我们也可以将<code class="du je jf jg jh b">module.exports</code>中的JSON对象添加到<code class="du je jf jg jh b">jest: {}</code>到<code class="du je jf jg jh b">package.json</code>的属性中，这减少了我们必须管理的配置文件的数量。</p><figure class="jj jk jl jm fd jn"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="17f0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">确保<code class="du je jf jg jh b">.babelrc</code>文件具有安装了<code class="du je jf jg jh b">babel-preset-env</code>模块的以下配置。</p><figure class="jj jk jl jm fd jn"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="966b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦我们设置了选项配置(主要是<code class="du je jf jg jh b">collectCoverageFrom</code>源路径),我们就可以运行Jest了！</p><p id="5028" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们需要做的就是将<code class="du je jf jg jh b">scripts: { “test”: “jest” }</code>添加到package.json中，然后运行这个脚本。</p><pre class="jj jk jl jm fd le jh lf lg aw lh bi"><span id="773c" class="li kg hi jh b fi lj lk l ll lm">$ npm run test</span></pre></div><div class="ab cl jy jz gp ka" role="separator"><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd"/></div><div class="hb hc hd he hf"><h1 id="5490" class="kf kg hi bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">编写测试文件</h1><p id="628c" class="pw-post-body-paragraph if ig hi ih b ii lp ik il im lq io ip iq lr is it iu ls iw ix iy lt ja jb jc hb bi translated">在我们有Jest可以运行的测试文件之前，上面的脚本不是很有用，所以让我们添加一个。</p><p id="3162" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Jest将在我们的项目文件夹中拾取<code class="du je jf jg jh b">*.test.js</code>或<code class="du je jf jg jh b">*.spec.js</code>文件。我喜欢将测试文件放在与我的Vue组件相同的文件夹中，并使用组件文件名。例如<code class="du je jf jg jh b">button.vue</code>组件在<code class="du je jf jg jh b">components/</code>文件夹中会有<code class="du je jf jg jh b">button.test.js</code>测试文件。这有助于我管理组件文件和测试文件，因为它们位于同一个文件夹中，并且在<a class="ae jd" href="https://code.visualstudio.com/docs/getstarted/userinterface" rel="noopener ugc nofollow" target="_blank"> VSCode </a>的<code class="du je jf jg jh b">Explorer</code>中彼此相邻。</p><h2 id="0e45" class="li kg hi bd kh lu lv lw kl lx ly lz kp iq ma mb kt iu mc md kx iy me mf lb mg bi translated">测试文件模板</h2><p id="0244" class="pw-post-body-paragraph if ig hi ih b ii lp ik il im lq io ip iq lr is it iu ls iw ix iy lt ja jb jc hb bi translated">这是我用来开始的一个基本模板测试文件。注意<code class="du je jf jg jh b">shallowMount()</code>有像<code class="du je jf jg jh b">propsData, mocks, stubs, methods</code>一样的各种属性，我们可以设置我们挂载的组件来模仿或存根组件的各种属性。通常的做法是在每次测试之前调用<code class="du je jf jg jh b">shallowMount()</code>并将模拟组件存储在<code class="du je jf jg jh b">wrapper</code>中，并在每次测试之后销毁<code class="du je jf jg jh b">wrapper</code>。这样，我们每次测试都从一个新的状态开始，这使得测试更加可预测。</p><p id="d892" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Jest具有<code class="du je jf jg jh b">describe()</code>、<code class="du je jf jg jh b"> test()</code>和<code class="du je jf jg jh b">expect()</code>测试功能来设置每个测试和资产期望值。我喜欢在开始时检查<code class="du je jf jg jh b">wrapper.isVueInstance</code>测试通过，以确保我模拟了组件的默认属性。</p><figure class="jj jk jl jm fd jn"><div class="bz dy l di"><div class="ln lo l"/></div><figcaption class="ju jv et er es jw jx bd b be z dx">Sample Jest test template</figcaption></figure><p id="527a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们的组件使用Vuex，我们需要使用<code class="du je jf jg jh b">use() </code>将Vuex添加到一个Vue实例(这里命名为<code class="du je jf jg jh b">localVue</code>)中，并将该实例传递到<code class="du je jf jg jh b">shallowMount()</code>。</p><figure class="jj jk jl jm fd jn"><div class="bz dy l di"><div class="ln lo l"/></div><figcaption class="ju jv et er es jw jx bd b be z dx">Template with Vuex mocks</figcaption></figure><h2 id="90bc" class="li kg hi bd kh lu lv lw kl lx ly lz kp iq ma mb kt iu mc md kx iy me mf lb mg bi translated">常用测试方法</h2><figure class="jj jk jl jm fd jn er es paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="er es mh"><img src="../Images/146f18101baacbe3680e5afe5fbebd66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*0eJUg_516D65qxd0bAiwow.gif"/></div></div><figcaption class="ju jv et er es jw jx bd b be z dx">Credit: <a class="ae jd" href="https://www.behance.net/taylorrafael" rel="noopener ugc nofollow" target="_blank">https://www.behance.net/taylorrafael</a></figcaption></figure><p id="5713" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们来看看一些涵盖大多数单元测试类型的测试方法。</p><ul class=""><li id="b375" class="mi mj hi ih b ii ij im in iq mk iu ml iy mm jc mn mo mp mq bi translated"><strong class="ih mr">DOM元素的存在<br/> </strong>我们通过检查<code class="du je jf jg jh b">wrapper</code>是否拥有我们期望在组件挂载时呈现的所有默认元素来开始测试。我们通过检查实际的元素标签或其他属性(如类、id等)来做到这一点。Jest的断言函数如<code class="du je jf jg jh b">toBe()</code>以及来自Vue Test Utils的<code class="du je jf jg jh b">wrapper.contains()</code>或<code class="du je jf jg jh b">wrapper.findAll().length</code>可以帮助这个测试。</li></ul><figure class="jj jk jl jm fd jn"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="4dfb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们还可以使用<code class="du je jf jg jh b">wrapper.find()</code>返回的DOM元素的<code class="du je jf jg jh b">.text()</code>函数来检查元素的<code class="du je jf jg jh b">innerHTML</code>。<br/>例如<code class="du je jf jg jh b">expect(wrapper.find('.blah').text()).toBe('blah text')</code>。</p><ul class=""><li id="2717" class="mi mj hi ih b ii ij im in iq mk iu ml iy mm jc mn mo mp mq bi translated"><strong class="ih mr"> DOM action events <br/> </strong>我们可以测试一个动作在组件中执行时应该发出的事件。例如，当点击关闭按钮时，应该通过监听<code class="du je jf jg jh b">close</code>事件来关闭对话框。我们使用Vue Test Utils中的<code class="du je jf jg jh b">trigger()</code>函数来触发包装器所选DOM元素上的事件，并且<code class="du je jf jg jh b">wrapper.emitted()</code>给出了一个发出事件的列表，用于检查所需事件的存在。</li></ul><figure class="jj jk jl jm fd jn"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="59fc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面我们在<code class="du je jf jg jh b">closeBtn</code> DOM选择器上触发了<code class="du je jf jg jh b">click</code>事件。我们还可以触发其他事件，如按键的<code class="du je jf jg jh b">keydown</code>等。</p><figure class="jj jk jl jm fd jn"><div class="bz dy l di"><div class="ln lo l"/></div></figure><ul class=""><li id="657d" class="mi mj hi ih b ii ij im in iq mk iu ml iy mm jc mn mo mp mq bi translated"><strong class="ih mr">访问Vue包装器属性</strong> <br/>如果我们需要访问或更改我们的Vue组件的<code class="du je jf jg jh b">data</code>、<code class="du je jf jg jh b">computed</code>、<code class="du je jf jg jh b">methods</code>和<code class="du je jf jg jh b">props</code>，我们可以使用<code class="du je jf jg jh b">wrapper.vm</code>对象，因为Vue Test Utils在<code class="du je jf jg jh b">wrapper</code>中创建了组件的一个实例。当我们必须模拟其中一个属性的值时，这很有帮助。</li></ul><pre class="jj jk jl jm fd le jh lf lg aw lh bi"><span id="e4f2" class="li kg hi jh b fi lj lk l ll lm">wrapper.vm.name = 'test'; // changes name data property</span><span id="bc9d" class="li kg hi jh b fi ms lk l ll lm">wrapper.vm.save(); // invokes save() method</span><span id="22e3" class="li kg hi jh b fi ms lk l ll lm">wrapper.setProps({ propsName: newValue }); // changes propsName to newValue</span></pre><p id="a958" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一个例外是<code class="du je jf jg jh b">computed</code>属性，它需要使用<code class="du je jf jg jh b">shallowMount()</code>重新挂载并作为属性传入。因为我们在<code class="du je jf jg jh b">beforeEach()</code>中安装了组件，所以我们可以将<code class="du je jf jg jh b">shallowMount()</code>存储在一个工厂函数中，这个工厂函数可以在<code class="du je jf jg jh b">beforeEach()</code>期间和测试中轻松调用，测试需要将<code class="du je jf jg jh b">computed</code>属性的覆盖作为getter函数传递。</p><figure class="jj jk jl jm fd jn"><div class="bz dy l di"><div class="ln lo l"/></div></figure><ul class=""><li id="dc99" class="mi mj hi ih b ii ij im in iq mk iu ml iy mm jc mn mo mp mq bi translated">编写单元测试时需要知道的一件重要的事情是，如何伪造或模仿一个模块或方法的执行，它不是我们正在测试的单元的一部分。这有助于使我们的测试更加可预测，也避免了任何外部代码变更导致我们的测试失败。我们可以使用Jest的<code class="du je jf jg jh b">fn()</code>和<code class="du je jf jg jh b">mock()</code>函数来返回被嘲笑的版本。Vue Test Utils中的<code class="du je jf jg jh b">shallowMount()</code>内还有一个<code class="du je jf jg jh b">mocks</code>属性，用于模拟我们的组件在没有import语句的情况下可能使用的任何全局函数。</li></ul><p id="2203" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们来看看嘲讽函数。</p><figure class="jj jk jl jm fd jn"><div class="bz dy l di"><div class="ln lo l"/></div><figcaption class="ju jv et er es jw jx bd b be z dx">Mocking methods using jest.fn()</figcaption></figure><p id="a458" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面的测试，我们用<code class="du je jf jg jh b">jest.fn()</code>来模拟各种函数的返回值。我们可以在<code class="du je jf jg jh b">fn(() =&gt; true)</code>内部传递一个参数，该参数将被模拟调用。如果留空，则返回一个<code class="du je jf jg jh b">undefined</code>函数。</p><p id="fd1d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们还模仿了<code class="du je jf jg jh b">window.open()</code>全局函数，因为JSDOM没有提供，但是我们的测试需要执行它。</p><p id="5ec1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这些函数也是<code class="du je jf jg jh b">spies</code>，它让我们窥探它们的行为，并使用<code class="du je jf jg jh b">expect().toBeCalled()</code>函数来验证它们是否在测试中被调用。我们也可以使用<code class="du je jf jg jh b">jest.spyOn(Object, function name)</code> Jest函数来实现类似的行为。</p><p id="05ce" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">其他有用的函数模拟包括<code class="du je jf jg jh b">setInterval</code>和<code class="du je jf jg jh b">setTimeout</code>，因为Javascript原生定时器并不像Jest中预期的那样工作。我们可以使用Jest的函数如<code class="du je jf jg jh b">advanceTimersByTime(x)</code>或<code class="du je jf jg jh b">runOnlyPendingTimers()</code>来清除所有的定时器，只要确保在测试文件的顶部声明<code class="du je jf jg jh b">jest.userFakeTimers()</code>即可。</p><pre class="jj jk jl jm fd le jh lf lg aw lh bi"><span id="5193" class="li kg hi jh b fi lj lk l ll lm">jest.useFakeTimers(); // Declare at top of test file</span><span id="34c9" class="li kg hi jh b fi ms lk l ll lm">jest.advanceTimersByTime(1000); // Inside test function if you have specific millis</span><span id="a0ee" class="li kg hi jh b fi ms lk l ll lm">jest.runOnlyPendingTimers(); // Fast-forward until all pending timers have been executed</span></pre><p id="a537" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">模仿导入的模块非常简单。</p><figure class="jj jk jl jm fd jn"><div class="bz dy l di"><div class="ln lo l"/></div><figcaption class="ju jv et er es jw jx bd b be z dx">Mocking modules using jest.mock()</figcaption></figure><p id="5de2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们有一个<code class="du je jf jg jh b">Constants</code>模块导入到我们的组件中，那么我们返回带有我们的组件使用的任何属性的模拟对象，例如<code class="du je jf jg jh b">Constants.myConstant</code>。</p><ul class=""><li id="829c" class="mi mj hi ih b ii ij im in iq mk iu ml iy mm jc mn mo mp mq bi translated"><strong class="ih mr">异步回调<br/></strong></li></ul><figure class="jj jk jl jm fd jn"><div class="bz dy l di"><div class="ln lo l"/></div></figure><h1 id="45e7" class="kf kg hi bd kh ki mt kk kl km mu ko kp kq mv ks kt ku mw kw kx ky mx la lb lc bi translated">演示</h1><p id="09c7" class="pw-post-body-paragraph if ig hi ih b ii lp ik il im lq io ip iq lr is it iu ls iw ix iy lt ja jb jc hb bi translated">链接到<a class="ae jd" href="https://github.com/achhunna/vue-jest-unit-test" rel="noopener ugc nofollow" target="_blank">vue-jest-unit-test</a>repo I设置，带有<code class="du je jf jg jh b">App</code>组件及其测试。</p></div><div class="ab cl jy jz gp ka" role="separator"><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd"/></div><div class="hb hc hd he hf"><h1 id="1e2c" class="kf kg hi bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">结论</h1><p id="814c" class="pw-post-body-paragraph if ig hi ih b ii lp ik il im lq io ip iq lr is it iu ls iw ix iy lt ja jb jc hb bi translated">如果我们能很好地处理Jest和Vue Test Utils APIs，那么为我们的Vue组件编写单元测试将会变得轻而易举，我们甚至会乐在其中！这很重要，因为对我们的组件进行单元测试有助于我们编写设计更好且易于重构的代码。</p></div></div>    
</body>
</html>