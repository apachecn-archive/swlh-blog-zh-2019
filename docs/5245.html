<html>
<head>
<title>Design and Implement Cache Systems with Least Recently Used and Least Frequently Used Policies in C#</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用C#中最近最少使用和最少使用的策略设计和实现缓存系统</h1>
<blockquote>原文：<a href="https://medium.com/swlh/design-and-implement-cache-systems-with-least-recently-used-and-least-frequently-used-policies-in-1bedc4c7f328#2019-06-09">https://medium.com/swlh/design-and-implement-cache-systems-with-least-recently-used-and-least-frequently-used-policies-in-1bedc4c7f328#2019-06-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="0998" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">缓存系统是一个非常重要的工具，通过允许更快地访问保存在缓存中的数据来提高应用程序的性能。它比包括主存储器和硬盘在内的其他类型的存储器每字更贵。因此，缓存系统的容量非常有限，当达到其容量时，需要智能替换策略来管理缓存中的数据。并且高速缓存替换策略应该能够最小化高速缓存未命中的数量。在本教程中，我将分享如何用C#分别设计具有最近最少使用策略和最少使用策略的简单缓存系统。</p><h1 id="d8f6" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">高速缓存系统的基本要求</h1><p id="5ae1" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">缓存系统的主要目的是提供对存储在容量有限的缓存中的数据的更快访问。因此，我们可以将缓存系统的基本要求总结如下:</p><ol class=""><li id="78b7" class="kg kh hi ih b ii ij im in iq ki iu kj iy kk jc kl km kn ko bi translated">固定和有限的容量</li><li id="7f69" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated">给定一个键，访问存储在缓存中的数据的时间复杂度为常数(O(1))</li><li id="5f8e" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated">在缓存中添加数据项的恒定时间复杂度(O(1))</li></ol><p id="f3ea" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不管缓存替换策略如何，这三个基本要求可以应用于任何缓存系统。因此，我们可以根据上述要求创建一个接口ICache。为了使本教程更简单，并把重点放在真正重要的事情上，我将使用integer作为键及其在缓存中的值的数据类型，但如果必要的话，数据类型肯定可以是通用的。</p><figure class="ku kv kw kx fd ky"><div class="bz dy l di"><div class="kz la l"/></div></figure><h1 id="7e35" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">具有LRU策略的缓存系统</h1><p id="76e2" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">最近最少使用(LRU)策略是指选择最近最少访问的数据条目进行替换的算法。该策略假设，由于所选择的用于替换的数据条目不再被执行，因此它们的相关联的存储器可以被释放，而对应用性能的影响最小。</p><h2 id="3d7c" class="lb je hi bd jf lc ld le jj lf lg lh jn iq li lj jr iu lk ll jv iy lm ln jz lo bi translated">LRU的要求和设计</h2><ol class=""><li id="dc49" class="kg kh hi ih b ii kb im kc iq lp iu lq iy lr jc kl km kn ko bi translated">为了实现对数据条目的快速(O(1))访问，包括缓存中的Get和Add方法，我们可以使用C#中的字典来记录键及其数据条目。</li><li id="e5eb" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated">为了跟踪最少或最近使用的数据条目，我们需要设计一个数据结构。通过使用这种数据结构，每当数据条目被访问时，它将被放置在列表的顶部，利用这种属性，列表底部的数据条目将是最近最少使用的。为了符合高速缓存系统的基本要求，在该列表中添加或移除数据条目的时间复杂度也应该是O(1)。显然，这可以用双向链表来实现。</li></ol><figure class="ku kv kw kx fd ky er es paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="er es ls"><img src="../Images/3e28d1fee1508a4317b15ab0cec1bf7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RAN6Kl6kBfjPCl4r_CiOKw.png"/></div></div><figcaption class="lz ma et er es mb mc bd b be z dx">Double-Linked List for LRU</figcaption></figure><h2 id="6d79" class="lb je hi bd jf lc ld le jj lf lg lh jn iq li lj jr iu lk ll jv iy lm ln jz lo bi translated">RLU的实施</h2><p id="e581" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">我们可以使用LRUNode类来表示一个数据条目，它包含键、值以及它的前一个和下一个LRUNode的链接的属性。</p><figure class="ku kv kw kx fd ky"><div class="bz dy l di"><div class="kz la l"/></div></figure><p id="b203" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有了LRUNode类，现在我们可以实现LRU策略的双向链表，它有两个伪节点头和尾，以及三个时间复杂度为O(1)的方法:</p><ol class=""><li id="9e1c" class="kg kh hi ih b ii ij im in iq ki iu kj iy kk jc kl km kn ko bi translated">AddToTop(LRUNode node):这个方法是在双向链表的顶部添加一个新的节点。</li><li id="e17f" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated">RemoveNode(LRUNode node):这个方法是从双向链表中移除一个节点。</li><li id="fe92" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated">RemoveLRUNode():这个方法从双向链表中删除最近最少使用的节点。</li></ol><figure class="ku kv kw kx fd ky"><div class="bz dy l di"><div class="kz la l"/></div></figure><p id="7f38" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们准备实现LRU缓存类。</p><figure class="ku kv kw kx fd ky"><div class="bz dy l di"><div class="kz la l"/></div></figure><p id="cdef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们完成了LRU缓存系统的实现。</p><h1 id="47be" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">具有LFU策略的缓存系统</h1><p id="dcac" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">LFU策略指的是一种选择最不常用的数据项进行替换的算法。此外，如果存在平局，这意味着有一个以上的键具有最低频率，那么具有最低频率的最近最少使用的数据条目将被选择用于替换。</p><h2 id="cf01" class="lb je hi bd jf lc ld le jj lf lg lh jn iq li lj jr iu lk ll jv iy lm ln jz lo bi translated">LFU缓存的需求与设计</h2><ol class=""><li id="15fd" class="kg kh hi ih b ii kb im kc iq lp iu lq iy lr jc kl km kn ko bi translated">对于缓存中的每个数据条目，我们需要能够跟踪它的频率。为了解决这个问题，我们可以为每个数据条目添加一个额外的频率属性。</li><li id="cb37" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated">所有数据条目都应该按频率管理，我们需要能够跟踪所有数据条目的最低频率。为了解决这个问题，我们可以使用以频率为关键字的字典。</li><li id="3233" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated">对于具有相同频率的数据条目，我们应该能够得到最不频繁使用的数据条目。这个问题可以通过再次使用双向链表来解决。</li><li id="7086" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated">所有运算的时间复杂度应为O(1)。</li></ol><p id="fade" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">基于以上需求，我们现在可以对LFU缓存的设计有一个基本的想法。我们需要一个字典来记录所有的数据条目，另一个字典根据频率来管理所有的数据条目，如下所示。</p><figure class="ku kv kw kx fd ky er es paragraph-image"><div class="er es md"><img src="../Images/542c82aaf79f7fd2961d7ca1750d9e49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1268/format:webp/1*uMrbbMUfD46sgvpE2fKw7A.png"/></div><figcaption class="lz ma et er es mb mc bd b be z dx">Dictionary with frequency as Key and Double-Linked List as Value</figcaption></figure><p id="0ddd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如我们在上图中看到的，对于具有相同频率的数据条目，我们将使用一个双向链表作为容器来存储这些数据条目。并且双向链表将有助于通过最近最少使用来保持数据条目的顺序。</p><p id="4e9a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们实现LFU缓存。</p><h2 id="a6a7" class="lb je hi bd jf lc ld le jj lf lg lh jn iq li lj jr iu lk ll jv iy lm ln jz lo bi translated">实施LFU缓存</h2><p id="c4c0" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">同样，我们将创建一个节点类来表示LFU缓存中的数据条目。</p><figure class="ku kv kw kx fd ky"><div class="bz dy l di"><div class="kz la l"/></div></figure><p id="37a2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，我们需要执行LFU政策的双链表。这个双向链表非常类似于LRU的双向链表，除了我们需要添加一个额外的属性Count。我实现如下:</p><figure class="ku kv kw kx fd ky"><div class="bz dy l di"><div class="kz la l"/></div></figure><p id="38e9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们准备用LFU策略实现我们的缓存系统。在这个类中，除了基本的Get和Add方法之外，我们需要创建一个方法来将数据条目从较低频率的双向链表提升到较高频率的双向链表。并且每当有数据条目被访问时，将使用该方法。</p><p id="7e74" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我对这个LFU缓存实现如下:</p><figure class="ku kv kw kx fd ky"><div class="bz dy l di"><div class="kz la l"/></div></figure><p id="2f05" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">感谢您的宝贵时间！</p><p id="f376" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">希望这有助于理解具有这两种不同替换策略的缓存系统。</p><p id="2d4e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">参考:</p><ol class=""><li id="4722" class="kg kh hi ih b ii ij im in iq ki iu kj iy kk jc kl km kn ko bi translated">本教程的源代码可以在我的个人github中找到:<a class="ae me" href="https://github.com/doctral/Medium-Cache-System-Design.git" rel="noopener ugc nofollow" target="_blank">https://github.com/doctral/Medium-Cache-System-Design.git</a></li></ol></div></div>    
</body>
</html>