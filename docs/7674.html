<html>
<head>
<title>True Quantified Boolean Formulas in Non deterministic Polynomial time Problems</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">不确定多项式时间问题中的真量化布尔公式</h1>
<blockquote>原文：<a href="https://medium.com/swlh/true-quantified-boolean-formulas-in-non-deterministic-polynomial-time-problems-bb317efe1653?source=collection_archive---------42-----------------------#2019-07-05">https://medium.com/swlh/true-quantified-boolean-formulas-in-non-deterministic-polynomial-time-problems-bb317efe1653?source=collection_archive---------42-----------------------#2019-07-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/e1524e8f9199d476e700d0836ed9ddaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JU7-Ksjiq4PaSbnS1-A6gw.jpeg"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx">Photo by <a class="ae hv" href="https://unsplash.com/@kaleidico?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Kaleidico</a> on <a class="ae hv" href="https://unsplash.com/search/photos/whiteboard?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><div class=""/><div class=""><h2 id="7a20" class="pw-subtitle-paragraph iv hx hy bd b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm dx translated">理解如何连接它们的第一种方法</h2></div><p id="6708" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">想象一下，您有一种机制，即使是手动的，也允许您将任何<strong class="jp kj">量化的布尔表达式</strong>连接到一个没有量词的简单表达式。</p><figure class="kl km kn ko fd hk er es paragraph-image"><div class="er es kk"><img src="../Images/f473e7ee060131b519401c29bc733928.png" data-original-src="https://miro.medium.com/v2/resize:fit:772/format:webp/1*Qzwp9zgwRdK-odUjhBRHtw.jpeg"/></div><figcaption class="hr hs et er es ht hu bd b be z dx"><a class="ae hv" href="https://archive.org/stream/TQBFInP_201802/TQBF_26FEBJMD#page/n1/mode/2up" rel="noopener ugc nofollow" target="_blank">https://archive.org/stream/TQBFInP_201802/TQBF_26FEBJMD#page/n1/mode/2up</a></figcaption></figure><p id="9298" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">此外，想象一下，你合并了允许你在多项式时间内解决任何<strong class="jp kj">布尔表达式</strong>的机制…</p><div class="hh hi ez fb hj kp"><a rel="noopener follow" target="_blank" href="/swlh/the-boolean-satisfiability-problem-solved-48ceb5550115"><div class="kq ab dw"><div class="kr ab ks cl cj kt"><h2 class="hz b fi z dy ku ea eb kv ed ef hx bi translated">布尔可满足性问题，解决了吗？</h2><div class="kw l"><h3 class="bd b fi z dy ku ea eb kv ed ef dx translated">在这里，我展示了一些终极技术来制作逻辑运算的强大工具。</h3></div><div class="kx l"><p class="bd b fp z dy ku ea eb kv ed ef dx translated">medium.com</p></div></div><div class="ky l"><div class="kz l la lb lc ky ld hp kp"/></div></div></a></div><p id="451e" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">但是现在，没人相信你。你有算法，细致的解释…，但你还没有得到正式的否定或接受。</p><p id="00d4" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">在这篇文章中，我将展示<em class="le">内核</em>与<strong class="jp kj"> TQBF </strong>之间的连接，以参与<strong class="jp kj"> NP </strong>类。</p><h2 id="988c" class="lf lg hy bd lh li lj lk ll lm ln lo lp jw lq lr ls ka lt lu lv ke lw lx ly lz bi translated">TQBF是什么意思</h2><p id="ccfa" class="pw-post-body-paragraph jn jo hy jp b jq ma iz js jt mb jc jv jw mc jy jz ka md kc kd ke me kg kh ki hb bi translated"><a class="ae hv" href="https://en.wikipedia.org/wiki/True_quantified_Boolean_formula" rel="noopener ugc nofollow" target="_blank">真量化布尔公式</a>是指你有一个<strong class="jp kj">布尔表达式</strong>并且你想知道它的一些变量是否可以表示为一个布尔函数来把整个表达式变成一个重言式。这就好比说:如果一个<strong class="jp kj">布尔表达式</strong>及其<strong class="jp kj">变量</strong>和<strong class="jp kj">参数</strong>是一个定理。比如<em class="le">ɐp ɐq: p&amp;(p→q)→q</em>是一个<strong class="jp kj">qbf</strong><em class="le">ɐp ɐq: p&amp;(p→q)→q = 1</em>是一个<strong class="jp kj"> TQBF </strong>。</p><p id="19b4" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><strong class="jp kj"> TQBF </strong>是一种问题，这个表达式是否成立，如果所有的变量都属于<strong class="jp kj">ɐ</strong>一类，那就意味着我们正在处理一个可能的重言式。在我们的例子中:<em class="le"> (P → Q) → Q = 1 </em>是一个重言式，意思是:</p><ul class=""><li id="4d2d" class="mf mg hy jp b jq jr jt ju jw mh ka mi ke mj ki mk ml mm mn bi translated">(ⱻP，ⱻQ : (P &amp; (P → Q) → Q) = 1)</li></ul><p id="1590" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">这就像解决一个<strong class="jp kj">TBF</strong>:<em class="le">(P&amp;(P→Q)→Q)</em>并对<strong class="jp kj"> TQBF </strong>问题做出相反的反应。</p><p id="d339" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">所以，问题是:我们能对存在主义的表达做些什么，比如:<em class="le">ɐp ⱻq:(p→q)→p .</em></p><p id="27ca" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">最初应该说，把存在的(<em class="le"> ⱻ) </em>放在普遍的(<em class="le">ɐ)</em>之前和之后是不一样的。</p><ul class=""><li id="5dc5" class="mf mg hy jp b jq jr jt ju jw mh ka mi ke mj ki mk ml mm mn bi translated">在<em class="le">ⱻqɐp:(p→q)→p中，q不能依赖于P </em></li><li id="487f" class="mf mg hy jp b jq mo jt mp jw mq ka mr ke ms ki mk ml mm mn bi translated">在<em class="le">ɐp ⱻq:(p→q)→p中，q是依赖于p或不依赖于p的布尔表达式</em></li></ul><p id="ea0e" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">在第一种情况下，<em class="le"> Q </em>只能得到两个可能的值(<em class="le">真</em>或<em class="le">假</em>)，如果你试图在Q = <em class="le">假</em>中找到一个重言式:</p><ul class=""><li id="3e42" class="mf mg hy jp b jq jr jt ju jw mh ka mi ke mj ki mk ml mm mn bi translated">(真→假)→假=真→假=假</li><li id="955b" class="mf mg hy jp b jq mo jt mp jw mq ka mr ke ms ki mk ml mm mn bi translated">(假→假)→真=真→真=真</li></ul><p id="1924" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">所以，如果Q = <em class="le">假</em>，就不是重言式。</p><p id="be47" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">如果<em class="le">问</em> = <em class="le">真:</em></p><ul class=""><li id="eb9a" class="mf mg hy jp b jq jr jt ju jw mh ka mi ke mj ki mk ml mm mn bi translated">(真→真)→假=真→假=假</li><li id="2bc2" class="mf mg hy jp b jq mo jt mp jw mq ka mr ke ms ki mk ml mm mn bi translated">(假→真)→真=真→真=真</li></ul><p id="67b4" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">这意味着表达式:<em class="le">ⱻqɐp:(p→q)→p</em>不是一个<strong class="jp kj">布尔定理</strong>。</p><p id="3197" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">但是如果我们在<em class="le">ɐp ⱻq:中测试<em class="le">q</em>=<em class="le">p</em>(p→q)→p，</em></p><ul class=""><li id="e538" class="mf mg hy jp b jq jr jt ju jw mh ka mi ke mj ki mk ml mm mn bi translated">(真→假)→假=假→假=真</li><li id="934b" class="mf mg hy jp b jq mo jt mp jw mq ka mr ke ms ki mk ml mm mn bi translated">(假→真)→真=真→真=真</li></ul><p id="2ca3" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">所以，<em class="le">ɐp ⱻq:(p→q)→p</em>是一个<strong class="jp kj">布尔定理</strong>，在Q = <em class="le"> P，</em>中我们只能得出一个重言式，你可以这样理解:如果一个表达式指向它的矛盾，那么它就指向表达式的对立面。</p><p id="14da" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">你能想象如果我们能找到产生重言式的表达式，我们能做多少应用吗？</p><figure class="kl km kn ko fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mt"><img src="../Images/b6719e4aa0ad3f2e73dd66c3939b4b39.png" data-original-src="https://miro.medium.com/v2/resize:fit:438/format:webp/1*w2HFl-VDODY8hhs6TQdBEw.jpeg"/></div></div></figure><h1 id="f299" class="mu lg hy bd lh mv mw mx ll my mz na lp je nb jf ls jh nc ji lv jk nd jl ly ne bi translated">什么是霍恩条款？</h1><p id="bce3" class="pw-post-body-paragraph jn jo hy jp b jq ma iz js jt mb jc jv jw mc jy jz ka md kc kd ke me kg kh ki hb bi translated">为了更简单，我的建议是使用<a class="ae hv" href="https://en.wikipedia.org/wiki/Horn_clause" rel="noopener ugc nofollow" target="_blank">霍恩的条款</a>。想象每一个<strong class="jp kj">布尔表达式</strong>都被转换成<em class="le"> Horn子句</em>的乘积:</p><p id="17b7" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">(A1 + A2 +… + An + B1 + B2 +… + Bn)形式的每一个分句都转换成:(B1 &amp; B2 &amp; … &amp; Bn → A1 + A2 +… + An)形式，这样我们就可以避开否定形式了。</p><p id="a08a" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">如果我们添加以下形式的子句:</p><ul class=""><li id="60c9" class="mf mg hy jp b jq jr jt ju jw mh ka mi ke mj ki mk ml mm mn bi translated">(<em class="le">真</em> → A1 +… + An)，并且</li><li id="2974" class="mf mg hy jp b jq mo jt mp jw mq ka mr ke ms ki mk ml mm mn bi translated">(B1&amp; … &amp; Bn → <em class="le">假</em>)</li></ul><p id="1e40" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">然后，这些子句的乘积将表示每个<strong class="jp kj">布尔表达式</strong>。</p><p id="8bec" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">现在，是什么让一个同义反复变成了一个喇叭子句？</p><h2 id="923e" class="lf lg hy bd lh li lj lk ll lm ln lo lp jw lq lr ls ka lt lu lv ke lw lx ly lz bi translated">ParamClause实现</h2><p id="f178" class="pw-post-body-paragraph jn jo hy jp b jq ma iz js jt mb jc jv jw mc jy jz ka md kc kd ke me kg kh ki hb bi translated">我们可以和熊猫一起研究牛角条款。考虑到它对大型数据库的用处。</p><p id="3451" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">为了理解它是如何工作的，我们可以从一个<em class="le">量化的霍恩条款</em>开始:</p><ul class=""><li id="e548" class="mf mg hy jp b jq jr jt ju jw mh ka mi ke mj ki mk ml mm mn bi translated"><em class="le">ɐx,ɐy,ɐz、ⱻA、ⱻB: A &amp; x → B + y + z </em></li></ul><p id="f0e6" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">上面的表达式有两个参数<em class="le"> A </em>、<em class="le"> B </em>和三个变量<em class="le"> x </em>、<em class="le"> y </em>、<em class="le"> z </em>。如果我们考虑公式对于每个参数可能采用的表达式，我们可以说，例如，如果<em class="le"> A </em>为<em class="le">假</em>，则整个子句已经是一个重言式。</p><p id="fdb3" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">更具体地说:(A =<em class="le">False</em>)+(A =<em class="le">x</em>)+(A =<em class="le">y</em>)+(A =<em class="le">z</em>)，而你可以用一个3值逻辑的字符串把这四种可能性表达为<em class="le">A:“2211”。</em>表示1为<em class="le">真</em>，2为<em class="le">假</em>，3为<em class="le">未确定</em>。如果与变量<em class="le"> x </em>相关:1为<em class="le"> x </em>，2为<em class="le"> x </em>，3为<em class="le">无关</em>。</p><p id="4fd8" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">所以，想象你可以这样输入公式<em class="le"> A &amp; x → B + y + z </em>:</p><pre class="kl km kn ko fd nf ng nh ni aw nj bi"><span id="aeb0" class="lf lg hy ng b fi nk nl l nm nn">&gt;&gt;&gt; ParamClause("22111122", "A", "B")<br/>Clause of 2 params.<br/>   A  B<br/>0  2  1<br/>1  2  1<br/>2  1  2<br/>3  1  2</span></pre><p id="3baf" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">在这个版本中没有提到变量<em class="le"> x </em>、<em class="le"> y </em>、<em class="le"> z </em>而是1、2、3；这是代码:</p><pre class="kl km kn ko fd nf ng nh ni aw nj bi"><span id="a7dd" class="lf lg hy ng b fi nk nl l nm nn">from pandas import DataFrame<br/>class ParamClause:<br/>    'Clauses of at least one parameter recognized'<br/>    def __init__(self, body, *params):<br/>        self.body = DataFrame({params[j] : X \<br/>            for j, X in enumerate(<br/>                ParamClause.sequence(body, len(params)))})<br/>    @staticmethod<br/>    def sequence(body, nParams):<br/>        body = [3 if not x in '12' else int(x) for x in body]<br/>        n = len(body)//nParams       <br/>        return  [body[i * n: (i + 1) * n] for i in range(nParams)]<br/>    def __repr__(self):<br/>        return 'Clause of '\<br/>               +repr(self.body.shape[1]) + ' params.\n' \<br/>               + repr(self.body)</span></pre><p id="32be" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">从这一点，你可以很容易地想象如何将问题转化为一个布尔表达式的可满足性问题。因为，如果你有两个<em class="le"> Horn子句</em>，那么<strong class="jp kj"> ParamClause </strong>对象必须共享参数和变量，在这一点上，你必须使用第三个值(3)来避免变量与子句或参数的任何关系。</p><p id="8941" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">使用这种方法:</p><pre class="kl km kn ko fd nf ng nh ni aw nj bi"><span id="48e6" class="lf lg hy ng b fi nk nl l nm nn">def required(self):<br/>        return [(I, J) for I in self.body.columns \<br/>                for J in self.body.index if self.body[I][J]&lt;3]</span></pre><p id="2ddb" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">你可以达到每一个布尔变量来满足像:</p><pre class="kl km kn ko fd nf ng nh ni aw nj bi"><span id="b7f8" class="lf lg hy ng b fi nk nl l nm nn">&gt;&gt;&gt; ParamClause("22111122", "A", "B").required()<br/>[('A', 0), ('A', 1), ('A', 2), ('A', 3), ('B', 0), ('B', 1), ('B', 2), ('B', 3)]</span></pre><p id="09ec" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">对(列，行)编码一个布尔变量<strong class="jp kj">有时在不同的子句中收缩，因此它生成一个公式。</strong></p><h2 id="ca93" class="lf lg hy bd lh li lj lk ll lm ln lo lp jw lq lr ls ka lt lu lv ke lw lx ly lz bi translated">旧版本</h2><p id="29fb" class="pw-post-body-paragraph jn jo hy jp b jq ma iz js jt mb jc jv jw mc jy jz ka md kc kd ke me kg kh ki hb bi translated">在<a class="ae hv" href="https://archive.org/download/TheTwoExactPhilosophiesFiles" rel="noopener ugc nofollow" target="_blank"> quantifiers31.py </a>中你可以到达一个完整的代码，而不是在<em class="le"> pandas </em>中，生成最后的<strong class="jp kj">布尔公式</strong>。</p><p id="20cd" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">在这个版本中，您可以使用一个包含一系列<em class="le"> QTuple </em>对象(<em class="le"> ParamClause </em>对象)的对象，在满足公式后，它会生成一个<em class="le"> QTuple </em>解决方案来获得所有重言式的情况。</p><p id="0fa6" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">在我们的类中，我们需要实现这些方法:</p><pre class="kl km kn ko fd nf ng nh ni aw nj bi"><span id="8dd4" class="lf lg hy ng b fi nk nl l nm nn">def notNulledParams(self):<br/>        return [X for X in self.body.columns \<br/>                if (self.body[X] == 3).sum() &lt; self.body.shape[0]]</span><span id="223b" class="lf lg hy ng b fi no nl l nm nn">def compatiblesInParam(self, other, param):<br/>        return (self.body[param] \<br/>                &amp; other.body[param] == 0).sum() == 0</span></pre><p id="320d" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">这对熊猫来说很容易。目前，我还没有完整的版本，但是如果这个帖子被认为是有趣的，我可以用<em class="le">熊猫</em>来结束这个课程。</p><p id="cae6" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">当然，你可以分享或尝试这个公共领域代码中的一切。</p></div></div>    
</body>
</html>