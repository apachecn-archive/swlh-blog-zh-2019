<html>
<head>
<title>How Does Hotspot Scan The Root Set During Garbage Collection?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Hotspot在垃圾收集时如何扫描根集？</h1>
<blockquote>原文：<a href="https://medium.com/swlh/https-medium-com-dredwardhyde-how-does-hotspot-jvm-scan-the-root-set-31c0bdbf3271?source=collection_archive---------20-----------------------#2019-07-15">https://medium.com/swlh/https-medium-com-dredwardhyde-how-does-hotspot-jvm-scan-the-root-set-31c0bdbf3271?source=collection_archive---------20-----------------------#2019-07-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/60b204abf4e3fce87c3704c0ec86fede.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WGrtjmHlct5159CXcvYcfA.png"/></div></div></figure><p id="9867" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jo">注意:我没有以任何方式参与OpenJDK开发。下面表达的所有观察</em> <em class="jo">都是我自己的。</em></p><p id="01da" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在我的第一篇文章中，我想谈谈一些有趣的解决方案，它们已经成为世界上最流行的JVM实现——Hotspot，最初由Sun Microsystems开发，然后由Oracle完善到目前的状态。</p><p id="1352" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">典型的JVM实现由多个子系统组成，比如各种解析器、类加载器、解释器、JIT编译器等等，但是最复杂的子系统可能都与垃圾收集有关。</p><p id="9deb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is jp">首先</strong>，JVM运行时的唯一目的是执行兼容的字节码，也就是严格遵循JLS规则来分配和销毁对象、调用方法和提供系统资源——以及所有这些。所以，运行时就是以最有效的方式操作和执行字节码，而字节码本身由类和方法组成。在实践中，你必须解决许多奇妙的工程问题才能正确地操纵它。挑战之一是清理垃圾——不可及的对象——因为Java是一种具有自动内存管理的语言。类实例——对象——分配给堆的小区域，有自己的头和指向它的指针——在运行时无处不在，因此垃圾收集器必须了解字节码执行期间发生的一切，并且必须了解各种代码操作，如JIT编译、优化和对象锁定。因此，与垃圾收集相关的代码在JVM实现中几乎无处不在，工程师在实现新特性时必须牢记这一点。</p><p id="9f8c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is jp">其次</strong>，运行时环境必须非常有效地执行代码——以最小的性能损失且没有明显的停顿——甚至以某种方式更改代码以使其执行更快，因为，通常情况下，开发人员不会考虑性能，直到为时已晚。垃圾收集的优化有两种方式——尽量不要产生新的垃圾，或者尽可能快地消除垃圾。第一种类型可以由JIT编译器完成——它被称为<em class="jo">转义分析</em>,它允许JIT在堆栈上而不是堆上分配一些对象——因此对象将与封闭方法框架一起被销毁。但是第二类优化的负担完全落在垃圾收集器解决方案架构师和开发人员的肩上。</p><h2 id="13e3" class="jq jr hi bd js jt ju jv jw jx jy jz ka jb kb kc kd jf ke kf kg jj kh ki kj kk bi translated">典型的GC循环包括哪些步骤？</h2><p id="202d" class="pw-post-body-paragraph iq ir hi is b it kl iv iw ix km iz ja jb kn jd je jf ko jh ji jj kp jl jm jn hb bi translated">例如，对于并发标记清除(CMS)收集器，并发收集周期通常包括以下步骤:</p><ul class=""><li id="49f5" class="kq kr hi is b it iu ix iy jb ks jf kt jj ku jn kv kw kx ky bi translated"><strong class="is jp">停止所有应用程序线程，识别从根可达的对象集，然后恢复所有应用程序线程。</strong></li><li id="aef7" class="kq kr hi is b it kz ix la jb lb jf lc jj ld jn kv kw kx ky bi translated">当应用程序线程正在执行时，使用一个或多个处理器并发地跟踪可到达对象图。</li><li id="94f2" class="kq kr hi is b it kz ix la jb lb jf lc jj ld jn kv kw kx ky bi translated">使用一个处理器，同时重新跟踪自上一步跟踪以来修改过的对象图部分。</li><li id="5f45" class="kq kr hi is b it kz ix la jb lb jf lc jj ld jn kv kw kx ky bi translated">停止所有应用程序线程，并重新跟踪根和对象图中自上次检查以来可能已被修改的部分，然后恢复所有应用程序线程。</li><li id="111b" class="kq kr hi is b it kz ix la jb lb jf lc jj ld jn kv kw kx ky bi translated">使用一个处理器，同时将不可到达的对象清除到用于分配的自由列表中。</li><li id="9f8d" class="kq kr hi is b it kz ix la jb lb jf lc jj ld jn kv kw kx ky bi translated">使用一个处理器，同时调整堆的大小并为下一个收集周期准备支持数据结构。</li></ul><p id="a8a1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">今天我想谈谈GC循环的第一步——识别和标记根对象。这是Hotspot中所有垃圾收集器的共同步骤——串行、并行、CMS、G1和Shenandoah，它没有什么特殊的实现细节值得一提。</p><h2 id="cdf0" class="jq jr hi bd js jt ju jv jw jx jy jz ka jb kb kc kd jf ke kf kg jj kh ki kj kk bi translated">什么是根？</h2><p id="5756" class="pw-post-body-paragraph iq ir hi is b it kl iv iw ix km iz ja jb kn jd je jf ko jh ji jj kp jl jm jn hb bi translated">好吧，引用<strong class="is jp">垃圾收集手册</strong>，<em class="jo">“有一些有限的赋值函数根集合，表示存放在存储器中的指针，赋值函数可以直接访问这些指针，而不需要通过其他对象”</em>。这是一个正确的定义，但是有更多的根源。在热点中，根是以下对象:</p><ul class=""><li id="1a7e" class="kq kr hi is b it iu ix iy jb ks jf kt jj ku jn kv kw kx ky bi translated">所有JNI全球参考</li><li id="53a5" class="kq kr hi is b it kz ix la jb lb jf lc jj ld jn kv kw kx ky bi translated">所有充气显示器</li><li id="1920" class="kq kr hi is b it kz ix la jb lb jf lc jj ld jn kv kw kx ky bi translated">由引导类加载器加载的所有类(或禁用类卸载时的所有类)</li><li id="ff26" class="kq kr hi is b it kz ix la jb lb jf lc jj ld jn kv kw kx ky bi translated">所有java线程</li><li id="f437" class="kq kr hi is b it kz ix la jb lb jf lc jj ld jn kv kw kx ky bi translated">对于每个java线程，线程执行堆栈上的所有局部变量和JNI局部变量引用</li><li id="4889" class="kq kr hi is b it kz ix la jb lb jf lc jj ld jn kv kw kx ky bi translated">来自<strong class="is jp">宇宙的所有可见/可解释的物体::oops_do() </strong></li></ul><p id="c8a6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">稍后我将以并行垃圾收集器为例详细解释每一步，因为它的实现非常简单易读。</p><p id="871b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在并行GC中标记根从方法<strong class="is jp"> do_it(): </strong>开始</p><figure class="le lf lg lh fd ij"><div class="bz dy l di"><div class="li lj l"/></div></figure><p id="fbf2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is jp">上述方法的第一步</strong>是在<strong class="is jp"> Universe — </strong> namespace中标记一些对象，这些对象包含VM中已知的系统类和对象。整个初始世界初始化，像加载基类，调用<strong class="is jp">VM symbols::initialize()</strong>，<strong class="is jp">system dictionary::initialize()</strong>以及各种必要的对象分配都发生在<strong class="is jp"> Universe::genesis() </strong>中。所以我们需要在<strong class="is jp"> oops_do() </strong>方法中标记其中的一些:</p><figure class="le lf lg lh fd ij"><div class="bz dy l di"><div class="li lj l"/></div></figure><p id="85b6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is jp">第二步</strong>是在全局JNI句柄中标记引用:</p><figure class="le lf lg lh fd ij"><div class="bz dy l di"><div class="li lj l"/></div></figure><p id="20af" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">全局JNI句柄列表驻留在<strong class="is jp"> JNIHandles </strong>类中:</p><figure class="le lf lg lh fd ij"><div class="bz dy l di"><div class="li lj l"/></div></figure><p id="1a3f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一般来说，<strong class="is jp"> OopStorage </strong>是线程安全(有时是并发的)交互的容器，它与Java堆中分配的对象的堆外引用进行交互。<strong class="is jp"> _global_handles </strong>包含用于ArrayOutOfBoundsException、ArrayStoreException、ClassCastException、类加载器、JIT编译器使用的oop包装器、编译器线程本身等的JNI句柄。在内部，每个<strong class="is jp"> OopStorage </strong>包含一组<strong class="is jp"> Blocks </strong>对象，而<strong class="is jp"> Block </strong>本身包含一个<strong class="is jp"> oop[] </strong>数组和一个指示哪些条目正在使用(已经分配但尚未释放)的位掩码。在垃圾收集期间，收集器必须知道所有的<strong class="is jp"> OopStorage </strong>对象及其引用强度，每个<strong class="is jp"> OopStorage </strong>为垃圾收集器提供对所有分配条目的迭代支持。所以<strong class="is jp"> oops_do() </strong>在<strong class="is jp"> OopStorage </strong>上最终调用<strong class="is jp"> iterate_impl() </strong>方法，该方法遍历<strong class="is jp">块</strong>:</p><figure class="le lf lg lh fd ij"><div class="bz dy l di"><div class="li lj l"/></div></figure><p id="b221" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后每个<strong class="is jp">块</strong>迭代所有存储在<strong class="is jp"> _data </strong>数组中的<strong class="is jp"> oops </strong>:</p><figure class="le lf lg lh fd ij"><div class="bz dy l di"><div class="li lj l"/></div></figure><p id="0e02" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is jp">下一步</strong>很棘手——我们需要标记存储在线程堆栈上的所有Java对象引用以及与线程相关的内部JVM对象。进程从<strong class="is jp">线程开始::oops_do() </strong>方法:</p><figure class="le lf lg lh fd ij"><div class="bz dy l di"><div class="li lj l"/></div></figure><p id="cb73" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们使用<em class="jo">“史上最丑的for循环”</em>遍历所有线程:</p><figure class="le lf lg lh fd ij"><div class="bz dy l di"><div class="li lj l"/></div></figure><p id="1bd1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">并调用<strong class="is jp"> JavaThread::oops_do() </strong>:</p><figure class="le lf lg lh fd ij"><div class="bz dy l di"><div class="li lj l"/></div></figure><p id="dd01" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在<strong class="is jp"> Thread::oops_do() </strong>中，我们标记所有活动的JNI句柄、可能的<strong class="is jp"> _pending_exception </strong>、在<strong class="is jp">handle area * _ handle _ area</strong>中的所有线程本地句柄，保留用于在VM和线程本地监视器内分配句柄:</p><figure class="le lf lg lh fd ij"><div class="bz dy l di"><div class="li lj l"/></div></figure><p id="4c3a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在<strong class="is jp">active _ handles()-&gt;oops _ do(f)</strong>中，我们遍历并标记每个线程的所有活动JNI句柄，因为<strong class="is jp">JNIHandleBlock * _ active _ handles</strong>中的每个<strong class="is jp"> JNIHandleBlock </strong>都包含强根——对作为参数传递给JNI方法的Java对象的引用:</p><figure class="le lf lg lh fd ij"><div class="bz dy l di"><div class="li lj l"/></div></figure><p id="60a0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">JNI方法是非托管区域，所以作为参数传递的对象被认为是活动的，我们需要标记它们:</p><figure class="le lf lg lh fd ij"><div class="bz dy l di"><div class="li lj l"/></div></figure><p id="b890" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">每个线程也可以持有任意数量的本地胖锁— <strong class="is jp"> ObjectMonitor </strong>对象。它们都必须用<strong class="is jp">object synchronizer::thread _ local _ used _ oops _ do()</strong>方法进行标记，因为它们包含向后对象指针:</p><figure class="le lf lg lh fd ij"><div class="bz dy l di"><div class="li lj l"/></div></figure><p id="853f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">JavaThread::oops_do() 中的下一个主要步骤是遍历当前线程的执行堆栈。什么是执行堆栈？这是一组帧，其中一些来自本机方法(如JIT编译)，一些来自解释器，其他的只是<strong class="is jp"> StubRoutine </strong>条目。每个这样的帧都包含局部变量和传递的参数，它们在垃圾收集期间就像强根一样。所以我们需要识别他们并做好标记。在<strong class="is jp">帧</strong>中标记根开始于<strong class="is jp">帧::oops_do_internal() </strong>方法:</p><figure class="le lf lg lh fd ij"><div class="bz dy l di"><div class="li lj l"/></div></figure><p id="2e26" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果frame是<strong class="is jp"> StubRoutine </strong>条目，那么我们需要标记传递的参数、调用的接收者(如果是非静态调用)和保存在<strong class="is jp"> JNIHandleBlock </strong>块中的对象:</p><figure class="le lf lg lh fd ij"><div class="bz dy l di"><div class="li lj l"/></div></figure><p id="9d13" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果frame被解释，那么调用<strong class="is jp">frame::oops _ interpreted _ do()</strong>方法。这里我们标记<strong class="is jp"> BasicObjectLock </strong>对象，因为它们包含对Java对象的引用，就像胖锁一样。然后我们需要标记当前帧中的所有局部引用。这就是使用<strong class="is jp"> OopMapCache </strong>的地方——这个缓存保存了解释帧中对象引用的位置:</p><figure class="le lf lg lh fd ij"><div class="bz dy l di"><div class="li lj l"/></div></figure><p id="3fbf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">每个<strong class="is jp">instance klass</strong>(Java类的VM级表示)只有一个<strong class="is jp"> OopMapCache </strong>实例，并且必须在第一次请求时被延迟分配。然后在<strong class="is jp"> OopMapCache::lookup() </strong>方法中查询并填充。但是在<strong class="is jp"> OopMapCache </strong>的查找中有一个微妙的细节——它发生在<strong class="is jp">全局安全点</strong>。这意味着执行堆栈的平均深度极大地影响了由根标记引起的停顿持续时间。这种模式甚至被用在最现代的垃圾收集器中，如G1和谢南多厄。</p><figure class="le lf lg lh fd ij"><div class="bz dy l di"><div class="li lj l"/></div></figure><p id="1723" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于编译帧，我们有一套稍微不同的工具。首先，<strong class="is jp"> CodeCache </strong>保存各种生成的代码——编译的java方法、运行时存根、转换帧等。<strong class="is jp"> CodeCache </strong>中的条目都是<strong class="is jp"> CodeBlob </strong>的。<strong class="is jp"> CodeCache </strong>可以更新，例如在C1用<strong class="is jp">Compilation::install _ code()</strong>方法编译之后或者在去优化事件期间。因此，概要分析和非概要分析的JIT生成的方法(nmethods)都存储在这里。通过检查<strong class="is jp">frame::oops _ do _ internal()</strong>中的<strong class="is jp">code cache::contains(PC())</strong>，我们可以判断它是否是本机方法，并在<strong class="is jp">frame::oops _ code _ blob _ do()</strong>中适当地处理它:</p><figure class="le lf lg lh fd ij"><div class="bz dy l di"><div class="li lj l"/></div></figure><p id="05d7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">每个<strong class="is jp">代码块</strong>保存<strong class="is jp">不可变的OOP mapset * _ OOP _ maps—<strong class="is jp">OOP map</strong>条目的</strong>集合。<strong class="is jp"> OopMapValue </strong>代表一个单独的<strong class="is jp"> OopMap </strong>条目，并为特定pc描述每个寄存器和帧堆栈槽是否是对Java对象的引用。如果它是一个引用(<strong class="is jp"> oop </strong>)，那么我们必须像往常一样将其标记为强根。</p><p id="0836" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is jp">markfrorootstask::do _ it()</strong>中根标记的下一步是通过调用<strong class="is jp">object synchronizer::oops _ do()</strong>来标记所有全局<strong class="is jp"> ObjectMonitor </strong>对象。这一过程也发生在全球安全点。</p><p id="c6cc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在<strong class="is jp"> Management::oops_do() </strong>中，我们标记了存储在<strong class="is jp"> MemoryService </strong>和<strong class="is jp"> ThreadService </strong>中的所有根。<strong class="is jp"> MemoryService </strong>提供虚拟机端的监控和管理支持，并保存对<strong class="is jp">内存池</strong>和<strong class="is jp">内存管理器</strong>实例的引用。每个<strong class="is jp">内存池</strong>保存从<strong class="is jp">内存池Impl.setUsageThreshold() </strong>方法传递的对<strong class="is jp">传感器</strong> Java对象— <strong class="is jp"> _usage_sensor </strong>和<strong class="is jp"> _gc_usage_sensor </strong>的引用。<strong class="is jp">线程服务</strong>包含引用Java线程的<strong class="is jp">线程快照</strong>对象。上述所有对象也必须标记为强根。</p><p id="ace0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在<strong class="is jp"> JvmtiExport::oops_do() </strong>中，我们标记了所有Java对象，这些对象的引用被过渡性地存储在<strong class="is jp"> JvmtiBreakpointCache </strong>中，并直接从JVM TI分配。</p><p id="d5e9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is jp">根标记过程的下一个重要步骤</strong>是从<strong class="is jp">系统字典</strong>中识别所有引用的强根。在<strong class="is jp">system dictionary::oops _ do()</strong>中，我们标记了系统和平台<strong class="is jp"> ClassLoader </strong> s等的VM端镜像。请参见下面代码片段中的注释:</p><figure class="le lf lg lh fd ij"><div class="bz dy l di"><div class="li lj l"/></div></figure><p id="0733" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is jp"> invoke_method_table() </strong>在<strong class="is jp">SymbolPropertyTable * _ invoke _ method _ table</strong>上被调用。<strong class="is jp">符号属性表</strong>是系统内部符号到指针的映射。例如，这个表保存了对JVM定义的低级内部方法的引用。例如，在调用点的多态方法查找期间，可以在<strong class="is jp">system dictionary::find _ method _ handle _ intrinsic()</strong>方法中添加<strong class="is jp"> SymbolPropertyTable </strong>的条目。</p><p id="86f1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is jp">ClassLoaderDataGraph::always _ strong _ CLD _ do()</strong>标记来自<strong class="is jp">块</strong>的所有Java对象引用。这些对象是与当前<strong class="is jp"> ClassLoaderData </strong>相关联的java/lang/ClassLoader实例、常量池数组、模块等。所有对象都有相应的<strong class="is jp">类加载器</strong>的相同生命周期。</p><figure class="le lf lg lh fd ij"><div class="bz dy l di"><div class="li lj l"/></div></figure><p id="ed6a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">而作为标记根的最后一步，<strong class="is jp"> AOTLoader::oops_do() </strong>必须标记所有引用的Java对象。<strong class="is jp"> AOTLoader </strong>用于<a class="ae lk" href="https://openjdk.java.net/jeps/295" rel="noopener ugc nofollow" target="_blank"> JEP 295 </a>中增加的提前编译。<strong class="is jp"> AOTCompiledMethod </strong>对象包含对封闭类的引用，而<strong class="is jp"> AOTCodeHeap </strong>包含Java对象指针<strong class="is jp"> _oop_got </strong>，由Hotspot修补:</p><figure class="le lf lg lh fd ij"><div class="bz dy l di"><div class="li lj l"/></div></figure><h1 id="49f7" class="ll jr hi bd js lm ln lo jw lp lq lr ka ls lt lu kd lv lw lx kg ly lz ma kj mb bi translated">结论</h1><p id="3ce1" class="pw-post-body-paragraph iq ir hi is b it kl iv iw ix km iz ja jb kn jd je jf ko jh ji jj kp jl jm jn hb bi translated">甚至GC循环的开始——标记根的过程——也相当复杂。大多数时候，人们在谈论Hotspot中的垃圾收集器时，更愿意几乎不提这个事实。它的设计者和实施者决定在global safepoint采取上述一些步骤。这些步骤的持续时间(safe point也是，没有与垃圾收集无关的额外步骤)很大程度上取决于你的代码风格和应用程序的结构。更多的线程和更高的执行堆栈平均深度，更多的局部变量——将使全局安全点变得更长。<br/>在企业部署中，这些数字很容易实现Wildfly等服务器上的所有应用程序共享同一个堆，最多可以有1000个线程，平均深度为20-40帧。</p><p id="0aa9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">例如，在以下OpenJDK版本中:</p><figure class="le lf lg lh fd ij"><div class="bz dy l di"><div class="li lj l"/></div></figure><p id="7589" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">那些JVM选项:</p><figure class="le lf lg lh fd ij"><div class="bz dy l di"><div class="li lj l"/></div></figure><p id="5202" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">运行4个应用程序的单个Wildfly 10.1实例总共有304个Java线程，平均执行堆栈深度约为20帧，我得到了这些结果:</p><p id="a2fe" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">触发:自上次GC以来的时间(300001 ms)大于保证间隔(300000 ms) <br/>【并发复位1222M- &gt; 1222M(1678M)，2.952 ms】<br/><strong class="is jp">【暂停初始化标记，14.636 ms】</strong><br/>【并发标记1222M- &gt; 1222M(1678M)，102.393 ms】<br/><strong class="is jp"/></p><p id="8932" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">触发:自上次GC以来的时间(300001 ms)大于保证间隔(300000 ms) <br/>【并发复位1242M- &gt; 1242M(1257M)，3.026 ms】<br/><strong class="is jp">【暂停初始化标记，12.033 ms】</strong><br/>【并发标记1242M- &gt; 1242M(1257M)，104.882 ms】<br/><strong class="is jp">【暂停结束标记】</strong></p><p id="9081" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如你所见，<strong class="is jp">初始化标记</strong>暂停(包括扫描根集)是这里的主要暂停。</p><p id="03d7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在当前状态下，有进一步改进的空间，可以通过单独停止每个线程来使扫描根集的过程并行进行。在我个人看来，GC周期中暂停的持续时间应该取决于堆的一些内部指标，比如它的大小，或者活动对象的数量。在使用最先进的收集器(如Shenandoah)时，使用mutator同时扫描根集将减少GC周期中最大的STW (stop-the-world)暂停的持续时间。</p><p id="ba83" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">目前，这种STW技术在<strong class="is jp"> Hotspot </strong>和<strong class="is jp"> OpenJ9 </strong>实现中都有使用，但我希望这种情况在未来会有所改变。</p></div></div>    
</body>
</html>