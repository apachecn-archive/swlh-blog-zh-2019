<html>
<head>
<title/>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1/>
<blockquote>原文：<a href="https://medium.com/swlh/simple-rules-to-make-you-effective-with-formal-verification-e283001dc991?source=collection_archive---------59-----------------------#2019-07-01">https://medium.com/swlh/simple-rules-to-make-you-effective-with-formal-verification-e283001dc991?source=collection_archive---------59-----------------------#2019-07-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><p id="c0ec" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated">简单的规则让你有效的进行正式的验证</p><h1 id="b136" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">如何成功进行正式验证？</h1><p id="e7aa" class="pw-post-body-paragraph hg hh hi hj b hk jd hm hn ho je hq hr hs jf hu hv hw jg hy hz ia jh ic id ie hb bi translated">力量在于从小处着手，但要从大处着眼</p><figure class="jj jk jl jm fd jn er es paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="er es ji"><img src="../Images/d5e2450b1d2f347a5b3072e106e83cc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GqJ4BKx19MCjKK2ThgjMTA.png"/></div></div></figure><blockquote class="ju jv jw"><p id="3fdb" class="hg hh jx hj b hk hl hm hn ho hp hq hr jy ht hu hv jz hx hy hz ka ib ic id ie hb bi translated">大约四年前，我做了几次关于围绕正式场合的神话传说的演讲。我做的演讲是关于“关于正式的十个神话”，这是由<a class="ae kb" href="http://www.techdesignforums.com/blog/2015/05/31/ten-myths-formal-verification/" rel="noopener ugc nofollow" target="_blank">技术设计论坛</a>报道的，视频是由<a class="ae kb" href="https://goo.gl/GSuKNh" rel="noopener ugc nofollow" target="_blank"> Cadence </a>在他们的DAC展台录制的。尽管从那时起，正式技术得到了越来越多的采用，但在它被公认为贯穿整个设计和验证的主流技术之前，我们还有很长的路要走。我仍然看到这些神话模糊了最终用户和他们的经理的判断。去年在美国DVCon上，我被邀请参加一个非常有趣的小组，讨论一个人是应该走得更深还是走得更远。我们讨论了一个人是否需要博士学位才能做正式的！好吧，有一点我们都同意，那就是你不知道。你真正需要的是一个训练有素的过程、计划和良好规则的执行的结合。</p></blockquote><p id="2120" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated">十多年来，我和设计验证的工程师们一起从事项目，并且培训了近百名工程师如何在实践中应用可扩展的形式验证技术；其中一些人在苹果、ARM、Diffblue、脸书、Imagination Technologies、Synopsys和OneSpin等公司工作。那次经历坚定了我的信念，对于我们这些已经超越神话传说，正忙于在项目中应用形式化的人来说，有一些基本规则可以帮助你最大限度地利用形式化。</p><p id="f51c" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated">以下是我的前10名。</p><p id="07c1" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated"><strong class="hj kc">规则1:想“什么”，而不是“如何”</strong></p><figure class="jj jk jl jm fd jn er es paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="er es kd"><img src="../Images/0c18c5b54fdd9de5a40214ee36e0c899.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zPSJ3R_EjUpKhl7WTpNnSQ.png"/></div></div><figcaption class="ke kf et er es kg kh bd b be z dx">What you’d like to verify should come first before you worry about how to do it?</figcaption></figure><blockquote class="ju jv jw"><p id="f562" class="hg hh jx hj b hk hl hm hn ho hp hq hr jy ht hu hv jz hx hy hz ka ib ic id ie hb bi translated">这里的“什么”,我指的是需求和规格。需要说明的是，需求并不等同于规范。虽然需求描述的是高层次的意图，但规范应该更加精确，应该包含功能、时间、性能、功率、面积、安全或保障的详细方面。</p></blockquote><p id="412e" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated">我经常注意到工程师们对规范应该是什么样子感到困惑。一份好的规格说明书描述的是设计的<em class="jx">‘什么’</em>，而不是<em class="jx">‘如何’。</em>你必须记住这种差异，否则可能发生的情况是，验证工程师很容易采用设计的“方式”来构建测试平台。</p><p id="0969" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated">这个问题对于形式化来说是严重的，因为大多数实际的形式化验证依赖于使用诸如Verilog/VHDL的设计语言来构建胶合逻辑，并且已经暴露于“如何”而不是“什么”使得验证工程师将设计代码镜像到验证测试台中，导致设计错误被掩盖，因为设计和测试台最终甚至对于错误的情况也彼此匹配。</p><p id="9269" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated">许多复杂的端到端验证需要了解设计的详细微架构，但这并不意味着我们需要知道设计是如何被检测的；我们需要知道的只是输入和输出之间的关系——输入/输出(IO)边界可以在主要输入/输出之间移动到主要输入/内部接口；或内部接口/主要输出。在所有情况下，什么是预期的行为是重要的，而不是它在设计中如何实现。</p><p id="c4b4" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated"><strong class="hj kc">规则2:与设计师交谈，不要阅读RTL </strong></p><figure class="jj jk jl jm fd jn er es paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="er es ji"><img src="../Images/c4e08206cc92bb18174c79c4236838cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SA2_qKi4INit17OBu7AiGA.png"/></div></div><figcaption class="ke kf et er es kg kh bd b be z dx">Talk to the designer, use a whiteboard, and flesh out the missing information</figcaption></figure><blockquote class="ju jv jw"><p id="9173" class="hg hh jx hj b hk hl hm hn ho hp hq hr jy ht hu hv jz hx hy hz ka ib ic id ie hb bi translated">大多数验证工程师认为，如果规范不可用，人们可以很容易地阅读设计代码，以了解设计是什么。不对！</p></blockquote><p id="2837" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated">事实上，即使在今天，当我在项目现场工作时，我也有意识地选择不去阅读设计，而是尽可能地与设计师交谈，或者依赖规范。在最近结束的一项关于<a class="ae kb" href="https://www.axiomise.com/risc-v-formal-verification" rel="noopener ugc nofollow" target="_blank"> RISC-V处理器验证</a>的工作中，我不得不一丝不苟地研究RISC-V规范，即使很多关于设计决策的信息已经丢失。当我碰壁时，我和设计师们争论，以确保我在没有研究设计的情况下完全掌握了被验证的东西。</p><blockquote class="ju jv jw"><p id="0c71" class="hg hh jx hj b hk hl hm hn ho hp hq hr jy ht hu hv jz hx hy hz ka ib ic id ie hb bi translated">然而，设计代码评审是有价值的，并且必须在项目生命周期的某个时间点进行，阅读设计以理解规范不能是在规范不存在或不清楚的情况下的第一步。</p></blockquote><p id="566e" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated">我已经看到许多糟糕的事情发生了，当人们只是把设计代码当作一个好的规范的替代品来阅读的时候。项目的压力通常意味着，一旦你阅读了设计代码，你就要像设计一样建模你的测试平台。这造成了掩盖设计缺陷的共模问题。</p><p id="88a0" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated">另一个更大的问题是，通过带着理解设计的意图阅读设计代码，而不是阅读设计来审查它(当你处于挑战模式时)，你很可能同意甚至设计的破损的一面，掩盖意图中的错误，并掩盖验证错误。</p><blockquote class="ju jv jw"><p id="d5a6" class="hg hh jx hj b hk hl hm hn ho hp hq hr jy ht hu hv jz hx hy hz ka ib ic id ie hb bi translated">作为验证工程师，一个人必须获得关于该领域的独立知识，并挑战设计者打破设计。一个好的测试平台的目标是能够破坏设计，如果你不能破坏它，那么你必须努力证明它能正确工作，这只有通过形式验证才有可能。</p></blockquote><p id="bae7" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated"><strong class="hj kc">规则3:分清主次，选择你的战斗</strong></p><figure class="jj jk jl jm fd jn er es paragraph-image"><div class="er es ki"><img src="../Images/12801743144ed942e4bd073cb0b082e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/format:webp/1*r-DGjDypMY_eXLY9d-iFWA.png"/></div><figcaption class="ke kf et er es kg kh bd b be z dx">Pick your battles wisely, prioritise what’s important</figcaption></figure><blockquote class="ju jv jw"><p id="20f1" class="hg hh jx hj b hk hl hm hn ho hp hq hr jy ht hu hv jz hx hy hz ka ib ic id ie hb bi translated">当我说正确处理你的优先事项时，我的意思是你必须根据你的团队所拥有的技能，在已知风险的背景下，思考你在你所拥有的时间内想要通过正式的方式实现什么。验证就是风险评估，正式的也没什么区别。</p></blockquote><p id="dca4" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated">是的，最先进的正式工具已经足够成熟，当与可靠的方法相结合时，可以用于几乎所有类型设计的端到端验证。但痛苦的事实是，我们必须选择我们的战斗。</p><p id="5aae" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated">一个人应该从设计的一开始就使用形式化，但是你必须有一个使用形式化的计划来追踪那些用模拟很难捕捉到的错误。我看到过一些很好的项目例子，这些项目使用跨IPs的断言来部署接口检查，以模拟和正式的方式进行测试。然而，这也是有代价的，而且可能无法解决所有问题。</p><p id="f7cf" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated">部署正式的来捕捉死锁、活锁和其他难以用模拟捕捉的假象可能更好。</p><blockquote class="ju jv jw"><p id="ba3c" class="hg hh jx hj b hk hl hm hn ho hp hq hr jy ht hu hv jz hx hy hz ka ib ic id ie hb bi translated">这里正确的方法是把正式的和模拟的结合起来，这样你就可以得到两个世界的最好的东西。然而在模拟中，刺激的产生是最具挑战性的任务，而在正式的模拟中，你可以免费得到它。制定正确的策略来部署满足您需求的正式。</p></blockquote><p id="1edb" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated"><strong class="hj kc">规则#4:计划、衡量和跟踪</strong></p><figure class="jj jk jl jm fd jn er es paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="er es ji"><img src="../Images/67bff9bce99980e8d0f3135d0d10d335.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o9BF8YM_4ybkWvjU_JBaCA.png"/></div></div><figcaption class="ke kf et er es kg kh bd b be z dx">Plan, measure and track</figcaption></figure><blockquote class="ju jv jw"><p id="3625" class="hg hh jx hj b hk hl hm hn ho hp hq hr jy ht hu hv jz hx hy hz ka ib ic id ie hb bi translated">大型项目的现代形式验证不仅仅是写几个断言或运行你最喜欢的供应商的自动化应用程序。使用适当的验证计划工具，并设计清晰的验证策略文档。并让您设计人员和验证领导及时审查该策略，以确保每个人都在同一页面上。</p></blockquote><p id="5637" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated">跟踪正式验证运行的进度对于验证规划者来说是非常可行的，一些EDA供应商提供了这样的解决方案。这个练习需要一系列的计划、记录、执行测试平台，然后将它与覆盖率结果集成在一起，给你一个已经实现的端到端视图。我不会骗你，但我看到拥有伟大技术的大组织忘记了这个简单的规则。</p><p id="86b1" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated"><strong class="hj kc">规则5:了解你的工具，正确使用它</strong></p><figure class="jj jk jl jm fd jn er es paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="er es ji"><img src="../Images/71d60409846dc37809e272a02d023dbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ExyxEhtkgkhlHIxQpSljFQ.png"/></div></div><figcaption class="ke kf et er es kg kh bd b be z dx">Understand how to use your tool properly</figcaption></figure><blockquote class="ju jv jw"><p id="b0dd" class="hg hh jx hj b hk hl hm hn ho hp hq hr jy ht hu hv jz hx hy hz ka ib ic id ie hb bi translated">现在开始使用一个正式的工具是非常容易的，但是知道如何足够详细地利用它是另一回事。</p></blockquote><p id="0493" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated">例如，编译、精心制作和运行一个工具并不需要很长时间，只要你不会遇到VHDL和SystemVerilog的多语言问题。然而，如果你对你的工具如何工作以及如何充分利用它有更多的了解，这是值得的。</p><p id="1c39" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated">以下是一些你应该了解的事情的例子:</p><ul class=""><li id="9c49" class="kj kk hi hj b hk hl ho hp hs kl hw km ia kn ie ko kp kq kr bi translated">不同的错误信息意味着什么？</li><li id="83bf" class="kj kk hi hj b hk ks ho kt hs ku hw kv ia kw ie ko kp kq kr bi translated">你如何设置一个设计来最大限度地利用验证引擎？</li><li id="591a" class="kj kk hi hj b hk ks ho kt hs ku hw kv ia kw ie ko kp kq kr bi translated">如何在不同的会话中有效地聚集属性以最大化吞吐量？</li><li id="f728" class="kj kk hi hj b hk ks ho kt hs ku hw kv ia kw ie ko kp kq kr bi translated">当你得到不确定的证据时，你如何决定用这个工具做什么？</li><li id="48b3" class="kj kk hi hj b hk ks ho kt hs ku hw kv ia kw ie ko kp kq kr bi translated">重要的是，你知道你的工具和应用能做什么，不能做什么吗？</li></ul><blockquote class="ju jv jw"><p id="59b3" class="hg hh jx hj b hk hl hm hn ho hp hq hr jy ht hu hv jz hx hy hz ka ib ic id ie hb bi translated">几年前，我正在使用一个声称具有死锁检测功能的工具。当我仔细检查它时，它似乎没有那个特征。原来供应商使用的死锁定义和我的不一样。寓意:不要害怕向你的供应商提问。大多数会提供有用的答案。没有问题是坏问题。</p></blockquote><p id="377c" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated">规则6:从小处着手，大处着眼</p><figure class="jj jk jl jm fd jn er es paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="er es ji"><img src="../Images/d5e2450b1d2f347a5b3072e106e83cc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GqJ4BKx19MCjKK2ThgjMTA.png"/></div></div><figcaption class="ke kf et er es kg kh bd b be z dx">Start with a small design, but plan for the overall verification challenge</figcaption></figure><blockquote class="ju jv jw"><p id="5e3e" class="hg hh jx hj b hk hl hm hn ho hp hq hr jy ht hu hv jz hx hy hz ka ib ic id ie hb bi translated">我见过许多工程师，包括形式专家，他们热衷于诸如黑盒或切割点等众所周知的形式验证缩减策略。然而，这并不是减少问题的最佳起点。如果被验证的设计非常接近原始设计，通常编译一个较小的代表性设计将有助于您获得更大的收益。这就是我所说的“从小处着手，大处着眼”这个想法是你得到了原始大设计的快照，但是你得到了一个更小的状态空间。</p></blockquote><p id="6f26" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated">当应用在正确的环境中时，黑盒和切割点确实非常有用。但是它们会产生比你想象的更多的问题。例如，如果做得过分，他们可以在你真正需要的时候切断设计逻辑，导致约束不足和虚假的断言失败。</p><h2 id="dbad" class="kx ig hi bd ih ky kz la il lb lc ld ip hs le lf it hw lg lh ix ia li lj jb lk bi translated">使用约束来缩小或扩大您可达到的设计空间</h2><p id="7715" class="pw-post-body-paragraph hg hh hi hj b hk jd hm hn ho je hq hr hs jf hu hv hw jg hy hz ia jh ic id ie hb bi translated">约束不足既有好处也有坏处。当你在探索失败的环境中完成时，这可能是一个非常强大的技术。但是大多数情况下，这被认为是一种不好的做法，因为它会导致在调试虚假故障上浪费大量时间。</p><p id="bc7a" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated">过度约束被认为是危险的，因为它导致合法输入激励被正式工具阻塞，因此该工具不能搜索被过度约束屏蔽设计中的缺陷阻塞的状态空间。然而，在某些情况下，过度约束也是有益的。这种情况的一个例子是，当验证工程师有失败的跟踪，而设计者不相信跟踪代表有效的设计缺陷。发生这种情况是因为波形中有一些信号处于设计者认为无效的状态。通过有选择地应用约束并重新运行正式运行，人们能够获得对设计者来说看起来很真实的轨迹，使他相信这是一个设计缺陷。一旦设计错误被修复，人们必须记住在将验证标记为完成之前最终放松这些过度约束。</p><p id="814d" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated">还有其他众所周知的归约技术，如使用归纳、抽象和不变量，可以帮助将大的状态空间搜索分解为非常小的状态空间搜索，提供详尽的证明和非常快速的bug搜索能力，但它们将是另一天的主题。</p><blockquote class="ju jv jw"><p id="b1f7" class="hg hh jx hj b hk hl hm hn ho hp hq hr jy ht hu hv jz hx hy hz ka ib ic id ie hb bi translated"><a class="ae kb" href="https://www.axiomise.com/love-formal" rel="noopener ugc nofollow" target="_blank">最近，</a>我报告说在10亿门的设计中发现了bug(大约。3.34亿+ flops)使用端到端检查和抽象的组合。一些发现错误的属性将整个设计置于影响范围内。</p></blockquote><p id="80d8" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated"><strong class="hj kc">规则7:利用你的重置</strong></p><figure class="jj jk jl jm fd jn er es paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="er es ll"><img src="../Images/92fed461b2313b94822bcaf75278ed7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8vNNGHYp02sreQbMew55Og.png"/></div></div><figcaption class="ke kf et er es kg kh bd b be z dx">Resets play a vital role during verification especially in the context of low-power designs</figcaption></figure><blockquote class="ju jv jw"><p id="9928" class="hg hh jx hj b hk hl hm hn ho hp hq hr jy ht hu hv jz hx hy hz ka ib ic id ie hb bi translated">大多数设计都有一个复位引脚，但有多个复位引脚的设计并不少见，尤其是具有热复位和冷复位的低功耗设计。</p></blockquote><p id="cd5c" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated">大多数正式工具都善于检测复位引脚，并在正确的持续时间内应用复位。然而，控制复位的持续时间是验证工程师应该知道的事情，因为复位序列的应用需要正确的时钟周期数。随着重置，事情变得有趣多了，因为大多数检查器在重置时被禁用，以避免虚假的失败(例如，使用SystemVerilog断言中的<em class="jx"> disable iff </em>构造)。</p><p id="e2d2" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated">然而，在热复位期间，一些检查可能需要激活，这是需要记住的其他事情。此外，在许多情况下，工具可以通过不应用重置来达到有趣的状态，这通常会导致更快地发现一些错误。通过不应用复位，该工具可以自由地探索通常在复位可到达的状态空间之外的状态，使得该工具呈现任何开始状态。这可能会导致工具选择一个开始状态，该状态距离真正的bug只有几个时钟周期。然而，这种技术必须小心使用，因为它可能导致达到虚假的状态，否则是无法达到的，造成一种您发现了一个错误的错觉，这可能不是一个真正的错误。尽管如此，不要害怕在验证过程中使用重置设置。</p><p id="aaba" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated"><strong class="hj kc">规则8:丰富的配置</strong></p><figure class="jj jk jl jm fd jn er es paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="er es lm"><img src="../Images/c4015884d2658580fd07697801520d0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fR3RWR-X8dBMxru7O3JeEg.png"/></div></div><figcaption class="ke kf et er es kg kh bd b be z dx">Verifying designs with hundreds of configurations is a common phenomenon these days</figcaption></figure><blockquote class="ju jv jw"><p id="d9b5" class="hg hh jx hj b hk hl hm hn ho hp hq hr jy ht hu hv jz hx hy hz ka ib ic id ie hb bi translated">大多数IP设计都有很强的可重构性。因此，对所有配置进行彻底检查是极其昂贵的。</p></blockquote><p id="fbe1" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated">没有一种商用工具可以检查所有配置，而不必为每个配置重新编译设计，这会浪费大量时间。在这种情况下，最好的办法是获取最常用的配置，并随机抽取少量配置来测试设计。如果EDA工具供应商提供一种灵活的方法来一次验证多个配置，那就太好了。</p><p id="bc71" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated"><strong class="hj kc">规则9:不要让覆盖率碰运气</strong></p><figure class="jj jk jl jm fd jn er es paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="er es ln"><img src="../Images/f791ba2ff013615971c769831b418cb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eDfl1CBc3IsNgtjRhlQZ5Q.png"/></div></div><figcaption class="ke kf et er es kg kh bd b be z dx">Don’t leave coverage for chance, start measuring it from the first hour of formal verification</figcaption></figure><blockquote class="ju jv jw"><p id="091a" class="hg hh jx hj b hk hl hm hn ho hp hq hr jy ht hu hv jz hx hy hz ka ib ic id ie hb bi translated">几年来，这个话题一直是我的心头好。今天，基于不同EDA供应商提供的一系列不同技术，可以实现形式化的覆盖。它有多种口味。</p></blockquote><p id="1183" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated">从结构化覆盖开始，人们探索设计实现的可达性条件，并寻找死代码和不可达状态。然而，当覆盖技术的组合使用非常详细的覆盖分析(探索证据界限、影响锥分析和基于变异的覆盖)来评估验证环境的质量时，非常需要覆盖，以便您可以正式签署验证。每种技术都提供了一些关于功能验证检查所涵盖的内容和不涵盖的内容的见解。我在实践中使用了所有这些技术，在工具可以向您报告的内容与运行时间和内存占用之间必须做出权衡。</p><blockquote class="ju jv jw"><p id="96a9" class="hg hh jx hj b hk hl hm hn ho hp hq hr jy ht hu hv jz hx hy hz ka ib ic id ie hb bi translated">尽管证明核心和影响锥分析代表了一个很好的起点，但是您不能完全根据它们来签署正式验证。如果你现在这样做，你可能会错过真正的设计错误。</p><p id="dff3" class="hg hh jx hj b hk hl hm hn ho hp hq hr jy ht hu hv jz hx hy hz ka ib ic id ie hb bi translated">我是突变报道的忠实粉丝！</p></blockquote><p id="bb8e" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated">规则10:复习，复习，复习</p><figure class="jj jk jl jm fd jn er es paragraph-image"><div class="er es lo"><img src="../Images/38664b2707a7b47756e7905873ea6fd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1334/format:webp/1*JScwl_ilUh3faRPa-iswGA.png"/></div><figcaption class="ke kf et er es kg kh bd b be z dx">Review, review, review</figcaption></figure><blockquote class="ju jv jw"><p id="cdb6" class="hg hh jx hj b hk hl hm hn ho hp hq hr jy ht hu hv jz hx hy hz ka ib ic id ie hb bi translated">任何最佳实践策略都不能排除彻底的设计和验证审查。</p></blockquote><p id="24f3" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated">这当然也适用于正式场合。但是，审查需要:</p><ul class=""><li id="93bf" class="kj kk hi hj b hk hl ho hp hs kl hw km ia kn ie ko kp kq kr bi translated">一致。</li><li id="a81f" class="kj kk hi hj b hk ks ho kt hs ku hw kv ia kw ie ko kp kq kr bi translated">定期应用。</li><li id="bdd8" class="kj kk hi hj b hk ks ho kt hs ku hw kv ia kw ie ko kp kq kr bi translated">根据DV团队制定的一套指南并基于验证的基本原则进行。</li><li id="8779" class="kj kk hi hj b hk ks ho kt hs ku hw kv ia kw ie ko kp kq kr bi translated">签准——由独立工程师签署，与验证的具体计划和执行没有任何关系，因此不会出现共模问题。</li></ul><p id="dd1b" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated">我希望你会发现这些规则在你的日常工作中很有用。请务必让我知道您是否同意或不同意它们是否有用。</p></div></div>    
</body>
</html>