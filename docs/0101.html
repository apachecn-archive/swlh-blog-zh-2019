<html>
<head>
<title>Working with Geolocation and Geocoding in Flutter (And Integration with Maps)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Flutter中使用地理定位和地理编码(以及与地图的集成)</h1>
<blockquote>原文：<a href="https://medium.com/swlh/working-with-geolocation-and-geocoding-in-flutter-and-integration-with-maps-16fb0bc35ede?source=collection_archive---------0-----------------------#2019-01-07">https://medium.com/swlh/working-with-geolocation-and-geocoding-in-flutter-and-integration-with-maps-16fb0bc35ede?source=collection_archive---------0-----------------------#2019-01-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="dda2" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">使用位置并将其与谷歌地图集成的指南</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/9c75f872c60276ec33f5adaebea48a5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oD-PH33r1alVLhaA99gJvg.png"/></div></div></figure><p id="4893" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi kf translated"><span class="l kg kh ki bm kj kk kl km kn di"> W </span>处理用户的位置是许多应用程序需要的一项常见任务，然而在应用程序中实现一个有效解决方案的步骤往往令人困惑，并且需要设置太多样板文件。大多数Flutter软件包<strong class="jl ko">提取了大部分或者所有需要的样板文件</strong>，直接给用户提供了最佳的解决方案，减少了处理的麻烦。这通常意味着通过抽象失去了一些细粒度的控制，但是大多数时候并不需要。</p><p id="227e" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">你可以浏览一个在原生android 中实现定位的<a class="ae kp" href="https://developer.android.com/guide/topics/location/strategies" rel="noopener ugc nofollow" target="_blank">教程，看看向仅仅想要用户的位置或想要跟踪它的应用程序开发者呈现的大量<strong class="jl ko">通常不需要的</strong>信息。</a></p><p id="8378" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">今天，我们将通过使用两个不同的插件来实现Android和iOS的获取位置、位置跟踪和地理编码，这两个插件为我们提供了对底层API的不同程度的控制，然后查看地图位置的实现，我们将使用地图上的标记来跟踪用户。</p><p id="c756" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">让我们开始吧。</p><h1 id="aaef" class="kq kr hi bd ks kt ku kv kw kx ky kz la io lb ip lc ir ld is le iu lf iv lg lh bi translated">插件1: <a class="ae kp" href="https://pub.dartlang.org/packages/location" rel="noopener ugc nofollow" target="_blank">“位置”</a></h1><p id="02d9" class="pw-post-body-paragraph jj jk hi jl b jm li ij jo jp lj im jr js lk ju jv jw ll jy jz ka lm kc kd ke hb bi translated">“位置”插件是获取和跟踪用户位置的最简单方式，没有任何样板代码的麻烦。</p><p id="8ef4" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">设置非常简单:</p><ol class=""><li id="7b17" class="ln lo hi jl b jm jn jp jq js lp jw lq ka lr ke ls lt lu lv bi translated">将插件添加到<code class="du lw lx ly lz b">pubspec.yaml</code></li></ol><pre class="iy iz ja jb fd ma lz mb mc aw md bi"><span id="2f7b" class="me kr hi lz b fi mf mg l mh mi"><strong class="lz ko">dependencies:<br/>  location: </strong>^1.4.1</span></pre><p id="d5e8" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">2.向Android清单添加权限:</p><pre class="iy iz ja jb fd ma lz mb mc aw md bi"><span id="9b8e" class="me kr hi lz b fi mf mg l mh mi">&lt;<strong class="lz ko">uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" </strong>/&gt;</span></pre><p id="4775" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">3.向iOS添加权限<code class="du lw lx ly lz b">Info.plist</code></p><pre class="iy iz ja jb fd ma lz mb mc aw md bi"><span id="d577" class="me kr hi lz b fi mf mg l mh mi">&lt;key&gt;NSLocationAlwaysUsageDescription&lt;/key&gt;<br/>&lt;string&gt;Needed to access location&lt;/string&gt;<br/>&lt;key&gt;NSLocationWhenInUseUsageDescription&lt;/key&gt;<br/>&lt;string&gt;Needed to access location&lt;/string&gt;</span></pre><p id="d553" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">你就完了。</p><p id="f1a4" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在Android 6.0+中，我们需要在运行时请求访问位置，这个<strong class="jl ko">包自己处理</strong>。</p><h2 id="3129" class="me kr hi bd ks mj mk ml kw mm mn mo la js mp mq lc jw mr ms le ka mt mu lg mv bi translated">获取一次性位置</h2><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mw"><img src="../Images/33f0faa987c13248cc288736227d2e8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NVEPHFXN0wUpOBKJi9V2KQ.png"/></div></div></figure><p id="3b19" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">它让我们得到两样东西:</p><ol class=""><li id="2436" class="ln lo hi jl b jm jn jp jq js lp jw lq ka lr ke ls lt lu lv bi translated">用户的一次性位置</li><li id="acd5" class="ln lo hi jl b jm mx jp my js mz jw na ka nb ke ls lt lu lv bi translated">允许我们监听用户位置的数据流。</li></ol><p id="3fe6" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">让我们创建一个简单的应用程序，像上面一样一次性获得用户的位置。</p><p id="9cc9" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">正如我们所讨论的，这个包不需要太多的设置，代码相当简单。</p><p id="e269" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">首先，简单地初始化一个位置对象。</p><pre class="iy iz ja jb fd ma lz mb mc aw md bi"><span id="379b" class="me kr hi lz b fi mf mg l mh mi"><strong class="lz ko">var location </strong>= <strong class="lz ko">new </strong>Location();</span></pre><p id="c255" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><code class="du lw lx ly lz b">location</code>不是用户本身的位置而是帮助我们得到它的一个类。</p><p id="33cc" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">位置以地图的形式返回，带有“纬度”、“经度”等关键字。</p><pre class="iy iz ja jb fd ma lz mb mc aw md bi"><span id="c56b" class="me kr hi lz b fi mf mg l mh mi">Map&lt;String, double&gt; <strong class="lz ko">userLocation</strong>;</span></pre><p id="9923" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">最后，获取位置非常简单:</p><pre class="iy iz ja jb fd ma lz mb mc aw md bi"><span id="f2ce" class="me kr hi lz b fi mf mg l mh mi">userLocation = <strong class="lz ko">await location</strong>.getLocation();</span></pre><p id="4a90" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">就是这样。</p><p id="81ca" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">完整的代码:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="nc nd l"/></div></figure><p id="e8c1" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在这里，我们得到了纬度和经度。其他可用因素包括:</p><pre class="iy iz ja jb fd ma lz mb mc aw md bi"><span id="7dda" class="me kr hi lz b fi mf mg l mh mi">  currentLocation[<strong class="lz ko">"latitude"</strong>];<br/>  currentLocation[<strong class="lz ko">"longitude"</strong>];<br/>  currentLocation[<strong class="lz ko">"accuracy"</strong>];<br/>  currentLocation[<strong class="lz ko">"altitude"</strong>];<br/>  currentLocation[<strong class="lz ko">"speed"</strong>];<br/>  currentLocation[<strong class="lz ko">"speed_accuracy"</strong>]; //Not for iOS</span></pre><h2 id="d51f" class="me kr hi bd ks mj mk ml kw mm mn mo la js mp mq lc jw mr ms le ka mt mu lg mv bi translated">收听位置更新</h2><p id="fb47" class="pw-post-body-paragraph jj jk hi jl b jm li ij jo jp lj im jr js lk ju jv jw ll jy jz ka lm kc kd ke hb bi translated">监听位置更新与获取位置没有太大区别，我们只是使用插件提供的流对象来监听更新。</p><pre class="iy iz ja jb fd ma lz mb mc aw md bi"><span id="78d8" class="me kr hi lz b fi mf mg l mh mi">location.onLocationChanged().listen((Map&lt;String,double&gt; currentLocation) {<br/>  print(currentLocation[<strong class="lz ko">"latitude"</strong>]);<br/>  print(currentLocation[<strong class="lz ko">"longitude"</strong>]);<br/>  print(currentLocation[<strong class="lz ko">"accuracy"</strong>]);<br/>  print(currentLocation[<strong class="lz ko">"altitude"</strong>]);<br/>  print(currentLocation[<strong class="lz ko">"speed"</strong>]);<br/>  print(currentLocation[<strong class="lz ko">"speed_accuracy"</strong>]); <em class="ne"><br/></em>});</span></pre><p id="ea27" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这方面的一个例子是:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="nc nd l"/></div></figure><p id="c5b9" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">它给出了一个与第一个例子相似的页面，但是这一次，我们监听位置。</p><p id="1e73" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这个插件使用起来很简单，不需要太多的设置和控制，使用和意图都很简单。接下来，我们将看到另一个对所涉及的API进行更多控制并且允许地理编码的工具。</p><h1 id="7c68" class="kq kr hi bd ks kt ku kv kw kx ky kz la io lb ip lc ir ld is le iu lf iv lg lh bi translated">插件2:<a class="ae kp" href="https://pub.dartlang.org/packages/geolocator" rel="noopener ugc nofollow" target="_blank">‘地理定位器’</a></h1><h2 id="fa77" class="me kr hi bd ks mj mk ml kw mm mn mo la js mp mq lc jw mr ms le ka mt mu lg mv bi translated">设置</h2><p id="f7f1" class="pw-post-body-paragraph jj jk hi jl b jm li ij jo jp lj im jr js lk ju jv jw ll jy jz ka lm kc kd ke hb bi translated">这个插件的设置和位置差不多。如果您也计划使用粗略定位，请添加</p><pre class="iy iz ja jb fd ma lz mb mc aw md bi"><span id="39ce" class="me kr hi lz b fi mf mg l mh mi">&lt;<strong class="lz ko">uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" </strong>/&gt;</span></pre><p id="a190" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">到<code class="du lw lx ly lz b">AndroidManifest.xml</code>。</p><p id="7be4" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">首先，我们将使用这个插件完成同样的两个任务，这两个任务大致相同:</p><h2 id="90e2" class="me kr hi bd ks mj mk ml kw mm mn mo la js mp mq lc jw mr ms le ka mt mu lg mv bi translated">获取位置一次</h2><p id="1e16" class="pw-post-body-paragraph jj jk hi jl b jm li ij jo jp lj im jr js lk ju jv jw ll jy jz ka lm kc kd ke hb bi translated">使用<code class="du lw lx ly lz b">Geolocator</code>对象代替<code class="du lw lx ly lz b">Location</code>，并且代替<code class="du lw lx ly lz b">Map&lt;String,double&gt;</code>，我们得到一个<code class="du lw lx ly lz b">Position</code>对象。</p><pre class="iy iz ja jb fd ma lz mb mc aw md bi"><span id="6e80" class="me kr hi lz b fi mf mg l mh mi">Geolocator <strong class="lz ko">geolocator </strong>= Geolocator();<br/><br/>Position <strong class="lz ko">userLocation</strong>;</span></pre><p id="5624" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们这样做是为了拍摄外景:</p><pre class="iy iz ja jb fd ma lz mb mc aw md bi"><span id="354a" class="me kr hi lz b fi mf mg l mh mi">currentLocation = <strong class="lz ko">await geolocator</strong>.getCurrentPosition(<br/>    desiredAccuracy: LocationAccuracy.<strong class="lz ko">best</strong>);</span></pre><p id="105d" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在这里，我们也可以根据我们需要的精度来设置定位精度。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="nc nd l"/></div></figure><h2 id="cf9b" class="me kr hi bd ks mj mk ml kw mm mn mo la js mp mq lc jw mr ms le ka mt mu lg mv bi translated">获取位置更新</h2><p id="4d8a" class="pw-post-body-paragraph jj jk hi jl b jm li ij jo jp lj im jr js lk ju jv jw ll jy jz ka lm kc kd ke hb bi translated">更新类似于“位置”包，但具有增强的选项。</p><pre class="iy iz ja jb fd ma lz mb mc aw md bi"><span id="8ede" class="me kr hi lz b fi mf mg l mh mi"><strong class="lz ko">geolocator</strong>.getPositionStream().listen((position) {<br/>  <em class="ne">// Do something here<br/></em>});</span></pre><p id="d693" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们可以设置精确度，更新的时间间隔，是否要强制使用Android位置管理器等等。</p><pre class="iy iz ja jb fd ma lz mb mc aw md bi"><span id="78cd" class="me kr hi lz b fi mf mg l mh mi"><strong class="lz ko">geolocator<br/>    </strong>.getPositionStream(LocationOptions(<br/>        accuracy: LocationAccuracy.<strong class="lz ko">best</strong>, timeInterval: 1000))<br/>    .listen((position) {<br/>  <em class="ne">// Do something here<br/></em>});</span></pre><h2 id="1243" class="me kr hi bd ks mj mk ml kw mm mn mo la js mp mq lc jw mr ms le ka mt mu lg mv bi translated">使用地理编码</h2><p id="25da" class="pw-post-body-paragraph jj jk hi jl b jm li ij jo jp lj im jr js lk ju jv jw ll jy jz ka lm kc kd ke hb bi translated">地理编码本质上是<strong class="jl ko">获取地址的物理地图坐标和细节</strong>的过程。</p><pre class="iy iz ja jb fd ma lz mb mc aw md bi"><span id="e3ee" class="me kr hi lz b fi mf mg l mh mi">List&lt;Placemark&gt; placemark = await Geolocator().placemarkFromAddress(<strong class="lz ko">"Gronausestraat 710, Enschede"</strong>);</span></pre><p id="3ed8" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">您可以通过以下方式获得该地点的所有详细信息:</p><pre class="iy iz ja jb fd ma lz mb mc aw md bi"><span id="de8f" class="me kr hi lz b fi mf mg l mh mi">print(placemark[0].<strong class="lz ko">country</strong>);<br/>print(placemark[0].<strong class="lz ko">position</strong>);<br/>print(placemark[0].<strong class="lz ko">locality</strong>);<br/>print(placemark[0].<strong class="lz ko">administrativeArea</strong>);<br/>print(placemark[0].<strong class="lz ko">postalCode</strong>);<br/>print(placemark[0].<strong class="lz ko">name</strong>);<br/>print(placemark[0].<strong class="lz ko">subAdministratieArea</strong>);<br/>print(placemark[0].<strong class="lz ko">isoCountryCode</strong>);<br/>print(placemark[0].<strong class="lz ko">subLocality</strong>);<br/>print(placemark[0].<strong class="lz ko">subThoroughfare</strong>);<br/>print(placemark[0].<strong class="lz ko">thoroughfare</strong>);</span></pre><p id="41e0" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们也可以从坐标中得到一个地方的细节:</p><pre class="iy iz ja jb fd ma lz mb mc aw md bi"><span id="c48b" class="me kr hi lz b fi mf mg l mh mi">List&lt;Placemark&gt; placemark = <strong class="lz ko">await </strong>Geolocator().placemarkFromCoordinates(52.2165157, 6.9437819);</span></pre><h2 id="4b6d" class="me kr hi bd ks mj mk ml kw mm mn mo la js mp mq lc jw mr ms le ka mt mu lg mv bi translated">获取坐标之间的距离</h2><p id="23be" class="pw-post-body-paragraph jj jk hi jl b jm li ij jo jp lj im jr js lk ju jv jw ll jy jz ka lm kc kd ke hb bi translated">该插件还允许我们<strong class="jl ko">计算两个坐标</strong>之间的距离，如下所示:</p><pre class="iy iz ja jb fd ma lz mb mc aw md bi"><span id="466d" class="me kr hi lz b fi mf mg l mh mi">double distanceInMeters = <strong class="lz ko">await </strong>Geolocator().distanceBetween(52.2165157, 6.9437819, 52.3546274, 4.8285838);</span></pre><h1 id="a4be" class="kq kr hi bd ks kt ku kv kw kx ky kz la io lb ip lc ir ld is le iu lf iv lg lh bi translated">将位置更新与谷歌地图集成</h1><p id="5941" class="pw-post-body-paragraph jj jk hi jl b jm li ij jo jp lj im jr js lk ju jv jw ll jy jz ka lm kc kd ke hb bi translated">为了将Google Maps与位置更新整合，我们需要使用<a class="ae kp" href="https://pub.dartlang.org/packages/google_maps_flutter" rel="noopener ugc nofollow" target="_blank"> google_maps_flutter </a>包和您选择的位置插件。</p><p id="07d1" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">现在让我们只使用“位置”包。</p><p id="06cf" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl ko">这一部分的前身是我的文章《探索Google Maps in Flutter 》,我强烈推荐你用它在你的应用程序中设置地图。</strong></p><div class="nf ng ez fb nh ni"><a rel="noopener follow" target="_blank" href="/flutter-community/exploring-google-maps-in-flutter-8a86d3783d24"><div class="nj ab dw"><div class="nk ab nl cl cj nm"><h2 class="hj b fi z dy nn ea eb no ed ef hh bi translated">在颤动中探索谷歌地图</h2><div class="np l"><h3 class="bd b fi z dy nn ea eb no ed ef dx translated">在Flutter应用中添加官方支持的谷歌地图</h3></div><div class="nq l"><p class="bd b fp z dy nn ea eb no ed ef dx translated">medium.com</p></div></div><div class="nr l"><div class="ns l nt nu nv nr nw jh ni"/></div></div></a></div><p id="a3da" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">要将地图与位置跟踪集成，我们只需结合使用这两个插件。</p><p id="e88c" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">让我们在用户改变位置时移动一个标记。</p><p id="70a5" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">首先，我们创建我们的<code class="du lw lx ly lz b">MapController</code>和<code class="du lw lx ly lz b">Location</code>对象来操作地图和位置。(当map初始化时分配<code class="du lw lx ly lz b">mapController</code>，如上一篇文章所述)</p><pre class="iy iz ja jb fd ma lz mb mc aw md bi"><span id="cc1e" class="me kr hi lz b fi mf mg l mh mi">GoogleMapController <strong class="lz ko">mapController</strong>;<br/>Location <strong class="lz ko">location </strong>= Location();</span></pre><p id="d0fd" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">接下来，我们添加一个标记来存储当前标记:</p><pre class="iy iz ja jb fd ma lz mb mc aw md bi"><span id="4e1e" class="me kr hi lz b fi mf mg l mh mi">Marker <strong class="lz ko">marker</strong>;</span></pre><p id="8080" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">现在，我们收听位置更新。</p><pre class="iy iz ja jb fd ma lz mb mc aw md bi"><span id="705b" class="me kr hi lz b fi mf mg l mh mi"><strong class="lz ko">location</strong>.onLocationChanged().listen((location) <strong class="lz ko">async </strong>{<br/>  // Do something here<br/>});</span></pre><p id="fcc1" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">位置更新时，我们将这样移动标记:</p><ol class=""><li id="0fda" class="ln lo hi jl b jm jn jp jq js lp jw lq ka lr ke ls lt lu lv bi translated">如果不为空，则移除当前标记，因为现在有一个新的位置需要它。</li><li id="66ce" class="ln lo hi jl b jm mx jp my js mz jw na ka nb ke ls lt lu lv bi translated">添加经纬度标记。</li><li id="6164" class="ln lo hi jl b jm mx jp my js mz jw na ka nb ke ls lt lu lv bi translated">将相机移动到新的标记位置，并设置其他特征，如缩放、方位和倾斜。(GMaps文章中给出了详细信息)</li></ol><pre class="iy iz ja jb fd ma lz mb mc aw md bi"><span id="ba68" class="me kr hi lz b fi mf mg l mh mi"><strong class="lz ko">location</strong>.onLocationChanged().listen((location) <strong class="lz ko">async </strong>{<br/>  <em class="ne">// Step 1<br/>  </em><strong class="lz ko">if</strong>(<strong class="lz ko">marker </strong>!= <strong class="lz ko">null</strong>) {<br/>    <strong class="lz ko">mapController</strong>.removeMarker(<strong class="lz ko">marker</strong>);<br/>  }<br/>  <em class="ne">// Step 2<br/>  </em><strong class="lz ko">marker </strong>= <strong class="lz ko">await mapController</strong>?.addMarker(MarkerOptions(<br/>    position: LatLng(location[<strong class="lz ko">"latitude"</strong>], location[<strong class="lz ko">"longitude"</strong>]),<br/>  ));<br/>  <em class="ne">//Step 3<br/>  </em><strong class="lz ko">mapController</strong>?.moveCamera(<br/>    CameraUpdate.<em class="ne">newCameraPosition</em>(<br/>      CameraPosition(<br/>        target: LatLng(<br/>          location[<strong class="lz ko">"latitude"</strong>],<br/>          location[<strong class="lz ko">"longitude"</strong>],<br/>        ),<br/>        zoom: 20.0,<br/>      ),<br/>    ),<br/>  );<br/>});</span></pre><p id="a300" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">现在，当用户移动时，标记将更新位置！</p><p id="c49c" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">下面是完整的演示页面代码:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="nc nd l"/></div></figure><blockquote class="nx"><p id="cf9c" class="ny nz hi hj oa ob oc od oe of og ke dx translated">本文到此为止！我希望你喜欢它，如果你喜欢，留下一些掌声。请关注我，获取更多精彩的文章，并评论您对本文的任何反馈。</p></blockquote><blockquote class="oh oi oj"><p id="8ac7" class="jj jk ne jl b jm ok ij jo jp ol im jr om on ju jv oo op jy jz oq or kc kd ke hb bi translated"><strong class="jl ko">注</strong>:我已经为Flutter widgets做了一段时间的深度潜水系列，如果你以前没看过，请读一下。以下是该系列的几篇文章。</p></blockquote><div class="nf ng ez fb nh ni"><a rel="noopener follow" target="_blank" href="/flutter-community/flutter-listview-and-scrollphysics-a-detailed-look-7f0912df2754"><div class="nj ab dw"><div class="nk ab nl cl cj nm"><h2 class="hj b fi z dy nn ea eb no ed ef hh bi translated">Flutter ListView和ScrollPhysics:详细介绍</h2><div class="np l"><h3 class="bd b fi z dy nn ea eb no ed ef dx translated">深入探索ListView小部件及其特性</h3></div><div class="nq l"><p class="bd b fp z dy nn ea eb no ed ef dx translated">medium.com</p></div></div><div class="nr l"><div class="os l nt nu nv nr nw jh ni"/></div></div></a></div><div class="nf ng ez fb nh ni"><a rel="noopener follow" target="_blank" href="/flutter-community/a-deep-dive-into-hero-widgets-in-flutter-d34f441eb026"><div class="nj ab dw"><div class="nk ab nl cl cj nm"><h2 class="hj b fi z dy nn ea eb no ed ef hh bi translated">深入探究Flutter中的英雄部件</h2><div class="np l"><h3 class="bd b fi z dy nn ea eb no ed ef dx translated">颤振中英雄部件的力量教程</h3></div><div class="nq l"><p class="bd b fp z dy nn ea eb no ed ef dx translated">medium.com</p></div></div><div class="nr l"><div class="ot l nt nu nv nr nw jh ni"/></div></div></a></div><p id="d667" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl ko">也可以随意查看我的其他资料:</strong></p><div class="nf ng ez fb nh ni"><a href="https://twitter.com/DevenJoshi7" rel="noopener  ugc nofollow" target="_blank"><div class="nj ab dw"><div class="nk ab nl cl cj nm"><h2 class="hj b fi z dy nn ea eb no ed ef hh bi translated">Deven Joshi (@DevenJoshi7) |推特</h2><div class="np l"><h3 class="bd b fi z dy nn ea eb no ed ef dx translated">Deven Joshi的最新推文(@DevenJoshi7)。谷歌认证安卓开发者。Flutter的博客作者和发言人…</h3></div><div class="nq l"><p class="bd b fp z dy nn ea eb no ed ef dx translated">twitter.com</p></div></div><div class="nr l"><div class="ou l nt nu nv nr nw jh ni"/></div></div></a></div><div class="nf ng ez fb nh ni"><a href="https://github.com/deven98" rel="noopener  ugc nofollow" target="_blank"><div class="nj ab dw"><div class="nk ab nl cl cj nm"><h2 class="hj b fi z dy nn ea eb no ed ef hh bi translated">deven98 -概述</h2><div class="np l"><h3 class="bd b fi z dy nn ea eb no ed ef dx translated">谷歌认证安卓开发者。Flutter和Android的演讲者和博客作者。热爱编码，人工智能和国际象棋。- deven98</h3></div><div class="nq l"><p class="bd b fp z dy nn ea eb no ed ef dx translated">github.com</p></div></div><div class="nr l"><div class="ov l nt nu nv nr nw jh ni"/></div></div></a></div><figure class="iy iz ja jb fd jc er es paragraph-image"><a href="https://medium.com/swlh"><div class="er es ow"><img src="../Images/308a8d84fb9b2fab43d66c117fcc4bb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YqDjlKFwScoQYQ62DWEdig.png"/></div></a></figure><h2 id="c148" class="me kr hi bd ks mj mk ml kw mm mn mo la js mp mq lc jw mr ms le ka mt mu lg mv bi translated">这篇文章发表在<a class="ae kp" href="https://medium.com/swlh" rel="noopener">《创业</a>》上，这是Medium最大的创业刊物，有+408714人关注。</h2><h2 id="869c" class="me kr hi bd ks mj mk ml kw mm mn mo la js mp mq lc jw mr ms le ka mt mu lg mv bi translated">在这里订阅接收<a class="ae kp" href="http://growthsupply.com/the-startup-newsletter/" rel="noopener ugc nofollow" target="_blank">我们的头条新闻</a>。</h2><figure class="iy iz ja jb fd jc er es paragraph-image"><a href="https://medium.com/swlh"><div class="er es ow"><img src="../Images/b0164736ea17a63403e660de5dedf91a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ouK9XR4xuNWtCes-TIUNAw.png"/></div></a></figure></div></div>    
</body>
</html>