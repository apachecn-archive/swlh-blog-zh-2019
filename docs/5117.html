<html>
<head>
<title>Let us get in on the basics of machine learning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让我们开始学习机器学习的基础知识</h1>
<blockquote>原文：<a href="https://medium.com/swlh/let-us-get-in-on-the-basics-of-machine-learning-c2ba274c8c58?source=collection_archive---------63-----------------------#2019-06-07">https://medium.com/swlh/let-us-get-in-on-the-basics-of-machine-learning-c2ba274c8c58?source=collection_archive---------63-----------------------#2019-06-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="605a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当你学习新的东西时，从基础开始总是好的，因为它的根源为以后的事情奠定了基础。在这篇文章中，我想分享一些我学到的机器学习术语的基础知识。</p><p id="e540" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">机器学习是人工智能的一个子领域，包括使用线性代数、概率论和统计学来建立模型，以从手头的数据中学习。Python是机器学习的同义词，因为它开发了如此多的库来帮助建立这些模型。NumPy、Pands、SciPy、Scikit-learn、TernsorFlow是Python中最常用的几个库。正如我在以前的一篇文章中提到的，使用Anaconda和conda包管理器，管理所有这些依赖项变得更加容易。</p><p id="5f4a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">机器学习的主要目标是利用从历史数据中收集的知识进行预测。机器学习任务可以进一步分为四类；</p><ul class=""><li id="8d6f" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated"><strong class="ih jm">无监督学习</strong></li></ul><p id="c628" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">主要处理未标记的数据，目标是找到底层数据的结构，并从中提取我们需要的信息。示例包括欺诈检测、营销活动的客户聚类。</p><ul class=""><li id="3825" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated"><strong class="ih jm">监督学习</strong></li></ul><p id="c9bd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们有完整描述和期望输出的数据。这里的目标是有一个通用的模型，它可以很好地处理输入并映射到期望的输出。例子包括语音识别、电影或购物推荐。</p><p id="26e1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">监督学习可以进一步分解为回归和分类。</p><ul class=""><li id="300e" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated"><strong class="ih jm">半监督学习</strong></li></ul><p id="baf2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这种情况下，并不是所有的样本都会被标记，通常会有大量的未标记数据和标记数据。</p><ul class=""><li id="2921" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated"><strong class="ih jm">强化学习</strong></li></ul><p id="2959" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这种情况下，系统根据确定的最终目标适应动态行为。它基于奖励和反馈循环机制工作。这方面的例子包括AlphaGo等应用程序，它们击败了世界上最好的围棋选手。自动驾驶汽车是这一领域的另一个好例子。</p><p id="d5ac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一般来说，建立一个机器学习模型包括以下步骤:</p><ol class=""><li id="bded" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc jn jj jk jl bi translated">了解业务</li><li id="bcb8" class="jd je hi ih b ii jo im jp iq jq iu jr iy js jc jn jj jk jl bi translated">理解数据</li><li id="2c84" class="jd je hi ih b ii jo im jp iq jq iu jr iy js jc jn jj jk jl bi translated">数据预处理</li><li id="cc4f" class="jd je hi ih b ii jo im jp iq jq iu jr iy js jc jn jj jk jl bi translated">系统模型化</li><li id="162c" class="jd je hi ih b ii jo im jp iq jq iu jr iy js jc jn jj jk jl bi translated">估价</li><li id="19ef" class="jd je hi ih b ii jo im jp iq jq iu jr iy js jc jn jj jk jl bi translated">部署</li></ol><p id="53c8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第3步到第5步通常以迭代的方式完成，并随着我们的进展进行微调。如果在理解数据方面有任何问题，那将需要更多的工作来清理、理解和验证数据。与任何软件应用程序一样，它应该以将系统提升到生产环境的标准方式结束。</p><h1 id="6531" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak">训练你的模型</strong></h1><p id="4c23" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">当您获得将用于训练您的模型的数据集时，它通常分为三类:</p><ul class=""><li id="a44b" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">训练集</li><li id="1ce4" class="jd je hi ih b ii jo im jp iq jq iu jr iy js jc ji jj jk jl bi translated">测试装置</li><li id="8a95" class="jd je hi ih b ii jo im jp iq jq iu jr iy js jc ji jj jk jl bi translated">验证集</li></ul><p id="68fc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您将开始使用训练集训练您的模型。在这一点上，作为你想从你的模型中得到的概括的一部分，会产生两个问题，我们称之为过度拟合和欠拟合。</p><p id="4f9d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">过度拟合是指模型试图进行补偿，以充分满足训练集中的所有样本，使其不再一般化，而是更具体地针对训练集。由于模型从训练集中学习了太多，这导致了机器学习中所谓的<strong class="ih jm">低偏差</strong>。当用除训练集之外的任何其他样本集测试该模型时，该模型将具有很高的方差。</p><p id="c456" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一方面，适配不足恰恰相反。该模型不适用于训练集样本，这反过来意味着它不适用于任何其他样本。这通常是使用一小组样本进行训练的结果。与过度拟合一样，这会导致<strong class="ih jm">高偏差</strong>和较低的方差。</p><p id="1a4f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">学习模型产生的错误被称为<strong class="ih jm">回忆偏差。</strong>我们需要一种折衷偏差和方差的方法，称为<strong class="ih jm">偏差-方差折衷</strong>。为此，我们用“<strong class="ih jm">均方误差(MSE)”、</strong>来衡量估计的误差。</p><p id="924c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">与合身不足相反，合身过度更像是一种欺骗。对于欠拟合，你知道你的模型不工作，你可以努力使它变得更好。但是过度适应的话，你可能会变得自满和快乐，因为它在训练集中表现得很好。</p><p id="391b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那么，如何克服过度拟合的问题呢？</p><h1 id="c41f" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak">交叉验证</strong></h1><p id="c139" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">交叉验证就是在训练、测试和验证之间划分数据集，以便在训练期间几乎每个样本都通过模型。<strong class="ih jm">穷举</strong>和<strong class="ih jm">非穷举</strong>是用来进行交叉验证的两种方案。</p><p id="30ca" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">穷举方案包括省去固定数量的样本用于训练，并使用剩余的样本用于测试和验证。<strong class="ih jm">留一法交叉验证(LOOCV) </strong>是一种可用于每个样品都处于测试阶段的情况下的方法。</p><p id="8dd2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih jm">注意:当数据集太大时，不建议执行穷举方案，因为用多轮训练模型的计算成本太高。</strong></p><p id="fd16" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">顾名思义，非穷举方案采用不同的方法。<strong class="ih jm"> K倍交叉验证</strong>是该方案中使用的机制之一，其中数据被随机分成<strong class="ih jm"> k倍大小的</strong>倍。然后在一个折叠上完成训练集，并且在每次迭代中，折叠改变到下一个。一张图片将有助于更好地形象化这一点；</p><figure class="kx ky kz la fd lb er es paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="er es kw"><img src="../Images/7c58112cc6ce6dfc70010a65545a0d20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ATTDpcLUTEZkY9hz"/></div></div></figure><p id="0211" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih jm">正规化</strong></p><figure class="kx ky kz la fd lb er es paragraph-image"><div class="er es li"><img src="../Images/6a13b517a76b823ee2aebb1f7ac0ccdc.png" data-original-src="https://miro.medium.com/v2/resize:fit:904/0*aEmyFgsXZ2F7CNxB"/></div></figure><p id="ec58" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">根据奥卡姆剃刀的<a class="ae lj" href="https://simple.wikipedia.org/wiki/Occam%27s_razor" rel="noopener ugc nofollow" target="_blank">原理</a>，简单的方法比复杂的方法更受青睐。过度拟合通常是一个复杂模型的结果，正则化会给误差函数增加额外的参数。</p><p id="3d3e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有不同的方法来控制模型的复杂性。<strong class="ih jm">提前停止</strong>是一种用于提前停止模型训练的机制，这样它将最终产生一个更简单的模型，而不是一个容易过度拟合的复杂模型。</p><h1 id="38eb" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak">功能选择</strong></h1><p id="bdbe" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">当我们得到最初的数据集时，当你浏览它时，你会发现所有的数据都与你试图解决的问题无关。事实上，将它们作为训练模型的一部分只会增加过程的随机性，从而导致过度拟合。作为功能选择的一部分，了解哪些功能对问题实际上是重要的是很重要的。一般来说，您可以通过两种方式进行特征选择。一种方法是在每次迭代中使用所有的特性并根据需要删除它们，第二种方法是从最少的一组特性开始，并随着您的进展迭代地添加特性。</p><h1 id="493b" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak">降维</strong></h1><p id="993d" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">数据通常表示为矩阵。对于某些类型的数据，如文本、图像，维度会非常大。拥有更高维度的问题是，不容易将数据可视化。此外，它增加了导致过度拟合的复杂性。</p><p id="8b16" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">减少复杂性和过度拟合的一个常用方法是将其转换到一个更低的维度空间(在后面的帖子中会详细介绍)。</p><p id="7941" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就是这篇文章的全部内容。我将在接下来的帖子中分享更多关于我在这篇帖子中无法详细介绍的一些方面的内容。再次感谢阅读，一如既往，欢迎评论。</p></div></div>    
</body>
</html>