<html>
<head>
<title>The Boolean Satisfiability Problem. Initial Outline (with spam in comments).</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">布尔可满足问题。初始大纲(评论中有垃圾邮件)。</h1>
<blockquote>原文：<a href="https://medium.com/swlh/the-boolean-satisfiability-problem-solved-48ceb5550115?source=collection_archive---------24-----------------------#2019-06-03">https://medium.com/swlh/the-boolean-satisfiability-problem-solved-48ceb5550115?source=collection_archive---------24-----------------------#2019-06-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div class="er es hg"><img src="../Images/807180c2c7b2ee3faa1d4782f7065ec1.png" data-original-src="https://miro.medium.com/v2/resize:fit:452/format:webp/1*VmStqX-8kfMrdTDTO7g22Q.jpeg"/></div></figure><div class=""/><div class=""><h2 id="b8b1" class="pw-subtitle-paragraph im ho hp bd b in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd dx translated">在这里，我展示了一些终极技术来制作逻辑运算的强大工具。道歉:有人黑了这篇文章，以避免分享这项技术。</h2></div><p id="1ade" class="pw-post-body-paragraph je jf hp jg b jh ji iq jj jk jl it jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated"><strong class="jg ka">布尔可满足性问题</strong> (SAT)是确定是否存在满足给定布尔公式的解释的问题。考虑到布尔变量是只能取两个可能值(0或1，假或真)的变量，布尔公式是用布尔变量进行的任何运算，它将被求值以取两个可能值中的一个。这就是为什么布尔值是这样定义的。</p><p id="27e1" class="pw-post-body-paragraph je jf hp jg b jh ji iq jj jk jl it jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">所以问题很简单:如果我给你一个公式即“f <em class="kb"> (x，y，z) = x </em> <strong class="jg ka">和</strong>(<em class="kb">y</em>T8】或 <em class="kb"> z </em>)，考虑到<strong class="jg ka">和</strong>和<strong class="jg ka">或</strong>布尔运算符，就会有(<em class="kb"> x </em>、<em class="kb"> y </em>、<em class="kb"> z </em> ) →(布尔)的赋值</p><p id="610b" class="pw-post-body-paragraph je jf hp jg b jh ji iq jj jk jl it jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">在这篇文章中，我将告诉你如何有效地找到这些值。</p><h1 id="c8e7" class="kc kd hp bd ke kf kg kh ki kj kk kl km iv kn iw ko iy kp iz kq jb kr jc ks kt bi translated">一些初始运算符</h1><p id="e1d8" class="pw-post-body-paragraph je jf hp jg b jh ku iq jj jk kv it jm jn kw jp jq jr kx jt ju jv ky jx jy jz hb bi translated">为了确保我们能够满足任何公式，首先我们需要有必要的运算符来表示它。为此，我们可以使用<strong class="jg ka"> 0 </strong>和<strong class="jg ka"> 1 </strong>值分别代表<strong class="jg ka">假</strong>和<strong class="jg ka">真</strong>值。正如<a class="ae kz" href="https://en.wikipedia.org/wiki/Boolean_algebra" rel="noopener ugc nofollow" target="_blank">乔治·布尔在1847年</a>所解释的，我们可以使用三个直观的运算符，其中:</p><ul class=""><li id="6acc" class="la lb hp jg b jh ji jk jl jn lc jr ld jv le jz lf lg lh li bi translated">x <strong class="jg ka">和</strong> y = min( <em class="kb"> x </em>，<em class="kb"> y </em>)</li><li id="f434" class="la lb hp jg b jh lj jk lk jn ll jr lm jv ln jz lf lg lh li bi translated">x <strong class="jg ka">或</strong> y = max( <em class="kb"> x </em>，<em class="kb"> y </em>)</li><li id="bd42" class="la lb hp jg b jh lj jk lk jn ll jr lm jv ln jz lf lg lh li bi translated"><strong class="jg ka">不是</strong> x = 1- <em class="kb"> x </em></li></ul><p id="0487" class="pw-post-body-paragraph je jf hp jg b jh ji iq jj jk jl it jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">但在这篇文章中，我将使用一个新的操作员来代替<strong class="jg ka">或</strong>和<strong class="jg ka">而不是</strong>。我称之为:<strong class="jg ka">选择</strong>，当你键入(<em class="kb">x</em>|<em class="kb">y</em>|<em class="kb">z</em>)= 1的时候，意思是你可以选择哪个<em class="kb"> x </em>、<em class="kb"> y </em>或者<em class="kb"> z </em>是1，但只能有一个，且只能有一个。事实上，您可以键入(<em class="kb"> x </em> | <em class="kb"> y </em> ) = 1，这意味着<em class="kb"> x </em> = 1 - <em class="kb"> y = </em> <strong class="jg ka">而不是</strong> <em class="kb"> y </em>。</p><p id="0446" class="pw-post-body-paragraph je jf hp jg b jh ji iq jj jk jl it jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">考虑到运算符A B = A <strong class="jg ka">和</strong> B，现在我们准备展示漂亮的公式…</p><p id="3933" class="pw-post-body-paragraph je jf hp jg b jh ji iq jj jk jl it jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">还有…，[(x1 |…| xn)= 1]<strong class="jg ka">↔</strong>[x1+…+xn = 1]。稍后，我们将使用另一种符号，但现在让我们研究一下我们可以用这个运算符做什么。</p><p id="2b44" class="pw-post-body-paragraph je jf hp jg b jh ji iq jj jk jl it jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">命题。下式(<em class="kb">A</em>|<em class="kb">B</em>|<em class="kb">C</em>)(<em class="kb">B</em>|<em class="kb">D</em>|<em class="kb">E</em>)(<em class="kb">C</em>|<em class="kb">E</em>|<em class="kb">F</em>)= 1，其中<em class="kb"> A、B、…、F </em>为布尔变量，满足以下语句:</p><ul class=""><li id="7a4c" class="la lb hp jg b jh ji jk jl jn lc jr ld jv le jz lf lg lh li bi translated"><em class="kb"> B </em> = <strong class="jg ka">非</strong> <em class="kb"> A </em> <strong class="jg ka">非</strong> <em class="kb"> D </em></li><li id="7e35" class="la lb hp jg b jh lj jk lk jn ll jr lm jv ln jz lf lg lh li bi translated"><em class="kb">f</em>=<em class="kb">a</em><strong class="jg ka">↔</strong>d</li></ul><p id="0781" class="pw-post-body-paragraph je jf hp jg b jh ji iq jj jk jl it jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">所以我们可以构造下一个定理:对于每一个<em class="kb"> x </em>，<em class="kb"> y </em>布尔值:</p><ul class=""><li id="8550" class="la lb hp jg b jh ji jk jl jn lc jr ld jv le jz lf lg lh li bi translated">(<strong class="jg ka">非</strong><em class="kb">x</em>|<em class="kb">x</em><strong class="jg ka">和</strong> <em class="kb"> y | z1) (x </em> <strong class="jg ka">和<em class="kb">|</em><strong class="jg ka">非</strong><em class="kb">y | z2)(Z1 | z2 | x</em><strong class="jg ka">↔</strong><em class="kb">y)=</em>1</strong></li></ul><p id="09d7" class="pw-post-body-paragraph je jf hp jg b jh ji iq jj jk jl it jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">因此，作为推论:我们可以将每个布尔公式表示为布尔变量选择的合取()。</p><p id="188f" class="pw-post-body-paragraph je jf hp jg b jh ji iq jj jk jl it jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">你可以考虑一些其他的研究，关于不同的问题(对<strong class="jg ka">计算机科学</strong>来说是有趣的)如何被表现。</p><div class="hh hi ez fb hj lo"><a rel="noopener follow" target="_blank" href="/@jumadaru/some-applications-for-np-solving-a960e0626c1a"><div class="lp ab dw"><div class="lq ab lr cl cj ls"><h2 class="hq b fi z dy lt ea eb lu ed ef ho bi translated">求解NP问题的一些应用</h2><div class="lv l"><h3 class="bd b fi z dy lt ea eb lu ed ef dx translated">NP问题是一类可枚举问题，其解易于验证。要是大就好了…</h3></div><div class="lw l"><p class="bd b fp z dy lt ea eb lu ed ef dx translated">medium.com</p></div></div><div class="lx l"><div class="ly l lz ma mb lx mc hl lo"/></div></div></a></div><h1 id="2735" class="kc kd hp bd ke kf kg kh ki kj kk kl km iv kn iw ko iy kp iz kq jb kr jc ks kt bi translated">改进我们的符号</h1><p id="69e5" class="pw-post-body-paragraph je jf hp jg b jh ku iq jj jk kv it jm jn kw jp jq jr kx jt ju jv ky jx jy jz hb bi translated">如上所述，每个布尔公式都可以表示为一个选择乘积。每个因素都被称为子句:公式是子句的乘积。</p><p id="38df" class="pw-post-body-paragraph je jf hp jg b jh ji iq jj jk jl it jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">为了满足一个公式，我们只需研究子句之间的关系。在这篇文章中，将使用的技巧是<strong class="jg ka">面对</strong>每两个子句。所以，让我们从两个子句开始:</p><figure class="md me mf mg fd hk er es paragraph-image"><div class="er es hg"><img src="../Images/31705a49090e5197045c18287fffd1f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:452/format:webp/1*JhiA-w71lEFybt7SLm3JuA.jpeg"/></div><figcaption class="mh mi et er es mj mk bd b be z dx">(A | B | C)·(A | D | E) = 1</figcaption></figure><p id="0078" class="pw-post-body-paragraph je jf hp jg b jh ji iq jj jk jl it jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">上面可以看到，方程(<em class="kb">A</em>|<em class="kb">B | C</em>)(<em class="kb">A | D | E</em>)= 1只有5个解(例)。事实上，只有知道每个子句中重复出现的变量，我们才能研究矩阵的最终形式。举个例子，</p><figure class="md me mf mg fd hk er es paragraph-image"><div class="er es ml"><img src="../Images/5d66db2ffb5436f748bbcce59276cf14.png" data-original-src="https://miro.medium.com/v2/resize:fit:460/format:webp/1*7TY-TQSQlSxMRYu6kNmrhA.jpeg"/></div></figure><p id="9a2b" class="pw-post-body-paragraph je jf hp jg b jh ji iq jj jk jl it jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">这就是为什么我们可以猜测如何组合代表不同重复的两个矩阵:</p><figure class="md me mf mg fd hk er es paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="er es mm"><img src="../Images/06d96ea65a2031014e38a90cd9e490b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BWHX5izJm-e7oDagcHl05A.jpeg"/></div></div><figcaption class="mh mi et er es mj mk bd b be z dx">Matrix1 <strong class="bd mr">and </strong>Matrix2 = Matrix3</figcaption></figure><p id="9664" class="pw-post-body-paragraph je jf hp jg b jh ji iq jj jk jl it jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">在Python中，我们可以完美地使用<strong class="jg ka"> numpy </strong>库来实现这个目的。</p><pre class="md me mf mg fd ms mt mu mv aw mw bi"><span id="c79a" class="mx kd hp mt b fi my mz l na nb">&gt;&gt;&gt; from numpy import matrix<br/>&gt;&gt;&gt; A<br/>matrix([[ True, False, False],<br/>        [False,  True,  True],<br/>        [False,  True,  True]])<br/>&gt;&gt;&gt; B<br/>matrix([[ True, False,  True],<br/>        [False,  True, False],<br/>        [ True, False,  True]])<br/>&gt;&gt;&gt; A&amp;B<br/>matrix([[ True, False, False],<br/>        [False,  True, False],<br/>        [False, False,  True]])</span></pre><p id="1d13" class="pw-post-body-paragraph je jf hp jg b jh ji iq jj jk jl it jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">此外，我们甚至可以实现关联任意两个子句的矩阵。</p><pre class="md me mf mg fd ms mt mu mv aw mw bi"><span id="ef4f" class="mx kd hp mt b fi my mz l na nb">def cMatrix(clauseC, clauseR):<br/>    R = matrix([[True] * len(clauseC)] * len(clauseR))<br/>    for i, X in enumerate(clauseC):<br/>        if X in clauseR:<br/>            j = clauseR.index(X)<br/>            R &amp;= matrix([[(i==col) == (j==row) \<br/>                         for col in range(len(clauseC))] \<br/>                        for row in range(len(clauseR))])<br/>    return R</span></pre><p id="bb39" class="pw-post-body-paragraph je jf hp jg b jh ji iq jj jk jl it jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">现在，我们可以测试代码，考虑公式中clauseC位于clauseR之前，以便按列或行排序:</p><pre class="md me mf mg fd ms mt mu mv aw mw bi"><span id="56a7" class="mx kd hp mt b fi my mz l na nb">&gt;&gt;&gt; cMatrix((1, 2, 4, 5), (1, 2, 3, 6, 7))<br/>matrix([[ True, False, False, False],<br/>        [False,  True, False, False],<br/>        [False, False,  True,  True],<br/>        [False, False,  True,  True],<br/>        [False, False,  True,  True]])</span></pre><p id="dd2f" class="pw-post-body-paragraph je jf hp jg b jh ji iq jj jk jl it jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">正如你所看到的，我们可以用数字或字符串来表示布尔变量。最重要的事情之一是:公式中每个子句的顺序，我们将在后面学习。</p><h1 id="5986" class="kc kd hp bd ke kf kg kh ki kj kk kl km iv kn iw ko iy kp iz kq jb kr jc ks kt bi translated">两个以上从句之间的连贯性</h1><p id="bfdb" class="pw-post-body-paragraph je jf hp jg b jh ku iq jj jk kv it jm jn kw jp jq jr kx jt ju jv ky jx jy jz hb bi translated">我们说过需要两个以上的子句来表示任何布尔公式。但是，最初我们需要确保我们每一个矩阵都会以正确的顺序面对每一个关系。</p><figure class="md me mf mg fd hk er es paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="er es nc"><img src="../Images/eb83c71d580f8e9cd1a42d9fbabe78a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EihYrgrbZ_punK_cSOR8IA.jpeg"/></div></div><figcaption class="mh mi et er es mj mk bd b be z dx">Example of a formula of 4 clauses: (A1| … |An)·(B1| … |Bn)·(C1| … |Cn)·(D1| … |Dn) = 1</figcaption></figure><p id="adde" class="pw-post-body-paragraph je jf hp jg b jh ji iq jj jk jl it jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">在上表中，我们看到我们需要表示公式中每个子句之间的每个关系。因此，如果我们连接子句-i和子句-j，我们确保列的子句是min( <em class="kb"> i </em>，<em class="kb"> j </em>)，行的子句是max( <em class="kb"> i </em>，<em class="kb"> j </em>)。</p><p id="704d" class="pw-post-body-paragraph je jf hp jg b jh ji iq jj jk jl it jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">现在，我提出下一个符号(在我看来，这会使它更简单):</p><figure class="md me mf mg fd hk er es paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="er es nd"><img src="../Images/14b380266a33e99527c7086cc0c75542.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t3P_Iq9FM3ThFaELStNCcw.jpeg"/></div></div><figcaption class="mh mi et er es mj mk bd b be z dx">Other way to represent (A1| … |An)·(B1| … |Bn)·(C1| … |Cn)·(D1| … |Dn) = 1</figcaption></figure><p id="e26e" class="pw-post-body-paragraph je jf hp jg b jh ji iq jj jk jl it jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">现在你可以看到6 =(4(4–1))/2个面和其他表示它们对应矩阵的方式。它们所代表的值是两个子句之间的唯一关系，所以我们对完整的关系感兴趣。</p><p id="74e7" class="pw-post-body-paragraph je jf hp jg b jh ji iq jj jk jl it jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">所以，当你拿着一把武士刀，你拿着一块石头，你假装在清理杂质的时候弄锋利了刀刃。你有办法改进一个矩阵，增加其他子句的信息:</p><figure class="md me mf mg fd hk er es paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="er es ne"><img src="../Images/63366f743550d219c257d58da370c707.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QQc82WwPhh72u1sfgB8TAA.jpeg"/></div></div><figcaption class="mh mi et er es mj mk bd b be z dx">Adding Ck to matrix [Ai·Dl]</figcaption></figure><p id="e626" class="pw-post-body-paragraph je jf hp jg b jh ji iq jj jk jl it jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">在示例中，我们看到了以下操作:</p><ul class=""><li id="5cd1" class="la lb hp jg b jh ji jk jl jn lc jr ld jv le jz lf lg lh li bi translated">[AiCkDl]=([C1 Dl][艾C1]|……|[Cn Dl][艾Cn])</li></ul><p id="60b0" class="pw-post-body-paragraph je jf hp jg b jh ji iq jj jk jl it jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">你可以看到，我们将矩阵(C，D)中的一行与矩阵(A，C)中的一列相乘，所以我们说的是矩阵乘积。乘积结果必须与原始矩阵(A，D)进行<strong class="jg ka">和</strong>运算。</p><p id="b1db" class="pw-post-body-paragraph je jf hp jg b jh ji iq jj jk jl it jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">所以，</p><ul class=""><li id="68c8" class="la lb hp jg b jh ji jk jl jn lc jr ld jv le jz lf lg lh li bi translated">对于一个<c matrix="" d="" c=""/></li></ul><p id="0bdd" class="pw-post-body-paragraph je jf hp jg b jh ji iq jj jk jl it jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">Considering a spetial property of those matrices, where the transposed matrix A* is the inverse one (in <strong class="jg ka"> numpy </strong>库是矩阵类中的<code class="du nf ng nh mt b">.transposed()</code>方法):</p><ul class=""><li id="9340" class="la lb hp jg b jh ji jk jl jn lc jr ld jv le jz lf lg lh li bi translated">A* A = I(单位矩阵)</li><li id="ab66" class="la lb hp jg b jh lj jk lk jn ll jr lm jv ln jz lf lg lh li bi translated">matrix(X，Y)* = matrix(Y，X)</li></ul><p id="f9e6" class="pw-post-body-paragraph je jf hp jg b jh ji iq jj jk jl it jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">这指出了其余的操作:</p><ul class=""><li id="379a" class="la lb hp jg b jh ji jk jl jn lc jr ld jv le jz lf lg lh li bi translated">对于一个<c matrix="" d="" a=""/></li><li id="31b2" class="la lb hp jg b jh lj jk lk jn ll jr lm jv ln jz lf lg lh li bi translated">For A<c matrix="" c="" d=""/></li></ul><p id="c044" class="pw-post-body-paragraph je jf hp jg b jh ji iq jj jk jl it jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">If you configured correctly a class for tables with the matrix class, you could type this code, in instance:</p><pre class="md me mf mg fd ms mt mu mv aw mw bi"><span id="6431" class="mx kd hp mt b fi my mz l na nb">tables[(C,D)] &amp;= tables[(A, D)]*tables[(C, A)]</span></pre><figure class="md me mf mg fd hk er es paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="er es nc"><img src="../Images/da3aafdabe15dc5e0482eee2b9627b29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ejLObPzSJ2POnLnUKwLcxA.jpeg"/></div></div><figcaption class="mh mi et er es mj mk bd b be z dx">You have to use every two matrices before eliminating a clause in the group of matrices</figcaption></figure><p id="f502" class="pw-post-body-paragraph je jf hp jg b jh ji iq jj jk jl it jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">I have an old version of this code not with <strong class="jg ka"> numpy </strong>，并使用表格结构的逆序…，在文件<a class="ae kz" href="https://archive.org/download/TheTwoExactPhilosophiesFiles" rel="noopener ugc nofollow" target="_blank"> <strong class="jg ka"> altEng.py </strong> </a>和2015年<a class="ae kz" href="https://ephjournal.com/index.php/bps/article/view/16" rel="noopener ugc nofollow" target="_blank">原文</a>中的一些其他解释。如果用户需要(如果你对这篇文章感兴趣)，我可以在<strong class="jg ka"> numpy </strong>中编写整个版本。</p><p id="eae4" class="pw-post-body-paragraph je jf hp jg b jh ji iq jj jk jl it jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">新:考虑到一个用户在<strong class="jg ka"> altEng.py </strong>的求解器中发现了一个反例，我建议改变知道一个公式是否可满足的方法，检查表格中的每一个案例:如果没有发现案例，单元格将被零清空。否则，你删除了两个子句来重复这个问题:作为结果，你将折叠一个结果或者你将删除所有结果。SAT问题将在O(x⁵).得到解决可以用诺瑟林环来改善。但是代码不是构造的:如果你感兴趣，你必须自己编码。否则，求解器只会在99%的情况下工作。</p><p id="5d7a" class="pw-post-body-paragraph je jf hp jg b jh ji iq jj jk jl it jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">如果你想知道更多关于这个结构的故事，我在:</p><div class="hh hi ez fb hj lo"><a rel="noopener follow" target="_blank" href="/datadriveninvestor/hard-life-for-a-rebellious-mind-2ea7693ebfe0"><div class="lp ab dw"><div class="lq ab lr cl cj ls"><h2 class="hq b fi z dy lt ea eb lu ed ef ho bi translated">叛逆思想的艰难生活</h2><div class="lv l"><h3 class="bd b fi z dy lt ea eb lu ed ef dx translated">最高效的机器被鄙视。</h3></div><div class="lw l"><p class="bd b fp z dy lt ea eb lu ed ef dx translated">medium.com</p></div></div><div class="lx l"><div class="ni l lz ma mb lx mc hl lo"/></div></div></a></div><h1 id="8739" class="kc kd hp bd ke kf kg kh ki kj kk kl km iv kn iw ko iy kp iz kq jb kr jc ks kt bi translated">一些额外的警告</h1><p id="db9b" class="pw-post-body-paragraph je jf hp jg b jh ku iq jj jk kv it jm jn kw jp jq jr kx jt ju jv ky jx jy jz hb bi translated">在用所有子句的信息计算一个矩阵后，你会注意到你将能够知道是否有解:最后一个矩阵将有一个<strong class="jg ka">值为真</strong>的单元，表示至少有一种情况。</p><p id="b8cd" class="pw-post-body-paragraph je jf hp jg b jh ji iq jj jk jl it jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">而且，你可以<em class="kb">打磨</em>结构，保证各个部位的边缘都是锋利的；或者甚至削尖整个结构以获得没有任何杂质的所有外壳。</p><p id="08ed" class="pw-post-body-paragraph je jf hp jg b jh ji iq jj jk jl it jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">例如，在<em class="kb">抛光</em>整个结构后，结果可能是:</p><figure class="md me mf mg fd hk er es paragraph-image"><div class="er es nj"><img src="../Images/15532423d620a89ac59de029f9b03f0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:988/format:webp/1*TM9Qeb3-rANgxomrpuSCDw.jpeg"/></div><figcaption class="mh mi et er es mj mk bd b be z dx">Every cell without a 1 is a 0, but a <strong class="bd mr">0</strong> is <strong class="bd mr">remarked</strong></figcaption></figure><p id="d5f2" class="pw-post-body-paragraph je jf hp jg b jh ji iq jj jk jl it jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">每个1意味着你可以达成一个解决方案，使<strong class="jg ka">为真</strong>它们对应的两个子句的变量。所以如果你想知道一个解，你只需要一个<em class="kb">完整的夏普</em>矩阵，并重构所有没有两个子句的公式。</p><p id="a1de" class="pw-post-body-paragraph je jf hp jg b jh ji iq jj jk jl it jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">这意味着你需要给寻找解决方案的算法增加一层复杂性。</p><p id="00a5" class="pw-post-body-paragraph je jf hp jg b jh ji iq jj jk jl it jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">或许，有了一个<em class="kb">完美的</em>结构，你可以更快地猜出解决方案。这就是本节的原因:在上图中，你可以找到三种解决方案。让我们看看下一张图:</p><figure class="md me mf mg fd hk er es paragraph-image"><div class="er es nk"><img src="../Images/4297e32e69f78b183bd39cba5999be6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:978/format:webp/1*KE9IuW7KV0A4LS4VTKEOXQ.jpeg"/></div><figcaption class="mh mi et er es mj mk bd b be z dx">You can superpose three cases: <strong class="bd mr">Blue </strong>+ <strong class="bd mr">Orange </strong>= <strong class="bd mr">Purple</strong></figcaption></figure><p id="1a45" class="pw-post-body-paragraph je jf hp jg b jh ji iq jj jk jl it jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">这三个案例纠缠在一起，我们只能知道每个单元格中是否有案例。两个<strong class="jg ka">蓝色</strong>箱子与两个<strong class="jg ka">橙色</strong>箱子<strong class="jg ka">紫色</strong>箱子有共同之处。</p><p id="09f0" class="pw-post-body-paragraph je jf hp jg b jh ji iq jj jk jl it jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">我们知道有一个叠加，因为有一个三重态，有两个1和一个0，正如第一个图中所展示的。所以，如果你想崩溃来观察排他的情况，你只需要决定那些1中的哪些必须转换成0…，然后你会<em class="kb">润色</em>，你会找到至少一个情况。</p><figure class="md me mf mg fd hk er es paragraph-image"><div class="er es nl"><img src="../Images/5d732dbf8ff3391512e1c2f20cd18f60.png" data-original-src="https://miro.medium.com/v2/resize:fit:990/format:webp/1*Mk6iLR2lChGq33dlnHp3Mw.jpeg"/></div><figcaption class="mh mi et er es mj mk bd b be z dx">You chose to eliminate the <strong class="bd mr">Blues</strong></figcaption></figure><p id="4a87" class="pw-post-body-paragraph je jf hp jg b jh ji iq jj jk jl it jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">消除纠结后，你会看到琐碎的作业来完成解决方案。只有排除案例，你才能在不重构完整公式的情况下得到解决方案。</p><p id="a453" class="pw-post-body-paragraph je jf hp jg b jh ji iq jj jk jl it jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">在我的旧代码中，我实现了一种方法来索引案例，而没有确证的纠缠(键入<code class="du nf ng nh mt b">object[case]</code>)。因此，对于该指标，解决方案是快速实现还是不实现。考虑到它能够在大多数指数中找到一个解决方案，因为它通常以很高的概率(80%)工作，那么你总是可以尝试另一个指数来找到想要的解决方案。</p><p id="a4dc" class="pw-post-body-paragraph je jf hp jg b jh ji iq jj jk jl it jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">基于这个结果，我考虑了我的证明，SAT在多项式时间和空间中是可解的。</p><p id="ca00" class="pw-post-body-paragraph je jf hp jg b jh ji iq jj jk jl it jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">时间和用户会告诉我们这些技术是否正是我所保证的。</p></div></div>    
</body>
</html>