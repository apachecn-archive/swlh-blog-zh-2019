# 用 JavaScript 编写一个简单的 transpiler

> 原文：<https://medium.com/swlh/writing-a-simple-transpiler-in-javascript-3c34ccb99e74>

## JS 的 Lambda calculus，人人都渴望的 transpiler。

![](img/dd015935303f3857653eac2716775c89.png)

Not pictured: a metaphor for my transpiler

我不知道为什么我决定写一个 transpiler，但是我知道我期望它比实际要难得多。我也不知道为什么我决定学习 lambda 微积分，但是*和我预期的一样难。*

这篇文章是关于我如何写了一个非常基本的 transpiler 来尝试掌握 lambda 语法。你不需要了解 lambda 演算或编译——我将一步一步地介绍我是如何编写这个工具的，并根据需要解释 lambdas 的古怪之处。完整的源代码可以在[这里](https://github.com/s-leigh/lambda-transpiler)找到。

术语注释:“编译”指的是将某些东西翻译成另一种语言，不管这两种语言的“高级”程度如何。“翻译”指的是将一种语言翻译成与另一种语言大致相同的高级语言。我把我的编译器称为“transpiler ”,但是你可以说 lambda 语法实际上比 JavaScript 更高级。我将在本文中使用这两个术语。

## 为什么会有人想这么做？

我的理由是，这是一种学习不熟悉的语法的结构化方式——它没有自己的解释器或任何可以交互使用的东西，因为 lambda 演算与其说是一种编程模型，不如说是一种数学系统。其他原因可能包括为您自己的特定用例编写 DSL，或者只是出于对您编写的文字如何转化为机器代码的兴趣。

## 幸运的是 lambda 语法的简要概述

![](img/400ef3ea62759b3eeaa8193a1bffcfcf.png)

This was taken in Greece, where the letter λ comes from

这可能是它自己的整篇文章，但我会保持简短。Lambda syntax 是天才数学家阿隆索·丘奇在 20 世纪 30 年代发明的，是一种表达可计算函数的方式。从这个意义上说，它有点像它自己的编程语言，除了它只有函数，没有别的。每个函数只能有一个参数。函数看起来像这样:

```
λx.λy.y
```

lambda 符号λ表示一个函数，点表示您将下一个东西应用于该函数。前面不带λ的字母是参数。JS 这么写，λx.λy.y 和`x => y => y`一样。因为每个函数只能有一个参数(用有趣的术语来说，函数的 arity 为 1 ),所以你最终会大量使用 currying。`(x => y => y)()(5)`给你 5，在 JavaScript 和 lambda calculus(反正连数字都没有)看来都是完全没用的函数，但我保证不是。

有了这样的限制性规则，lambda 语法实际上是编写编译器的最佳选择，因为需要担心的情况很少。

## 目标

![](img/699ec30d17dda17dfee138ffe2c5cbed.png)

`T`rapped in mathematical abstractions

我想要一个采用 lambda 表达式并在 JavaScript 中返回等价内容的东西，例如从λx.λy.y 到`x => y => y`。我到了那里，反正是为了基本的 lambda 表达式。我学到的东西:

*   编写编译器是测试驱动开发的一个很好的用例。我本质上并不是一个 TDD 的人——我怀疑这只是一个东西，因为它很容易在会议上发表演讲——但是尽管我很愤世嫉俗，这是它的一个极好的用例。编译器设计应该严格遵守关注点分离，并且应该总是非常清楚每个单元的输出应该被赋予什么输入。遵循 TDD 原则使得整个体验更加简单。
*   编写编译器是一次很好的学习经历，但你最终会达到收益递减。我本可以继续钻研并包装各种边缘案例、不同的 lambda 语法风格、更复杂的函数等等。但在某种程度上，这将是一个摆弄正则表达式和打乱逻辑而没有学到任何新东西的例子。我可能会继续搞砸，但我觉得我已经从这次经历中获得了最大的价值。

## 编译器剖析

它们可以变得非常复杂，但是编译器都有三个基本部分:

*   **词法分析器** : 将一个表达式分解成块(“词法”或“标记”)。我们将一次传入一个完整的 lambda 表达式，但是为了对它进行推理，我们需要把它分成不同的词位，它们表示不同的东西。
*   解析器:将词位列表转换成逻辑操作树——抽象语法树，或 AST。这听起来很复杂，但还不算太糟糕。AST 是语言不可知的——它与源语言或目标语言无关。当你看到下面的一个时，这可能更有意义。
*   **编译器/编译器**:将 AST 转换成目标语言(JavaScript)。这是一个遵循 AST 逻辑树并根据每个节点之前和之后发生的事情解决如何将它转换成 JS 的例子。

编译器也可能描述他们的源语言的语法。这通常以一种叫做 [EBNF](https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_form) 的格式编写，你可以在这里看到我的例子[。我不是以编程的方式使用我的方法，但仍然发现这是一个有用的练习，因为我对如何最好地推理语法没有完全的信心。在编写 lexer 时，它也有助于确定如何分解给定的表达式。从我的例子中可以看出，lambdas 的语法非常简单，但你可以想象对于适当的编程语言来说，它会有多复杂。](https://github.com/s-leigh/lambda-transpiler/blob/master/src/model/grammar.ebnf)

## 我们走吧

![](img/6715e4d2ea200c0706468a1ec36fc67b.png)

Greece again

我将回顾一下我的第一遍，这是为了支持我能想到的最简单的测试用例:“身份函数”，λx.x，它应该翻译成`x => x`(一个只返回给定的任何内容的函数)。在这一点上，我懒得复制和粘贴λ字符，所以我使用了`l`来代替。

## 编写 lexer

这非常简单，因为我已经掌握了 lambda 语法的基础，而且语法非常简单。完整地看着我的 lexer:

```
(str) => str.split(/(?<=\.)/);
```

不幸的是，没有摆脱正则表达式，所以我咬紧牙关，进入了地狱，这是积极和消极的前瞻性和前瞻性。它接受字符串并返回一个数组，该数组在`'.'`上拆分了字符串(但保留在前面的元素中)，所以我们的 identity 函数变成了`[’lx.’, 'x’]`。

我反复思考应该如何分解这个表达式。`.`应该是它自己的词位吗？λ符号`l`是否应该？最终，它归结为可以解析的最简单的实现，这就是我们在这里看到的。

## 编写解析器

这是最冗长的部分，部分原因是我想在解析器将一个词位识别为多种类型时抛出一个错误(这是不应该发生的)。

我们有 lexer:

模型是:

为了分解和简化，步骤如下:

1.  以第一个词位为例(在我们的例子中，`lx.`)
2.  如果它与 lambda 的正则表达式匹配，则将 lambda 解析器添加到我们的函数列表中，以便稍后执行
3.  如果它与绑定变量的正则表达式匹配，则将该解析器添加到列表中
4.  如果列表是空的或者有不止一个词，那么一定是出了问题，因为每个词位应该只匹配一种情况。抛出一个错误。
5.  解析词位，返回一个新的实例`Lambda`或`BoundVariable`。对于新实例的`apply`字段，用下一个词位返回对`parse`的另一个调用的结果(如果这是数组中的最后一个词位，这将是`null`)。

正如你将从步骤 5 中看到的，我们使用递归来建立一个操作树。最终结果将是我们的抽象语法树:

```
{
    symbolType: 'lambda',
    variable: 'x',
    apply: {
        symbolType: 'boundVariable',
        variable: 'x',
        apply: null
    }
}
```

我们真的很幸运有 lambdas，因为树永远只有一个分支——你只能将一个函数应用于一件事，另一个函数。这消除了大量的复杂性。因为 identity 函数只有两个元素(lambda 和绑定变量),所以这棵树只有两层。当下一个`apply`场是`null`时，我们知道我们已经到达终点。

现在我们需要把 AST 转换成 JavaScript。

## 编写 transpiler

![](img/253f280103203e1e441ecc81efebfd75.png)

Trapped in recursion

transpiler 将遍历 AST 并构建一个 JS 表达式:

所以它沿着 AST 向下(再次递归)，如果它看到一个 lambda，它输出一个带有关联变量+ `=>`的字符串，如果它看到一个绑定变量，它添加括号。这些字符串表达式都加在一起，当它接收到一个`null`的`apply`节点时，它返回一个内置表达式的`eval()`。最终的结果是`x => (x)`，就是身份函数！

## 后续步骤

![](img/daf894a2a54f567d6bee550be3561a3b.png)

I am become master of compilation

正如您从[完整源代码](https://github.com/s-leigh/lambda-transpiler)中看到的，随着我添加更多用例，事情变得稍微复杂了一些。我放入了一个包装器/控制器，这样就可以用命令行参数调用该工具并输出一个字符串化的结果，这意味着我还可以添加端到端的测试。transpiler 还可以处理应用于函数的未绑定变量，因此`lx.x 6`将返回 6，但这当然意味着在 lexer 和解析器中添加对未绑定变量和空格的支持。随着我添加更多的测试用例，我最注意到的事情是，由于编译器结构中关注点的分离，失败的往往只是一两个模块——与抽象语法之间的转换解耦了翻译逻辑，这就是为什么您首先要这样做。

我建议任何人都尝试创建一个编译器。正如我满怀希望地展示的那样，至少为琐碎的用例创建一个并不困难。这是学习像我这样的晦涩语法的一个很好的方法，或者只是如果你有兴趣研究语言是如何翻译的。也许我天生对深奥的东西更感兴趣，但我实际上很享受这个过程，所以如果你做过类似的事情，请告诉我！