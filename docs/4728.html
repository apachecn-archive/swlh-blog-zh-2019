<html>
<head>
<title>Using pure Golang for Google cloud</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将pure Golang用于Google cloud</h1>
<blockquote>原文：<a href="https://medium.com/swlh/using-pure-golang-for-google-cloud-bacc6b62e0ed?source=collection_archive---------6-----------------------#2019-06-04">https://medium.com/swlh/using-pure-golang-for-google-cloud-bacc6b62e0ed?source=collection_archive---------6-----------------------#2019-06-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="b084" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在过去的半年里，我一直在使用pure Golang研究Google cloud的开发和部署选项。我很快意识到使用这些API实际上很难，至少作为一个第一次使用的用户是这样，我想分享一下为什么我一直在努力。我将展示一些例子，并讨论使用Golang构建<a class="ae jd" href="https://cloud.google.com/run/" rel="noopener ugc nofollow" target="_blank">云运行(新)</a>、<a class="ae jd" href="https://cloud.google.com/tasks/" rel="noopener ugc nofollow" target="_blank">云任务(新ish) </a>和<a class="ae jd" href="https://cloud.google.com/datastore/" rel="noopener ugc nofollow" target="_blank">数据存储</a>的烦恼。</p></div><div class="ab cl je jf gp jg" role="separator"><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj"/></div><div class="hb hc hd he hf"><p id="2b45" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每当我想尝试一个新的GCP API时，我都会遇到这些问题，当你使用任何云平台时，这是很常见的。我的挣扎是由于缺乏<a class="ae jd" href="https://github.com/GoogleCloudPlatform/golang-samples" rel="noopener ugc nofollow" target="_blank">示例</a>和<a class="ae jd" href="https://www.reddit.com/r/golang/comments/6zo3q0/help_is_it_me_or_are_godocs_hard_to_read/" rel="noopener ugc nofollow" target="_blank"> godoc理解</a>，更糟糕的是，代码感觉非常复杂。在继续之前，我希望您已经<a class="ae jd" href="https://cloud.google.com/go/getting-started/authenticate-users" rel="noopener ugc nofollow" target="_blank">正确设置了认证</a>。</p><p id="b29d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，这里有一个简单的从<strong class="ih jl">数据存储库</strong>上传和获取的操作，其中包含两者的基本要素。由于Datastore是一个文档存储解决方案(dictionaries，JSON)，我们将只上传一个简单的JSON对象。对于以下所有示例，您必须定义projectID变量，这是您的GCP项目名称。<a class="ae jd" href="https://github.com/frikky/medium-examples/tree/master/gcloud" rel="noopener ugc nofollow" target="_blank">例题</a>此处！</p><pre class="jm jn jo jp fd jq jr js jt aw ju bi"><span id="a638" class="jv jw hi jr b fi jx jy l jz ka">package main<br/><br/>import (<br/> "cloud.google.com/go/datastore"<br/> "context"<br/> "encoding/json"<br/> "log"<br/>)<br/><br/>// Create an item we're gonna put in and remove<br/>// Uses datastore and json tags to map it directly<br/>type Data struct {<br/> Key string `datastore:"key" json:"key"`<br/>}<br/><br/>// Puts some data from the struct Data into the database<br/>func putDatastore(ctx context.Context, client *datastore.Client, dbname string, data Data) error {<br/> // Make a key to map to datastore<br/> datastoreKey := datastore.NameKey(dbname, data.Key, nil)<br/><br/> // Adds the key described above with the <br/>        // data from datastoreKey<br/> if _, err := client.Put(ctx, datastoreKey, &amp;data); err != nil {<br/>  log.Fatalf("Error adding testdata to %s: %s", dbname, err)<br/>  return err<br/> }<br/><br/> return nil<br/>}<br/><br/>// Gets the data back from the datastore<br/>func getDatastore(ctx context.Context, client *datastore.Client, dbname string, identifier string) (*Data, error) {<br/> // Defines the key<br/> datastoreKey := datastore.NameKey(dbname, identifier, nil)<br/><br/> // Creates an empty variable of struct Data, which we map the data back to<br/> newdata := &amp;Data{}<br/> if err := client.Get(ctx, datastoreKey, newdata); err != nil {<br/>  return &amp;Data{}, err<br/> }<br/><br/> return newdata, nil<br/>}<br/><br/>func main() {<br/> // Describe the project<br/> projectID := "yourprojectnamehere"<br/> dbname := "medium-test"<br/><br/> ctx := context.Background()<br/><br/> // Create a client<br/> client, err := datastore.NewClient(ctx, projectID)<br/> if err != nil {<br/>  log.Fatalf("Failed setting up client")<br/> }<br/><br/> // Create som json data to map to struct<br/> jsondata := `{<br/>  "key": "qwertyuiopasdfghjkl"<br/> }`<br/><br/> // Map the jsondata to the struct Data<br/> var structData Data<br/> if err := json.Unmarshal([]byte(jsondata), &amp;structData); err != nil {<br/>  log.Fatalf("Failed unmarshalling: %s", err)<br/> }<br/><br/> // Puts the data described above in the datastore<br/> if err := putDatastore(ctx, client, dbname, structData); err != nil {<br/>  log.Fatalf("Failed putting in datastore: %s", err)<br/> }<br/><br/> // Gets the same data back from the datastore<br/> returnData, err := getDatastore(ctx, client, dbname, structData.Key)<br/> if err != nil {<br/>  log.Fatalf("Failed getting from datastore: %s", err)<br/> }<br/><br/> // Print with some extra value<br/> log.Printf("%#v", returnData)<br/>}</span></pre><p id="b159" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">至于数据存储，它有一个ok API，使用起来非常简单。您创建了一个客户机，创建了一个结构来映射数据，这样就基本上完成了。这个样品有你需要的大部分东西。</p></div><div class="ab cl je jf gp jg" role="separator"><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj"/></div><div class="hb hc hd he hf"><p id="5e0c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">继续，让我们看一个更烦人的例子:<a class="ae jd" href="https://cloud.google.com/tasks/" rel="noopener ugc nofollow" target="_blank"> <strong class="ih jl">云任务</strong> </a> <strong class="ih jl">。</strong>我在任何示例可用之前开发了这些函数，这意味着它可能无法100%准确地使用live。(参见:apiv2beta3)。我花了很多时间来理解这个API，但好的一面是它教会了我如何更好地读取和跟踪godoc，这在总体上很方便。</p><p id="b028" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该代码创建一个客户端，定义一个项目位置(目标任务名称)，创建一个任务，然后计算任务的数量。PS:任务在钩子之后被自动删除，这意味着你可能不得不停止它来测试迭代器。</p><pre class="jm jn jo jp fd jq jr js jt aw ju bi"><span id="c3f6" class="jv jw hi jr b fi jx jy l jz ka">package main<br/><br/>import (<br/> cloudtasks "cloud.google.com/go/cloudtasks/apiv2beta3"<br/> "context"<br/> "fmt"<br/> "google.golang.org/api/iterator"<br/> taskspb "google.golang.org/genproto/googleapis/cloud/tasks/v2beta3"<br/> "log"<br/>)<br/><br/>func createTask(ctx context.Context, client *cloudtasks.Client, parent string) {<br/> // Define some endpoint you want the data to hit from<br/> url := "/api/test"<br/><br/> // Nested structs. Just mapped them like this so it's actually readable<br/> var appEngineHttpRequest *taskspb.AppEngineHttpRequest = &amp;taskspb.AppEngineHttpRequest{<br/>  HttpMethod:  taskspb.HttpMethod_GET,<br/>  RelativeUri: url,<br/> }<br/><br/> var appeng *taskspb.Task_AppEngineHttpRequest = &amp;taskspb.Task_AppEngineHttpRequest{<br/>  AppEngineHttpRequest: appEngineHttpRequest,<br/> }<br/><br/> var task *taskspb.Task = &amp;taskspb.Task{<br/>  PayloadType: appeng,<br/> }<br/><br/> // Structs added into the last struct which creates the task<br/> req := &amp;taskspb.CreateTaskRequest{<br/>  Parent: parent,<br/>  Task:   task,<br/> }<br/><br/> ret, err := client.CreateTask(ctx, req)<br/> if err != nil {<br/>  log.Printf("Error creating task: %s", err)<br/>  return<br/> }<br/><br/> log.Printf("%#v", ret)<br/><br/>}<br/><br/>func listAllTasks(ctx context.Context, client *cloudtasks.Client, parent string) {<br/> // Makes a struct to map<br/> req := &amp;taskspb.ListTasksRequest{<br/>  Parent: parent,<br/> }<br/><br/> // Returns an iterator over the parent tasks and counts<br/> ret := client.ListTasks(ctx, req)<br/> cnt := 0<br/> for {<br/>  _, err := ret.Next()<br/><br/>  if err == iterator.Done {<br/>   break<br/>  }<br/><br/>  if err != nil {<br/>   log.Printf("Error in iterator: %s", err)<br/>   break<br/>  }<br/><br/>  cnt += 1<br/> }<br/><br/> log.Printf("Current amount of tasks: %d", cnt)<br/>}<br/><br/>func main() {<br/> // Define the client<br/> ctx := context.Background()<br/> client, err := cloudtasks.NewClient(ctx)<br/> if err != nil {<br/>  log.Fatalf("Error creating cloudtask client: %s", err)<br/> }<br/><br/> // Set the projectId, location and queuename for the specific request<br/> projectID := "yourprojectnamehere"<br/> location := "europe-west3"<br/> queuename := "myqueue"<br/> var formattedParent string = fmt.Sprintf("projects/%s/locations/%s/queues/myqueue", projectID, location, queuename)<br/><br/> // Creates a task<br/> createTask(ctx, client, formattedParent)<br/> listAllTasks(ctx, client, formattedParent)<br/>}</span></pre><p id="18fa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这不是很容易吗？良好的..不完全是。这就是google cloud代码结构内部难以理解的地方，对于新手来说，这确实是一个麻烦。我个人认为<em class="kb">真的</em>愚蠢的一个例子是针对四个嵌套的结构，它们只是定义一个GET请求和一个端点。我知道appengine集成有一定的深度，但是拜托..</p></div><div class="ab cl je jf gp jg" role="separator"><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj"/></div><div class="hb hc hd he hf"><p id="ebe3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在继续之前，让我们向GCP的容器注册中心添加一个Docker图像。如果您有一个基于环境变量“PORT”监听的web服务器docker映像，请跳过这一步。(是的，我知道这是虚伪的，但我真的不想再花一天时间去宣传一个码头工人的形象..<a class="ae jd" href="https://cloud.google.com/container-registry/docs/reference/libraries" rel="noopener ugc nofollow" target="_blank">(我最终会回到这个话题)</a></p><pre class="jm jn jo jp fd jq jr js jt aw ju bi"><span id="7143" class="jv jw hi jr b fi jx jy l jz ka">git clone <a class="ae jd" href="https://github.com/medium-examples" rel="noopener ugc nofollow" target="_blank">https://github.com/frikky/medium-examples</a><br/>cd medium-examples/gcloud/webhook</span><span id="d698" class="jv jw hi jr b fi kc jy l jz ka"># Set the "projectname" variable in gcp_run.sh<br/>vim gcp_run.sh # ..</span><span id="d098" class="jv jw hi jr b fi kc jy l jz ka"># Run the script to build and deploy the webserver<br/>./gcp_run.sh</span><span id="e171" class="jv jw hi jr b fi kc jy l jz ka"># run.sh can will run the same file locally</span></pre></div><div class="ab cl je jf gp jg" role="separator"><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj"/></div><div class="hb hc hd he hf"><figure class="jm jn jo jp fd ke er es paragraph-image"><div role="button" tabindex="0" class="kf kg di kh bf ki"><div class="er es kd"><img src="../Images/9c8bc574ce23984aeeee39f70069419b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HK8SQDRWor-JcHvEyZcVbg.png"/></div></div></figure><p id="6a3f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">至于最后一部分，<strong class="ih jl">云跑</strong>，我很兴奋地看到<a class="kl km ge" href="https://medium.com/u/1737b4e67578?source=post_page-----bacc6b62e0ed--------------------------------" rel="noopener" target="_blank"> Jaana </a>的<a class="ae jd" rel="noopener" href="/google-cloud/google-cloud-run-for-go-ec09ddbba111"> blogpost </a>在发布后不久，希望看到一些真实的Golang具体例子。我很难过地看到(像那里的大多数博客帖子一样)，后备是使用gcloud CLI，而不仅仅是原生Go代码(我知道这是为了更广泛的受众:)。我和其他人一样喜欢gcloud，但我个人不在bash中进行平台集成。无论如何，这里有一个片段为一个已经存在的docker映像创建了一个新的云运行服务。它还有一个获取服务的功能。代码下面解释了我是如何到达这里的。我想强调的是，像这样的任务需要更多的时间。</p><pre class="jm jn jo jp fd jq jr js jt aw ju bi"><span id="e534" class="jv jw hi jr b fi jx jy l jz ka">package main<br/><br/>import (<br/> "context"<br/> "fmt"<br/> cloudrun "google.golang.org/api/run/v1alpha1"<br/> "log"<br/>)<br/><br/>func getAllLocations(projectsLocationsService *cloudrun.ProjectsLocationsService) ([]string, error) {<br/> // List locations<br/> // Make a request, then do the request<br/> list := projectsLocationsService.List(fmt.Sprintf("projects/shuffle-241517"))<br/> ret, err := list.Do()<br/><br/> if err != nil {<br/>  log.Println(err)<br/>  return []string{}, err<br/> }<br/><br/> locationNames := []string{}<br/> for _, item := range ret.Locations {<br/>  locationNames = append(locationNames, item.Name)<br/> }<br/><br/> return locationNames, nil<br/><br/>}<br/><br/>// https://cloud.google.com/run/docs/reference/rest/<br/>func main() {<br/> ctx := context.Background()<br/><br/> // Defines a the projectname, the servicename to use and an existing image to use<br/> projectId := "yourprojectnamehere"<br/> imagename := "yourimagenamehere"<br/> servicename := "webhook2"<br/><br/> // Create a service client like anywhere else<br/> apiservice, err := cloudrun.NewService(ctx)<br/> if err != nil {<br/>  log.Fatalf("Error creating cloudrun service client: %s", err)<br/> }<br/><br/> // Gets all available locations<br/> projectsLocationsService := cloudrun.NewProjectsLocationsService(apiservice)<br/> allLocations, err := getAllLocations(projectsLocationsService)<br/> if err != nil {<br/>  log.Fatalf("Error getting locations: %s", err)<br/> }<br/><br/> // Define the service to deploy<br/> // Wtf even is this<br/> // Metadata initializers<br/> // SOO MANY LAYERS OF BULLSHIT (:<br/> tmpservice := &amp;cloudrun.Service{<br/>  ApiVersion: "serving.knative.dev/v1alpha1",<br/>  Kind:       "Service",<br/>  Metadata: &amp;cloudrun.ObjectMeta{<br/>   Name:      servicename,<br/>   Namespace: projectId,<br/>  },<br/>  Spec: &amp;cloudrun.ServiceSpec{<br/>   RunLatest: &amp;cloudrun.ServiceSpecRunLatest{<br/>    Configuration: &amp;cloudrun.ConfigurationSpec{<br/>     RevisionTemplate: &amp;cloudrun.RevisionTemplate{<br/>      Metadata: &amp;cloudrun.ObjectMeta{<br/>       DeletionGracePeriodSeconds: 0,<br/>      },<br/>      Spec: &amp;cloudrun.RevisionSpec{<br/>       Container: &amp;cloudrun.Container{<br/>        Image: imagename,<br/>        Resources: &amp;cloudrun.ResourceRequirements{<br/>         Limits: map[string]string{"memory": "256Mi"},<br/>        },<br/>        Stdin:     false,<br/>        StdinOnce: false,<br/>        Tty:       false,<br/>       },<br/><br/>       ContainerConcurrency: 80,<br/>       TimeoutSeconds:       300,<br/>      },<br/>     },<br/>    },<br/>   },<br/>  },<br/> }<br/> //Env: []*cloudrun.EnvVar{<br/> //        &amp;cloudrun.EnvVar{<br/> //         Name:  "PORT",<br/> //         Value: "8080",<br/> //        },<br/> //       },<br/><br/> // Deploy the previously described service to all locations<br/> // Locations are the same as "parent" in other API calls, AKA:<br/> // projects/{projectname}/locations/{locationName}<br/> for _, location := range allLocations {<br/>  getService(projectsLocationsService, location)<br/>  createService(projectsLocationsService, location, tmpservice)<br/> }<br/>}<br/><br/>func getService(projectsLocationsService *cloudrun.ProjectsLocationsService, location string) {<br/> projectsLocationsServicesGetCall := projectsLocationsService.Services.Get(fmt.Sprintf("%s/services/webhook", location))<br/><br/> service, err := projectsLocationsServicesGetCall.Do()<br/> if err != nil {<br/>  log.Fatalf("Error creating new locationservice: %s", err)<br/> }<br/><br/> _ = service<br/>}<br/><br/>func createService(projectsLocationsService *cloudrun.ProjectsLocationsService, location string, service *cloudrun.Service) {<br/> projectsLocationsServicesCreateCall := projectsLocationsService.Services.Create(location, service)<br/> service, err := projectsLocationsServicesCreateCall.Do()<br/> log.Println(service, err)<br/> if err != nil {<br/>  log.Fatalf("Error creating new locationservice: %s", err)<br/> }<br/><br/> log.Printf("%#v", service.Spec)<br/>}</span></pre><p id="b752" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，这可能看起来不太糟糕，但是为了管理这个庞然大物的创建，我必须通过首先创建Get调用来逆向创建它。我最初是从godocs的<a class="ae jd" href="https://godoc.org/google.golang.org/api/run/v1alpha1#EnvVar" rel="noopener ugc nofollow" target="_blank">开始逆向构建的，寻找对“locations.services.create”的引用，在这里找到了</a><a class="ae jd" href="https://cloud.google.com/run/docs/reference/rest/v1alpha1/projects.locations.services/create" rel="noopener ugc nofollow" target="_blank"/>(其余的api文档实际上非常简洁)。在构建了结构并测试了API调用之后，我必须构建“服务”结构，这看起来是可行的(它很大而且非常复杂)，直到我发现当我的API调用失败时，API并没有告诉我出了什么问题。这意味着我必须在七个(是的，真的)嵌套结构中寻找无效或缺失的变量，以找到所需的或缺失的变量。</p><figure class="jm jn jo jp fd ke er es paragraph-image"><div role="button" tabindex="0" class="kf kg di kh bf ki"><div class="er es kn"><img src="../Images/0f65dc15ccf15c1f73ffb4a73887701a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1R7eBN57w3XLwyr59oiWHg.png"/></div></div><figcaption class="ko kp et er es kq kr bd b be z dx">Horrible error code</figcaption></figure><figure class="jm jn jo jp fd ke er es paragraph-image"><div role="button" tabindex="0" class="kf kg di kh bf ki"><div class="er es ks"><img src="../Images/df7afb3925a1ad0f241eae7394dd0242.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-5XFJeITyb31t5nbJ1UOQQ.png"/></div></div><figcaption class="ko kp et er es kq kr bd b be z dx">Notes while trying to understand and build the structure</figcaption></figure><p id="c6a8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以为了进一步调试需要的东西，我查看了Google cloud中的日志记录工具，很高兴地发现他们有ok审计日志记录。然而，真正的问题是审计日志也没有告诉你任何事情。</p><p id="580d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我的问题和愤怒不断堆积，我甚至开始逆向工程前端API调用，在创建新的云运行服务时遍历必填字段，但无济于事。</p><figure class="jm jn jo jp fd ke er es paragraph-image"><div role="button" tabindex="0" class="kf kg di kh bf ki"><div class="er es kt"><img src="../Images/74ae7398dd421ae335754aedb2a251f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:598/format:webp/1*_ejaQdFJgR7SIl9mPeNjDQ.png"/></div></div><figcaption class="ko kp et er es kq kr bd b be z dx">The CREATE function calls when creating in the frontend.</figcaption></figure><p id="e5d1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我很快想起我完全忘记了一个“简单”的叫法，我应该早点想到的。webhooks也有一个GET语句。我构建了GET语句，并很快基于遍历run的所有字段开发了以下struct。从Get调用返回的服务。</p><figure class="jm jn jo jp fd ke er es paragraph-image"><div role="button" tabindex="0" class="kf kg di kh bf ki"><div class="er es ku"><img src="../Images/b2f1610981bf04243b3c9eabb9a304c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nCWytrynHYJ8UPN6X4OrxQ.png"/></div></div><figcaption class="ko kp et er es kq kr bd b be z dx">The finished cloudrun example struct</figcaption></figure><p id="8919" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最终，经过一番努力，我得到了期待已久的200封回信。这是它在GUI中的样子(是的，我知道我很擅长审查)。</p><figure class="jm jn jo jp fd ke er es paragraph-image"><div role="button" tabindex="0" class="kf kg di kh bf ki"><div class="er es kv"><img src="../Images/1b1dcd76f18584af69b0c0307753f70b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*13lwDOHQdTX-vrer-xVBrw.png"/></div></div></figure></div><div class="ab cl je jf gp jg" role="separator"><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj"/></div><div class="hb hc hd he hf"><p id="c555" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，真正的问题是什么？是我太笨看不懂API，缺乏实例，还是它在alpha中？良好的..不，不是真的。我认为我在这方面的挣扎有多种原因，其中一个主要原因是它太复杂了，无法直接理解，这本身就是它自己的陷阱。我没有在其他语言中这样做过，但是所有这些背后的JSON必须在任何语言中构建，所以它依赖于包装器，但是代码生成是他们库中的一个大主题，我无法想象他们会好到哪里去。</p><blockquote class="kw kx ky"><p id="b3bc" class="if ig kb ih b ii ij ik il im in io ip kz ir is it la iv iw ix lb iz ja jb jc hb bi translated">我发现令人烦恼的是，我花了一整天的时间仅仅是为了理解一个结构应该如何构建。</p></blockquote></div><div class="ab cl je jf gp jg" role="separator"><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj"/></div><div class="hb hc hd he hf"><p id="70a0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就是一些完整的工作示例，并附有一些上下文。一个易于使用，一个有点复杂，没有很好的示例，定义非常奇怪，还有一个非常复杂，因为代码是分层的。这是他们三个的来源。</p><div class="lc ld ez fb le lf"><a href="https://github.com/frikky/medium-examples/tree/master/gcloud" rel="noopener  ugc nofollow" target="_blank"><div class="lg ab dw"><div class="lh ab li cl cj lj"><h2 class="hj b fi z dy lk ea eb ll ed ef hh bi translated">frikky/medium-示例</h2><div class="lm l"><h3 class="bd b fi z dy lk ea eb ll ed ef dx translated">中等博客的例子。在GitHub上创建一个帐户，为frikky/medium-examples开发做贡献。</h3></div><div class="ln l"><p class="bd b fp z dy lk ea eb ll ed ef dx translated">github.com</p></div></div><div class="lo l"><div class="lp l lq lr ls lo lt kj lf"/></div></div></a></div></div><div class="ab cl je jf gp jg" role="separator"><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj"/></div><div class="hb hc hd he hf"><p id="50ec" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">再次强调，这里的重点不是贬低Google cloud，因为我喜欢他们的服务，并且每天都在使用它们，但是我想分享我的沮丧和对一些功能和服务的学习，我觉得这些功能和服务缺少正确实现所需的文档。我也是问题的一部分，因为每当我完成一些我还没有找到样本的东西时，我通常不会花时间做拉请求。(无论如何，他们不会在<a class="ae jd" href="https://github.com/googlecloudplatform/golang-samples" rel="noopener ugc nofollow" target="_blank">Google cloud platform/golang-samples</a>repo中接受全新的样本)</p><p id="e7b8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">快乐无服务器编码:)</p></div></div>    
</body>
</html>