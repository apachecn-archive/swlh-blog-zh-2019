<html>
<head>
<title>Android MVI with Jetpack Compose</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带有Jetpack Compose的Android MVI</h1>
<blockquote>原文：<a href="https://medium.com/swlh/android-mvi-with-jetpack-compose-b0890f5156ac?source=collection_archive---------4-----------------------#2019-05-30">https://medium.com/swlh/android-mvi-with-jetpack-compose-b0890f5156ac?source=collection_archive---------4-----------------------#2019-05-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/2f4d40955abfea7ecaf9c8abf2a2dff5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9P5fa272ePdhka9smKcyaA.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Photo by <a class="ae iu" href="https://unsplash.com/photos/qB-jqzSE0yk?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Luca Nicoletti</a> on <a class="ae iu" href="https://unsplash.com/@lnicolet?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="fe1c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">今年，在Google I/O 2019上，已经宣布了JetPack Compose。它仍然是</p><blockquote class="jt ju jv"><p id="93c6" class="iv iw jw ix b iy iz ja jb jc jd je jf jx jh ji jj jy jl jm jn jz jp jq jr js hb bi translated">在早期探索，前阿尔法阶段。</p></blockquote><p id="e3b3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如<a class="ae iu" href="https://developer.android.com/jetpack/compose" rel="noopener ugc nofollow" target="_blank">官方文档页面</a>所述。在深入研究了演示预览(可以下载)之后，我完全同意这种说法。它缺少一些基本的组件，不适合生产，也不适合简单地迁移perk项目的某个部分。</p><p id="d9ee" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但这并不重要。我对我们目前所得到的非常满意。我有机会尝试了一下，并检查了这种<em class="jw">构建应用程序UI的新方式的潜力。</em></p><figure class="kb kc kd ke fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ka"><img src="../Images/d18ff83c45b709bee1d8defd91468406.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BRbi2bxkmtZNcrnmaSFqUw.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Photo by <a class="ae iu" href="https://unsplash.com/photos/ujx_KIIujRg?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Andrik Langfield</a> on <a class="ae iu" href="https://unsplash.com/search/photos/build?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure></div><div class="ab cl kf kg gp kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hb hc hd he hf"><p id="f04e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在我看来，从Flutter开始，然后是这个库，Google试图将web开发方式移植到移动应用程序中。在Flutter中，一切都是一个<code class="du km kn ko kp b">Widget</code>，这里组件被声明为函数。</p><p id="9572" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这可能是一个很好的开始，当然也有助于学习Flutter。一旦掌握了通过“组合”组件来构建ui的思想，切换到Flutter (React)模式就相当简单了。构建组件背后的范例在这两者之间并不遥远。</p></div><div class="ab cl kf kg gp kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hb hc hd he hf"><h1 id="633f" class="kq kr hi bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">简要介绍</h1><p id="4432" class="pw-post-body-paragraph iv iw hi ix b iy lo ja jb jc lp je jf jg lq ji jj jk lr jm jn jo ls jq jr js hb bi translated">JetPack Compose允许您声明</p><blockquote class="jt ju jv"><p id="d087" class="iv iw jw ix b iy iz ja jb jc jd je jf jx jh ji jj jy jl jm jn jz jp jq jr js hb bi translated">UI组件，包括绘制和创建自定义布局。</p></blockquote><p id="91a5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这意味着您可能有一个不返回任何内容的函数——从字面上看，该函数没有返回类型:</p><figure class="kb kc kd ke fd ij"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="1008" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是这个函数，由于有了<code class="du km kn ko kp b">@Composable</code>注释，允许我们声明一个“视图”,这个视图可以通过活动的<code class="du km kn ko kp b">setContent()</code>来设置(实际上是画出来的)。</p><figure class="kb kc kd ke fd ij"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="831b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是一个初始化可组合小部件树并将其包装在一个<code class="du km kn ko kp b">FrameLayout</code>中的方法。</p></div><div class="ab cl kf kg gp kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hb hc hd he hf"><h1 id="e575" class="kq kr hi bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">通常的方式</h1><p id="8269" class="pw-post-body-paragraph iv iw hi ix b iy lo ja jb jc lp je jf jg lq ji jj jk lr jm jn jo ls jq jr js hb bi translated">我计划向您展示的是，我们如何以一种奇特的方式使用这个新的Jetpack Compose来实现<strong class="ix lv"> MVI </strong>模式。<br/>现在，我们通常这样做来处理安卓系统中的<strong class="ix lv"> MVI </strong>:</p><figure class="kb kc kd ke fd ij"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="f1f3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们通过<code class="du km kn ko kp b">LiveData&lt;MVIViewState&gt;</code>发布从远程或本地存储中获取的任何内容(缓存数据！)这样:</p><figure class="kb kc kd ke fd ij"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="38bd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后我们从我们的活动中观察到<code class="du km kn ko kp b">LiveData</code>:</p><figure class="kb kc kd ke fd ij"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="79aa" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du km kn ko kp b">View</code>负责完全呈现<em class="jw">UI</em>，这有时会导致在<code class="du km kn ko kp b">View</code>中也使用逻辑，<em class="jw"> if-else </em>语句来显示或隐藏某些东西，而那个<code class="du km kn ko kp b">when</code>块，真的令人沮丧，不是吗？为什么<code class="du km kn ko kp b">View</code>要检查状态，并以不同的方式呈现一个状态？<code class="du km kn ko kp b">View</code>应该接收一个<code class="du km kn ko kp b">State</code>并呈现它，不执行任何其他操作(以纯函数的方式)。</p></div><div class="ab cl kf kg gp kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hb hc hd he hf"><h1 id="b3eb" class="kq kr hi bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">让我们改变我们建造东西的方式！</h1><p id="730d" class="pw-post-body-paragraph iv iw hi ix b iy lo ja jb jc lp je jf jg lq ji jj jk lr jm jn jo ls jq jr js hb bi translated">如果我们可以改变这种情况，给<code class="du km kn ko kp b">ViewModel</code>，或者更好的说法是<code class="du km kn ko kp b">ViewState</code>——构建<em class="jw"> UI </em>的能力，而让<code class="du km kn ko kp b">View</code>只渲染它，会怎么样？多亏了Jetpack Compose，这才成为可能。</p><figure class="kb kc kd ke fd ij"><div class="bz dy l di"><div class="lt lu l"/></div><figcaption class="iq ir et er es is it bd b be z dx">HURRAY!</figcaption></figure><p id="a1ae" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">那么，我们需要改变什么呢？<br/>这个<code class="du km kn ko kp b">MVIViewState</code>类会有一点不同:</p><figure class="kb kc kd ke fd ij"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="8a2b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个类相当冗长，这是有原因的:<code class="du km kn ko kp b">ViewState</code>应该表示<code class="du km kn ko kp b">View</code>，所以它应该<strong class="ix lv">知道</strong>如何渲染它，对吗？<br/>加入一项</p><figure class="kb kc kd ke fd ij"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="aab3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">函数给<code class="du km kn ko kp b">ViewState</code>，我们强制每个子类定义它，这意味着每个子类将知道如何“呈现”它的状态。这样，<strong class="ix lv">在<code class="du km kn ko kp b">ViewState</code>类的</strong>里面，我们相应地构建了<code class="du km kn ko kp b">ViewState</code>类的<code class="du km kn ko kp b">View</code>。这将允许我们有一个更精简的<strong class="ix lv"/><code class="du km kn ko kp b">View</code>(活动或片段)。</p><p id="4de7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">那么，<code class="du km kn ko kp b">ViewModel</code>级或者<code class="du km kn ko kp b">Activity/Fragment</code>级呢？嗯，<code class="du km kn ko kp b">ViewModel</code>基本保持不变:</p><figure class="kb kc kd ke fd ij"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="28e8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Okok，还有那个<code class="du km kn ko kp b">View</code>？</p><figure class="kb kc kd ke fd ij"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="a117" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这就是了！是不是<em class="jw">漂亮</em>？</p><p id="f3f8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我个人<strong class="ix lv"> <em class="jw">爱</em> </strong>怎么看也只是变得真<strong class="ix lv"> <em class="jw">精</em> </strong>而基本上什么都不做。i̶t̶<strong class="ix lv">̶o̶b̶s̶e̶r̶v̶e̶s̶</strong>̶t̶h̶e̶̶l̶i̶v̶e̶d̶a̶t̶a̶̶a̶n̶d̶̶t̶h̶a̶t̶'̶s̶̶i̶t̶.̶̶t̶h̶r̶o̶u̶g̶h̶̶t̶h̶e̶̶s̶e̶t̶c̶o̶n̶t̶e̶n̶t̶̶{̶}̶̶f̶u̶n̶c̶t̶i̶o̶n̶̶f̶r̶o̶m̶̶t̶h̶e̶̶j̶e̶t̶p̶a̶c̶k̶c̶o̶m̶p̶o̶s̶e̶̶l̶i̶b̶r̶a̶r̶y̶,̶̶w̶e̶'̶r̶e̶̶n̶o̶w̶̶a̶b̶l̶e̶̶t̶o̶̶d̶o̶̶t̶h̶i̶s̶̶m̶a̶g̶i̶c̶̶t̶r̶i̶c̶k̶！̶</p><p id="495f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi lw translated">多亏了利兰·理查森和他的建议，现在已经变得更好了。</p><p id="d013" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">它不是多次调用<code class="du km kn ko kp b">setContent{}</code>，而是创建视图的基本组件:<code class="du km kn ko kp b">CraneWrapper</code>、<code class="du km kn ko kp b">Scaffold</code>和<code class="du km kn ko kp b">AppBar</code>，然后<em class="jw">通过观察<code class="du km kn ko kp b">ViewState</code>上的变化，在<code class="du km kn ko kp b">Scaffold</code>内渲染</em>到<code class="du km kn ko kp b">View</code>的部分，也就是<em class="jw">渲染</em>的部分。</p></div><div class="ab cl kf kg gp kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hb hc hd he hf"><h2 id="fbd8" class="mh kr hi bd ks mi mj mk kw ml mm mn la jg mo mp le jk mq mr li jo ms mt lm mu bi translated">下降趋势</h2><p id="e78b" class="pw-post-body-paragraph iv iw hi ix b iy lo ja jb jc lp je jf jg lq ji jj jk lr jm jn jo ls jq jr js hb bi translated">但是也有一些缺点:</p><ul class=""><li id="56ba" class="mv mw hi ix b iy iz jc jd jg mx jk my jo mz js na nb nc nd bi translated">视图不再负责构建布局</li><li id="63a5" class="mv mw hi ix b iy ne jc nf jg ng jk nh jo ni js na nb nc nd bi translated">没有XML文件，所以您必须找到<code class="du km kn ko kp b">ViewState</code>类，搜索您想要检查的正确状态，并一个接一个地读取它构建的每个组件</li><li id="7bfd" class="mv mw hi ix b iy ne jc nf jg ng jk nh jo ni js na nb nc nd bi translated">布局检查器不起作用。<strong class="ix lv"> <em class="jw">等等，什么？！？</em> </strong>是的，没有。这是因为Jetpack Compose并不真正在视图层次结构中创建视图，它只是在画布上绘制了视图，所以基本上你是在检查视图。</li></ul><h2 id="b04d" class="mh kr hi bd ks mi mj mk kw ml mm mn la jg mo mp le jk mq mr li jo ms mt lm mu bi translated">我们在乎吗？</h2><p id="86ae" class="pw-post-body-paragraph iv iw hi ix b iy lo ja jb jc lp je jf jg lq ji jj jk lr jm jn jo ls jq jr js hb bi translated">一点也不。让我解释一下。上面列出的那些缺点是真正的缺点。我的意思是，如果没有布局检查器，我会一直试图找出为什么从12月份开始点击一个组件就不起作用了。<br/>但是由于<code class="du km kn ko kp b">View</code>不再负责构建布局，你可以很容易地检查它是如何构建的。您将不再有任何隐藏的加载器、隐藏的回收器、隐藏的自定义视图。所有你的用户需要看到的，将被构建到“<em class="jw">视图层次</em>”并绘制在画布上。你将最终拥有一个<strong class="ix lv">所见即所得</strong>。</p><h1 id="d9a2" class="kq kr hi bd ks kt nj kv kw kx nk kz la lb nl ld le lf nm lh li lj nn ll lm ln bi translated">结论</h1><p id="f758" class="pw-post-body-paragraph iv iw hi ix b iy lo ja jb jc lp je jf jg lq ji jj jk lr jm jn jo ls jq jr js hb bi translated">就是这样！这只是一个简单的介绍，我预计它将是结合Android世界中的<strong class="ix lv"> MVI </strong>模式的Jetpack Compose的开发！</p></div><div class="ab cl kf kg gp kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hb hc hd he hf"><p id="7cd0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">希望你喜欢阅读！感谢每一个反馈(这是我的第一篇博文:D)。</p></div></div>    
</body>
</html>