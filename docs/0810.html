<html>
<head>
<title>PyTorch Basics: Tensors and Gradients</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">PyTorch基础:张量和渐变</h1>
<blockquote>原文：<a href="https://medium.com/swlh/pytorch-basics-tensors-and-gradients-eb2f6e8a6eee#2019-02-07">https://medium.com/swlh/pytorch-basics-tensors-and-gradients-eb2f6e8a6eee#2019-02-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="e1bc" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">“PyTorch:零到GANs”的第一部分</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/9b0b8e1fe437e25a948c9a1f9d6d8a38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Yt6UFloi2B9UjL95vbwi5w.jpeg"/></div></div></figure><p id="883f" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><em class="kf">本帖是关于用</em><a class="ae kg" href="https://pytorch.org/" rel="noopener ugc nofollow" target="_blank"><em class="kf">【py torch】</em></a><em class="kf">【脸书开发和维护的开源神经网络库】构建深度学习模型系列教程的第一篇。查看完整系列:</em></p><ol class=""><li id="5c49" class="kh ki hi jl b jm jn jp jq js kj jw kk ka kl ke km kn ko kp bi translated"><a class="ae kg" rel="noopener" href="/jovian-io/pytorch-basics-tensors-and-gradients-eb2f6e8a6eee"> <em class="kf"> PyTorch基础知识:张量&amp;渐变</em> </a> <em class="kf">(本帖)</em></li><li id="30f4" class="kh ki hi jl b jm kq jp kr js ks jw kt ka ku ke km kn ko kp bi translated"><a class="ae kg" rel="noopener" href="/jovian-io/linear-regression-with-pytorch-3dde91d60b50"> <em class="kf">线性回归&amp;梯度下降</em> </a></li><li id="c962" class="kh ki hi jl b jm kq jp kr js ks jw kt ka ku ke km kn ko kp bi translated"><a class="ae kg" rel="noopener" href="/jovian-io/image-classification-using-logistic-regression-in-pytorch-ebb96cc9eb79"> <em class="kf">分类采用逻辑回归</em> </a></li><li id="efed" class="kh ki hi jl b jm kq jp kr js ks jw kt ka ku ke km kn ko kp bi translated"><a class="ae kg" rel="noopener" href="/jovian-io/training-deep-neural-networks-on-a-gpu-with-pytorch-11079d89805"> <em class="kf">前馈神经网络&amp;在GPU上训练</em> </a></li><li id="9949" class="kh ki hi jl b jm kq jp kr js ks jw kt ka ku ke km kn ko kp bi translated">即将到来..(CNN、迁移学习、RNNs、GANs等。)</li></ol><p id="3943" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这个系列试图让PyTorch对刚开始学习深度学习和神经网络的人来说更容易接近。在这篇文章中，我们将介绍PyTorch模型的基本构件:<em class="kf">张量和梯度</em>。</p><h1 id="5cf9" class="kv kw hi bd kx ky kz la lb lc ld le lf io lg ip lh ir li is lj iu lk iv ll lm bi translated">系统设置</h1><p id="db9c" class="pw-post-body-paragraph jj jk hi jl b jm ln ij jo jp lo im jr js lp ju jv jw lq jy jz ka lr kc kd ke hb bi translated">本教程采用了代码优先的方法来学习PyTorch，您应该尝试自己运行和试验代码。我们将使用Python的<a class="ae kg" href="https://www.anaconda.com/distribution/" rel="noopener ugc nofollow" target="_blank"> Anaconda发行版</a>来安装库和管理虚拟环境。对于交互式编码和实验，我们将使用<a class="ae kg" href="https://jupyter.org/" rel="noopener ugc nofollow" target="_blank"> Jupyter笔记本</a>。本系列的所有教程都可以在Jupyter笔记本上获得，托管在<a class="ae kg" href="https://www.jvn.io/" rel="noopener ugc nofollow" target="_blank"> Jovian </a>上:Jupyter的一个共享和协作平台。这篇文章的笔记本可以在这里找到:</p><div class="ls lt ez fb lu lv"><a href="https://jvn.io/aakashns/e5cfe043873f4f3c9287507016747ae5" rel="noopener  ugc nofollow" target="_blank"><div class="lw ab dw"><div class="lx ab ly cl cj lz"><h2 class="hj b fi z dy ma ea eb mb ed ef hh bi translated">aakashns/01-py torch-基础-木星</h2><div class="mc l"><h3 class="bd b fi z dy ma ea eb mb ed ef dx translated">即时分享Juptyer笔记本。Jovian使Jupyter笔记本可共享、可评论和可复制。</h3></div><div class="md l"><p class="bd b fp z dy ma ea eb mb ed ef dx translated">jvn.io</p></div></div><div class="me l"><div class="mf l mg mh mi me mj jh lv"/></div></div></a></div><p id="1a80" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">Jovian通过直接在Jupyter中运行一个命令，使得在云上共享Jupyter笔记本变得很容易。它还捕获运行笔记本所需的Python环境和库，因此任何人(包括您)都可以复制您的工作。</p><p id="4a3c" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">以下是您需要开始做的事情:</p><p id="1760" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">1.按照这里给出的<a class="ae kg" href="https://conda.io/projects/conda/en/latest/user-guide/install/index.html" rel="noopener ugc nofollow" target="_blank">说明安装Anaconda。您可能还需要将Anaconda二进制文件添加到系统路径中，以便能够运行<code class="du mk ml mm mn b">conda</code>命令行工具。</a></p><p id="0773" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">2.通过在Mac/Linux终端或Windows命令提示符下运行以下命令(不带<code class="du mk ml mm mn b">$</code>)来安装<code class="du mk ml mm mn b">jovian</code> Python库:</p><pre class="iy iz ja jb fd mo mn mp mq aw mr bi"><span id="ee58" class="ms kw hi mn b fi mt mu l mv mw">$ pip install jovian --upgrade</span></pre><p id="c297" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">3.使用<code class="du mk ml mm mn b">jovian clone</code>命令下载本教程的笔记本:</p><pre class="iy iz ja jb fd mo mn mp mq aw mr bi"><span id="abab" class="ms kw hi mn b fi mt mu l mv mw">$ jovian clone e5cfe043873f4f3c9287507016747ae5</span></pre><p id="2533" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这将创建一个包含Jupyter笔记本和Anaconda环境文件的目录<code class="du mk ml mm mn b">01-pytorch-basics</code>。</p><pre class="iy iz ja jb fd mo mn mp mq aw mr bi"><span id="6394" class="ms kw hi mn b fi mt mu l mv mw">$ ls 01-pytorch-basics<br/>01-pytorch-basics.ipynb  environment.yml</span></pre><p id="d3f0" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">4.现在我们可以进入目录并安装所需的Python库(Jupyter、PyTorch等。)使用<code class="du mk ml mm mn b">jovian</code>的单一命令:</p><pre class="iy iz ja jb fd mo mn mp mq aw mr bi"><span id="d53d" class="ms kw hi mn b fi mt mu l mv mw">$ cd 01-pytorch-basics<br/>$ jovian install</span></pre><p id="5a7b" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><code class="du mk ml mm mn b">jovian</code>读取<code class="du mk ml mm mn b">environment.yml</code>文件，为您的操作系统确定正确的依赖项，创建一个具有给定名称(默认为<code class="du mk ml mm mn b">01-pytorch-basics</code>)的虚拟环境，并在该环境中安装所有需要的库，以避免修改您的Python系统范围的安装。它在内部使用<code class="du mk ml mm mn b">conda</code>。如果你面临<code class="du mk ml mm mn b">jovian install</code>的问题，试着运行<code class="du mk ml mm mn b">conda env update</code>来代替。</p><p id="d2e7" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">5.通过运行以下命令激活虚拟环境</p><pre class="iy iz ja jb fd mo mn mp mq aw mr bi"><span id="6bf0" class="ms kw hi mn b fi mt mu l mv mw">$ conda activate 01-pytorch-basics</span></pre><p id="dec2" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">对于conda的旧版本，您可能需要运行命令:<code class="du mk ml mm mn b">source activate 01-pytorch-basics</code>。</p><p id="fe11" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">6.一旦虚拟环境被激活，我们就可以通过运行</p><pre class="iy iz ja jb fd mo mn mp mq aw mr bi"><span id="2ba2" class="ms kw hi mn b fi mt mu l mv mw">$ jupyter notebook</span></pre><p id="3c9f" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">7.你现在可以通过点击终端上显示的链接或者在浏览器上访问<a class="ae kg" href="http://localhost:8888" rel="noopener ugc nofollow" target="_blank"> http://localhost:8888 </a>来访问Jupyter的网络界面。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mx"><img src="../Images/aeea7fafec13da01106ee0eab7b0006c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WDMuCsNymA3pyMM7XpgSaQ.png"/></div></div></figure><p id="1519" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">此时，您可以点击笔记本<code class="du mk ml mm mn b">01-pytorch-basics.ipynb</code>打开它并运行代码。如果您想自己键入代码，也可以使用“新建”按钮创建一个新笔记本。</p><p id="934a" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们从导入PyTorch开始:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="my mz l"/></div></figure><h1 id="5132" class="kv kw hi bd kx ky kz la lb lc ld le lf io lg ip lh ir li is lj iu lk iv ll lm bi translated">张量</h1><p id="a9d4" class="pw-post-body-paragraph jj jk hi jl b jm ln ij jo jp lo im jr js lp ju jv jw lq jy jz ka lr kc kd ke hb bi translated">PyTorch的核心是一个处理张量的库。张量是数字、向量、矩阵或任何n维数组。让我们创建一个只有一个数字的张量:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="my mz l"/></div></figure><p id="ebae" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><code class="du mk ml mm mn b">4.</code>是<code class="du mk ml mm mn b">4.0</code>的简写。它用于向Python(和PyTorch)表明您想要创建一个浮点数。我们可以通过检查张量的<code class="du mk ml mm mn b">dtype</code>属性来验证这一点:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="my mz l"/></div></figure><p id="7b2c" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">让我们试着创建稍微复杂一点的张量:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="my mz l"/></div></figure><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="my mz l"/></div></figure><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="my mz l"/></div></figure><p id="cfd2" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">张量可以有任意多个维度，并且每个维度的长度不同。我们可以使用张量的<code class="du mk ml mm mn b">.shape</code>属性来检查每个维度的长度。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="my mz l"/></div></figure><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="my mz l"/></div></figure><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="my mz l"/></div></figure><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="my mz l"/></div></figure><h1 id="7039" class="kv kw hi bd kx ky kz la lb lc ld le lf io lg ip lh ir li is lj iu lk iv ll lm bi translated">张量运算和梯度</h1><p id="a4d7" class="pw-post-body-paragraph jj jk hi jl b jm ln ij jo jp lo im jr js lp ju jv jw lq jy jz ka lr kc kd ke hb bi translated">我们可以把张量和通常的算术运算结合起来。让我们看一个例子:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="my mz l"/></div></figure><p id="f2f5" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们已经创建了3个张量<code class="du mk ml mm mn b">x</code>、<code class="du mk ml mm mn b">w</code>和<code class="du mk ml mm mn b">b</code>，都是数字。<code class="du mk ml mm mn b">w</code>和<code class="du mk ml mm mn b">b</code>有一个附加参数<code class="du mk ml mm mn b">requires_grad</code>设置为<code class="du mk ml mm mn b">True</code>。我们马上就能看到它的作用。</p><p id="fc74" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">让我们通过组合这些张量来创建一个新的张量<code class="du mk ml mm mn b">y</code>:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="my mz l"/></div></figure><p id="a08c" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">正如所料，<code class="du mk ml mm mn b">y</code>是一个值为<code class="du mk ml mm mn b">3 * 4 + 5 = 17</code>的张量。PyTorch的特别之处在于，我们可以自动计算<code class="du mk ml mm mn b">y</code> w.r.t .的导数，即<code class="du mk ml mm mn b">requires_grad</code>设置为<code class="du mk ml mm mn b">True</code>的张量，即<code class="du mk ml mm mn b">w</code>和<code class="du mk ml mm mn b">b</code>。为了计算导数，我们可以在结果<code class="du mk ml mm mn b">y</code>上调用<code class="du mk ml mm mn b">.backward</code>方法。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="my mz l"/></div></figure><p id="cae2" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><code class="du mk ml mm mn b">y</code>相对于输入张量的导数存储在各自张量的<code class="du mk ml mm mn b">.grad</code>属性中。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="my mz l"/></div></figure><p id="feaa" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">不出所料，<code class="du mk ml mm mn b">dy/dw</code>与<code class="du mk ml mm mn b">x</code>的值相同，即<code class="du mk ml mm mn b">3</code>，而<code class="du mk ml mm mn b">dy/db</code>的值为<code class="du mk ml mm mn b">1</code>。注意<code class="du mk ml mm mn b">x.grad</code>是<code class="du mk ml mm mn b">None</code>，因为<code class="du mk ml mm mn b">x</code>没有将<code class="du mk ml mm mn b">requires_grad</code>设置为<code class="du mk ml mm mn b">True</code>。<code class="du mk ml mm mn b">w.grad</code>中的“grad”代表梯度，是导数的另一个术语，主要在处理矩阵时使用。</p><h1 id="c671" class="kv kw hi bd kx ky kz la lb lc ld le lf io lg ip lh ir li is lj iu lk iv ll lm bi translated">与Numpy的互操作性</h1><p id="e502" class="pw-post-body-paragraph jj jk hi jl b jm ln ij jo jp lo im jr js lp ju jv jw lq jy jz ka lr kc kd ke hb bi translated">Numpy是一个流行的开源库，用于Python中的数学和科学计算。它支持对大型多维阵列进行高效操作，并拥有一个庞大的支持库生态系统:</p><ul class=""><li id="821e" class="kh ki hi jl b jm jn jp jq js kj jw kk ka kl ke na kn ko kp bi translated">用于绘图和可视化的Matplotlib</li><li id="73bc" class="kh ki hi jl b jm kq jp kr js ks jw kt ka ku ke na kn ko kp bi translated"><a class="ae kg" href="https://opencv.org/" rel="noopener ugc nofollow" target="_blank">用于图像和视频处理的OpenCV </a></li><li id="071a" class="kh ki hi jl b jm kq jp kr js ks jw kt ka ku ke na kn ko kp bi translated"><a class="ae kg" href="https://pandas.pydata.org/" rel="noopener ugc nofollow" target="_blank"> Pandas </a>用于文件I/O和数据分析</li></ul><p id="34da" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">PyTorch没有重新发明轮子，而是与Numpy很好地互操作，以利用其现有的工具和库生态系统。</p><p id="9d96" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">下面是我们如何在Numpy中创建数组:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="my mz l"/></div></figure><p id="eef7" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们可以使用<code class="du mk ml mm mn b">torch.from_numpy</code>将Numpy数组转换成PyTorch张量。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="my mz l"/></div></figure><p id="c9cc" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">让我们验证Numpy数组和PyTorch张量具有相似的数据类型。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="my mz l"/></div></figure><p id="6fb5" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们可以使用张量的<code class="du mk ml mm mn b">.numpy</code>方法将PyTorch张量转换为Numpy数组。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="my mz l"/></div></figure><p id="2e24" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">PyTorch和Numpy之间的互操作性非常重要，因为您将使用的大多数数据集可能会作为Numpy数组进行读取和预处理。</p><h1 id="e066" class="kv kw hi bd kx ky kz la lb lc ld le lf io lg ip lh ir li is lj iu lk iv ll lm bi translated">提交并上传笔记本</h1><p id="ff0c" class="pw-post-body-paragraph jj jk hi jl b jm ln ij jo jp lo im jr js lp ju jv jw lq jy jz ka lr kc kd ke hb bi translated">最后一步，我们可以使用<code class="du mk ml mm mn b">jovian</code>库保存并提交我们的工作。</p><pre class="iy iz ja jb fd mo mn mp mq aw mr bi"><span id="19fd" class="ms kw hi mn b fi mt mu l mv mw">!pip install jovian --upgrade</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nb"><img src="../Images/104eaf1715593e5633e25fb23f58ae29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cl_ti-SyV3BKmuzDzs2qSg.png"/></div></div></figure><p id="ac05" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">Jovian将笔记本上传到<a class="ae kg" href="https://www.jovian.ml" rel="noopener ugc nofollow" target="_blank"> Jovian.ml </a>，捕获Python环境并为您的笔记本创建一个可共享的链接，如上图所示。你可以使用这个链接来分享你的作品，让任何人用<code class="du mk ml mm mn b">jovian clone</code>命令轻松复制它。Jovian还包括一个强大的评论界面，所以你(和其他人)可以讨论&amp;对你笔记本特定部分的评论:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nc"><img src="../Images/4a6e81e3672d5a7323079c8e8e6caeec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b4snnr_5Ve5Nyq60iDtuuw.png"/></div></div></figure><h1 id="07bb" class="kv kw hi bd kx ky kz la lb lc ld le lf io lg ip lh ir li is lj iu lk iv ll lm bi translated">进一步阅读</h1><p id="1b29" class="pw-post-body-paragraph jj jk hi jl b jm ln ij jo jp lo im jr js lp ju jv jw lq jy jz ka lr kc kd ke hb bi translated">PyTorch中的张量支持各种操作，我们在这里讨论的内容并不详尽。您可以在此了解关于张量和张量运算的更多信息:</p><div class="ls lt ez fb lu lv"><a href="https://pytorch.org/docs/stable/tensors.html" rel="noopener  ugc nofollow" target="_blank"><div class="lw ab dw"><div class="lx ab ly cl cj lz"><h2 class="hj b fi z dy ma ea eb mb ed ef hh bi translated">火炬。张量- PyTorch主文档</h2><div class="mc l"><h3 class="bd b fi z dy ma ea eb mb ed ef dx translated">当数据是一个张量x时，从传递的数据中读出“数据”,并构造一个叶变量。因此…</h3></div><div class="md l"><p class="bd b fp z dy ma ea eb mb ed ef dx translated">pytorch.org</p></div></div></div></a></div><p id="c3ed" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">您可以利用交互式Jupyter环境来试验张量，并尝试上面讨论的不同操作组合。以下是一些可以尝试的东西:</p><ol class=""><li id="6acd" class="kh ki hi jl b jm jn jp jq js kj jw kk ka kl ke km kn ko kp bi translated">在上面的例子中，如果一个或多个“<em class="kf">x“</em>”、“<em class="kf">w”</em>或“<em class="kf">b”</em>是矩阵，而不是数字，会怎么样？在这种情况下，结果“<em class="kf">y”</em>和梯度<code class="du mk ml mm mn b">w.grad</code>和<code class="du mk ml mm mn b">b.grad</code>会是什么样子呢？</li><li id="f2f7" class="kh ki hi jl b jm kq jp kr js ks jw kt ka ku ke km kn ko kp bi translated">如果"<em class="kf"> y" </em>是一个使用<code class="du mk ml mm mn b">torch.tensor</code>创建的矩阵，矩阵的每个元素都表示为数字张量"<em class="kf"> x" </em>、"<em class="kf"> w" </em>和"<em class="kf"> b" </em>"的组合会怎么样？</li><li id="28ee" class="kh ki hi jl b jm kq jp kr js ks jw kt ka ku ke km kn ko kp bi translated">如果我们有一个操作链，而不是只有一个操作链，即<code class="du mk ml mm mn b">y = x * w + b</code>、<code class="du mk ml mm mn b">z = l * y + m</code>、<code class="du mk ml mm mn b">e =c * z + d</code>等等，会怎么样？调用<code class="du mk ml mm mn b">e.backward()</code>会做什么？</li></ol><p id="3542" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">如果你感兴趣，你可以在维基百科上了解更多关于矩阵导数的知识(尽管这不是跟随这一系列教程所必需的):</p><div class="ls lt ez fb lu lv"><a href="https://en.wikipedia.org/wiki/Matrix_calculus#Derivatives_with_matrices" rel="noopener  ugc nofollow" target="_blank"><div class="lw ab dw"><div class="lx ab ly cl cj lz"><h2 class="hj b fi z dy ma ea eb mb ed ef hh bi translated">矩阵微积分-维基百科</h2><div class="mc l"><h3 class="bd b fi z dy ma ea eb mb ed ef dx translated">在数学中，矩阵微积分是做多变量微积分的专门符号，特别是在…</h3></div><div class="md l"><p class="bd b fp z dy ma ea eb mb ed ef dx translated">en.wikipedia.org</p></div></div></div></a></div><p id="e147" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">至此，我们完成了PyTorch中关于张量和梯度的讨论，我们准备进入下一个主题:<em class="kf">线性回归</em>。</p><h1 id="1857" class="kv kw hi bd kx ky kz la lb lc ld le lf io lg ip lh ir li is lj iu lk iv ll lm bi translated">信用</h1><p id="227f" class="pw-post-body-paragraph jj jk hi jl b jm ln ij jo jp lo im jr js lp ju jv jw lq jy jz ka lr kc kd ke hb bi translated">本系列中的材料主要受以下资源的启发:</p><ol class=""><li id="ce03" class="kh ki hi jl b jm jn jp jq js kj jw kk ka kl ke km kn ko kp bi translated"><a class="ae kg" href="https://github.com/yunjey/pytorch-tutorial" rel="noopener ugc nofollow" target="_blank">深度学习研究者PyTorch教程</a>作者Yunjey Choi</li><li id="095e" class="kh ki hi jl b jm kq jp kr js ks jw kt ka ku ke km kn ko kp bi translated"><a class="ae kg" href="https://github.com/fastai/fastai_docs/tree/master/dev_nb" rel="noopener ugc nofollow" target="_blank"> FastAI开发笔记本</a>杰瑞米·霍华德</li></ol></div></div>    
</body>
</html>