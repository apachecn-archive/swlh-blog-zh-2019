<html>
<head>
<title>Favouring full matches in Elasticsearch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">支持弹性搜索中的完全匹配</h1>
<blockquote>原文：<a href="https://medium.com/swlh/favouring-full-matches-in-elasticsearch-f3169982091d#2019-06-11">https://medium.com/swlh/favouring-full-matches-in-elasticsearch-f3169982091d#2019-06-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="1700" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">如何将最相关的匹配放在最上面，同时保留不太相关但仍然相关的结果</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/beed899057b1fb09e24c36224793f85e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*aqpVBtlnXUdnEnVb"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">Photo by <a class="ae jn" href="https://unsplash.com/@nickkarvounis?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Nick Karvounis</a> on <a class="ae jn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="1de0" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">问题是</h1><p id="c4a1" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">为了说明这个问题，假设我们有两个弹性搜索索引:一个包含一些画家的列表，另一个包含作曲家的列表。</p><p id="93ea" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">要亲自尝试这些示例，您可以在Elasticsearch实例上运行以下批量索引请求:</p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="2891" class="lm jp hi li b fi ln lo l lp lq">POST /_bulk<br/>{"index": {"_index": "painters"}}<br/>{"name": "<strong class="li lr">Vincent van Gogh</strong>"}<br/>{"index": {"_index": "painters"}}<br/>{"name": "<strong class="li lr">Rembrandt van Rijn</strong>"}<br/>{"index": {"_index": "painters"}}<br/>{"name": "<strong class="li lr">Frans Hals</strong>"}<br/>{"index": {"_index": "painters"}}<br/>{"name": "<strong class="li lr">Johann Adam Ackermann</strong>"}<br/>{"index": {"_index": "painters"}}<br/>{"name": "<strong class="li lr">Piet Mondriaan</strong>"}<br/>{"index": {"_index": "painters"}}<br/>{"name": "<strong class="li lr">Claude Monet</strong>"}<br/>{"index": {"_index": "painters"}}<br/>{"name": "<strong class="li lr">Jackson Pollock</strong>"}<br/>{"index": {"_index": "painters"}}<br/>{"name": "<strong class="li lr">Andy Warhol</strong>"}<br/>{"index": {"_index": "painters"}}<br/>{"name": "<strong class="li lr">Frida Kahlo</strong>"}<br/>{"index": {"_index": "painters"}}<br/>{"name": "<strong class="li lr">Johannes Vermeer</strong>"}<br/>{"index": {"_index": "painters"}}<br/>{"name": "<strong class="li lr">Leonardo da Vinci</strong>"}<br/>{"index": {"_index": "painters"}}<br/>{"name": "<strong class="li lr">Pieter Breugel</strong>"}<br/>{"index": {"_index": "composers"}}<br/>{"name": "<strong class="li lr">Johann Sebastian Bach</strong>"}<br/>{"index": {"_index": "composers"}}<br/>{"name": "<strong class="li lr">Johann Christoph Bach</strong>"}<br/>{"index": {"_index": "composers"}}<br/>{"name": "<strong class="li lr">Johann Ambrosius Bach</strong>"}<br/>{"index": {"_index": "composers"}}<br/>{"name": "<strong class="li lr">Clara Schumann</strong>"}</span></pre><p id="eb43" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">现在，为了说明这个问题，让我们搜索名字为“约翰·塞巴斯蒂安·巴赫”的人:</p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="5aa9" class="lm jp hi li b fi ln lo l lp lq">GET /painters,composers/_search<br/>{<br/>  "query": {<br/>    "match": {<br/>      "name": "johann sebastian bach"<br/>    }<br/>  }<br/>}</span></pre><p id="9941" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">它返回:</p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="bd1a" class="lm jp hi li b fi ln lo l lp lq">{<br/>  ...<br/>  "hits" : {<br/>    ...<br/>    "hits" : [<br/>      {<br/>        "_index" : "painters",<br/>        "_type" : "_doc",<br/>        "_id" : "xIxFCWsB7VA-_8kTLQH0",<br/>        "_score" : 1.9334917,<br/>        "_source" : {<br/>          "name" : "<strong class="li lr">Johann Adam Ackermann</strong>"<br/>        }<br/>      },<br/>      {<br/>        "_index" : "composers",<br/>        "_type" : "_doc",<br/>        "_id" : "zYxFCWsB7VA-_8kTLQH1",<br/>        "_score" : 1.8485742,<br/>        "_source" : {<br/>          "name" : "<strong class="li lr">Johann Sebastian Bach</strong>"<br/>        }<br/>      },<br/>      {<br/>        "_index" : "composers",<br/>        "_type" : "_doc",<br/>        "_id" : "zoxFCWsB7VA-_8kTLQH1",<br/>        "_score" : 0.6877716,<br/>        "_source" : {<br/>          "name" : "Johann Christoph Bach"<br/>        }<br/>      },<br/>      {<br/>        "_index" : "composers",<br/>        "_type" : "_doc",<br/>        "_id" : "z4xFCWsB7VA-_8kTLQH1",<br/>        "_score" : 0.6877716,<br/>        "_source" : {<br/>          "name" : "Johann Ambrosius Bach"<br/>        }<br/>      }<br/>    ]<br/>  }<br/>}</span></pre><p id="8561" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">哇，这是怎么回事？与我们的预期相反，巴赫并不是最靠前的搜索结果。虽然我们在<code class="du ls lt lu li b">composers</code>索引中找到了“约翰·塞巴斯蒂安·巴赫”(分数约为1.85)的字面匹配，但画家“约翰·亚当·阿克曼”(Johann Adam Ackermann)的分数更高(约为1.93)，他只匹配了我们搜索查询的一小部分！</p><h1 id="5b14" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">请解释一下</h1><p id="2737" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">和往常一样，我们可以<a class="ae jn" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-explain.html" rel="noopener ugc nofollow" target="_blank">向Elasticsearch寻求解释</a>:</p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="899e" class="lm jp hi li b fi ln lo l lp lq">GET /painters,composers/_search<strong class="li lr">?explain=true</strong><br/>{<br/>  "query": {<br/>    "match": {<br/>      "name": "johann sebastian bach"<br/>    }<br/>  }<br/>}</span></pre><p id="365e" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">这给了我们一个提示:与我们人类不同，Elasticsearch不知道“约翰·塞巴斯蒂安·巴赫”这个名字是一个连贯的单位，所以它单独搜索每个术语。</p><ol class=""><li id="a2dc" class="lv lw hi ki b kj lc km ld kp lx kt ly kx lz lb ma mb mc md bi translated">首先，一个<a class="ae jn" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-tokenizers.html" rel="noopener ugc nofollow" target="_blank">标记器</a>将查询分成三个词:<code class="du ls lt lu li b">johann OR sebastian OR bach</code>。</li><li id="fc17" class="lv lw hi ki b kj me km mf kp mg kt mh kx mi lb ma mb mc md bi translated">然后，Elasticsearch分别搜索每个术语。</li><li id="d4cd" class="lv lw hi ki b kj me km mf kp mg kt mh kx mi lb ma mb mc md bi translated">最后，它通过合并每个术语的分数来计算总分。</li></ol><p id="4acb" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">所以Elasticsearch默认运行<a class="ae jn" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query.html#query-dsl-match-query-boolean" rel="noopener ugc nofollow" target="_blank">一个</a> <code class="du ls lt lu li b"><a class="ae jn" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query.html#query-dsl-match-query-boolean" rel="noopener ugc nofollow" target="_blank">OR</a></code> <a class="ae jn" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query.html#query-dsl-match-query-boolean" rel="noopener ugc nofollow" target="_blank">查询</a>。也就是说，<em class="mj">至少有一个</em>的搜索词必须匹配，但不一定都要匹配。这解释了为什么Johann Adam Ackermann包含在结果中，尽管只有一个词(“Johann”)与我们的查询匹配。</p><h2 id="244d" class="lm jp hi bd jq mk ml mm ju mn mo mp jy kp mq mr ka kt ms mt kc kx mu mv ke mw bi translated">逆文档频率咬我们</h2><p id="cd94" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">但是这还没有回答为什么阿克曼的排名比巴赫高。是什么让阿克曼更相关？这与【Elasticsearch如何计算相关性有关:它依赖于<a class="ae jn" href="https://www.elastic.co/guide/en/elasticsearch/guide/current/scoring-theory.html#tfidf" rel="noopener ugc nofollow" target="_blank"> TF/IDF </a>算法。困扰我们的是IDF(倒排文档频率)部分:对于一个给定的搜索词，它出现在越多的文档中，它被认为越不相关。因此，在许多文档中出现的术语权重较低。一般来说，这是有意义的:如果你搜索<strong class="ki lr">'</strong>the well-tempered clavier '，你不会对所有包含诸如“the”等常见术语的文档感兴趣，而只会对少数提到键盘的文档感兴趣，最好是the-tempered那种。</p><p id="fa10" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">如果你看上面的数据，你会发现这两个指数加起来有四个约翰和三个巴赫。所以这仍然使巴赫成为更独特的相关术语，不是吗？<a class="ae jn" href="https://www.elastic.co/guide/en/elasticsearch/guide/current/scoring-theory.html#_putting_it_together" rel="noopener ugc nofollow" target="_blank">可惜不是，因为</a>:</p><blockquote class="mx my mz"><p id="67b8" class="kg kh mj ki b kj lc ij kl km ld im ko na le kr ks nb lf kv kw nc lg kz la lb hb bi translated">每个字段都有自己的倒排索引，因此，为了TF/IDF的目的，字段的值就是文档的值。</p></blockquote><p id="1826" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">也就是说，我们需要在字段级别区分<em class="mj">，而不是(仅)在索引级别区分</em>。(尽管两个索引中的字段都称为<code class="du ls lt lu li b">name</code>，但它们属于两个不同索引的事实使它们成为两个字段。)在这种情况下，我们在<code class="du ls lt lu li b">painters.name</code>领域只有一个约翰(阿克曼)，在<code class="du ls lt lu li b">composers.name</code>领域有三个，这确实将画家的相关性提升到了作曲家(约翰·塞巴斯蒂安·巴赫)之上。</p><h1 id="0709" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">解决方案1:仅匹配全部结果</h1><p id="8cce" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">正如我们上面看到的，默认情况下，Elasticsearch使用<code class="du ls lt lu li b">OR</code>来组合这些术语。那么，一个显而易见的解决方案就是告诉Elasticsearch匹配所有的搜索词<em class="mj">。您可以通过将操作员更改为<code class="du ls lt lu li b">AND</code>来完成此操作:</em></p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="b1df" class="lm jp hi li b fi ln lo l lp lq">GET /painters,composers/_search<br/>{<br/>  "query": {<br/>    "match": {<br/>      "name": {<br/>        "query": "johann sebastian bach",<br/><strong class="li lr">        "operator": "and"</strong><br/>      }<br/>    }<br/>  }<br/>}</span></pre><p id="670a" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">瞧，我们只有一个结果，那就是JSB。完成了吗？</p><p id="a868" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">那么，如果用户将巴赫与另一位著名作曲家的<a class="ae jn" href="https://en.wikipedia.org/wiki/Ludwig_van_Beethoven" rel="noopener ugc nofollow" target="_blank">混淆，而搜索<code class="du ls lt lu li b">johann van bach</code>呢？那个查询现在返回零个结果(因为<code class="du ls lt lu li b">van</code>在Bach的名字中找不到)，这对我们的用户来说有点太苛刻了。</a></p><h1 id="68e1" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">解决方案2:支持完整的结果</h1><p id="fdfa" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">我们可以通过用<code class="du ls lt lu li b"><a class="ae jn" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-minimum-should-match.html" rel="noopener ugc nofollow" target="_blank">minimum_should_match</a></code>替换自定义的<code class="du ls lt lu li b">operator</code>来解决这个问题:</p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="26dd" class="lm jp hi li b fi ln lo l lp lq">GET /painters,composers/_search<br/>{<br/>  "query": {<br/>    "match": {<br/>      "name": {<br/>        "query": "johann sebastian bach",<br/><strong class="li lr">        "minimum_should_match": "2&lt;75%"</strong><br/>      }<br/>    }<br/>  }<br/>}</span></pre><p id="73dc" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated"><code class="du ls lt lu li b">2&lt;75%</code>意思是:</p><ul class=""><li id="5cbb" class="lv lw hi ki b kj lc km ld kp lx kt ly kx lz lb nd mb mc md bi translated">如果你只提供两个搜索词(如<code class="du ls lt lu li b">johann bach</code>，它们必须都匹配(<code class="du ls lt lu li b">johann AND bach</code>)；</li><li id="7f7b" class="lv lw hi ki b kj me km mf kp mg kt mh kx mi lb nd mb mc md bi translated">但是如果您提供两个以上的术语(例如<code class="du ls lt lu li b">johann van bach</code>，只有75%(向下取整)必须匹配，所以这归结为<code class="du ls lt lu li b">(johann AND van) OR (van AND bach) OR (johann AND bach)</code>。</li></ul><p id="bf80" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">现在我们的搜索结果只包含三个Bachs，Johann Sebastian排名最高:</p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="7e3e" class="lm jp hi li b fi ln lo l lp lq">{<br/>  ...<br/>  "hits" : {<br/>    ...<br/>    "hits" : [<br/>      {<br/>        "_index" : "composers",<br/>        "_type" : "_doc",<br/>        "_id" : "zYxFCWsB7VA-_8kTLQH1",<br/>        "_score" : 1.8485742,<br/>        "_source" : {<br/>          "name" : "<strong class="li lr">Johann Sebastian Bach</strong>"<br/>        }<br/>      },<br/>      {<br/>        "_index" : "composers",<br/>        "_type" : "_doc",<br/>        "_id" : "zoxFCWsB7VA-_8kTLQH1",<br/>        "_score" : 0.6877716,<br/>        "_source" : {<br/>          "name" : "Johann Christoph Bach"<br/>        }<br/>      },<br/>      {<br/>        "_index" : "composers",<br/>        "_type" : "_doc",<br/>        "_id" : "z4xFCWsB7VA-_8kTLQH1",<br/>        "_score" : 0.6877716,<br/>        "_source" : {<br/>          "name" : "Johann Ambrosius Bach"<br/>        }<br/>      }<br/>    ]<br/>  }<br/>}</span></pre><p id="54d6" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">然而，这从我们的搜索结果中删除了画家Johann Ackermann，我们可能希望他作为‘Johann’的部分匹配返回。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ne"><img src="../Images/e628feb07d2a5417ecc221bc966763dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F2-zJ7i5ORrmxJYF3K1sZg.jpeg"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx">By <a class="ae jn" href="https://www.flickr.com/photos/ian_wilson_49/35145266852/in/photolist-VxEFoL-5bSHpW-VGb4kJ-kvEQ7y-7mDxN9-UYSnJj-m92wm-bsmDsx-kvCJVg-5R2fQC-mcaVGk-9Zo6Ap-bsmEg8-2dZC2sM-VV8yPc-bkUvDx-4MMPJQ-djnkYg-b7q7AD-VVaLtv-mgzVct-djnmpH-Tht4sb-dCmDkL-2cs5Zgi-TNkmW5-WpHYmR-UWjRdK-51xvba-4LXex2-9eiCvo-227UwBp-WHYzCw-cqvYWo-7Y3q9a-7DZi34-21SVdxg-M6tx8p-eEEW5d-TRVPhU-qCWqbB-r8FxW5-dYSjTP-DPdrVx-nFVnUQ-beX6Xc-9r3Kvp-W1VBjj-7caBiw-5bFTjg" rel="noopener ugc nofollow" target="_blank">Ian McFegan</a></figcaption></figure><h1 id="1ae2" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">解决方案3:以正确的方式支持完整的结果</h1><p id="baed" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">所以把操作符改成<code class="du ls lt lu li b">AND</code>(方案1)和提供一个<code class="du ls lt lu li b">minimum_should_match</code>(方案2)都<em class="mj">太严格</em>。一个更好、更灵活的解决方案是支持全部结果<em class="mj">，但仍然包含部分匹配的长尾。</em></p><p id="ec3c" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">解决这个问题的方法是利用复合布尔查询中<code class="du ls lt lu li b">should</code>子句的工作方式。<code class="du ls lt lu li b">should</code>关键字类似于常规的<code class="du ls lt lu li b">OR</code>,但在一个重要方面有所不同:匹配的子句越多，文档就被认为越相关。</p><p id="ee19" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">这使得将我们喜欢的结果指定为一组<code class="du ls lt lu li b">should</code>子句变得非常自然。我们首先将原始查询包装在一个bool查询中:</p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="b5aa" class="lm jp hi li b fi ln lo l lp lq">GET /painters,composers/_search<br/>{<br/>  "query": {<br/><strong class="li lr">   </strong> "bool": {<br/>      "should": [<strong class="li lr"><br/></strong>        <strong class="li lr">{<br/>          "match": {<br/>            "name": "johann sebastian bach"<br/>          }<br/>        }</strong><br/><strong class="li lr">      </strong>]<br/>    }<strong class="li lr"><br/></strong>  }<br/>}</span></pre><p id="0a9c" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">虽然这还没有改变我们的搜索结果，但它为添加更多的<code class="du ls lt lu li b">should</code>子句开辟了道路。因此，在此基础上，如果一个文档包含与查询顺序相同的术语组合，我们可以认为它更相关。用Elasticsearch的说法，这是一个<a class="ae jn" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query-phrase.html" rel="noopener ugc nofollow" target="_blank"> <em class="mj">短语匹配</em> </a> <em class="mj">。为此简单地增加一个<code class="du ls lt lu li b">should</code>条款:</em></p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="31a1" class="lm jp hi li b fi ln lo l lp lq">GET /painters,composers/_search<br/>{<br/>  "query": {<br/>    "bool": {<br/>      "should": [<br/>        {<br/>          "match": {<br/>            "name": "johann sebastian bach"<br/>          }<br/>        },<br/><strong class="li lr">        {<br/>          "match_phrase": {<br/>            "name": "johann sebastian bach"<br/>          }<br/>        }<br/></strong>      ]<br/>    }<br/>  }<br/>}</span></pre><p id="1dba" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">最后，我们可以将<code class="du ls lt lu li b">minimum_should_match</code>查询添加回我们的复合查询:</p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="7433" class="lm jp hi li b fi ln lo l lp lq">GET /painters,composers/_search<br/>{<br/>  "query": {<br/>    "bool": {<br/>      "should": [<br/>        {<br/>          "match": {<br/>            "name": "johann sebastian bach"<br/>          }<br/>        },<br/>        {<br/>          "match_phrase": {<br/>            "name": "johann sebastian bach"<br/>          }<br/>        },<br/>        <strong class="li lr">{<br/>          "match": {<br/>            "name": {<br/>              "query": "johann sebastian bach",<br/>              "minimum_should_match": "2&lt;75%"<br/>            }<br/>          }<br/>        }</strong><br/>      ]<br/>    }<br/>  }<br/>}</span></pre><p id="6b00" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">这给了我们想要的:</p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="4316" class="lm jp hi li b fi ln lo l lp lq">{<br/>  ...<br/>  "hits" : {<br/>    ...<br/>    "hits" : [<br/>      {<br/>        "_index" : "composers",<br/>        "_type" : "_doc",<br/>        "_id" : "j2VWR2sBKYAfkVJkD-Xu",<br/>        "_score" : <strong class="li lr">5.5457225</strong>,<br/>        "_source" : {<br/>          "name" : <strong class="li lr">"Johann Sebastian Bach"</strong><br/>        }<br/>      },<br/>      {<br/>        "_index" : "painters",<br/>        "_type" : "_doc",<br/>        "_id" : "hmVWR2sBKYAfkVJkD-Xu",<br/>        "_score" : <strong class="li lr">1.9334917</strong>,<br/>        "_source" : {<br/>          "name" : <strong class="li lr">"Johann Adam Ackermann"</strong><br/>        }<br/>      },<br/>      {<br/>        "_index" : "composers",<br/>        "_type" : "_doc",<br/>        "_id" : "kGVWR2sBKYAfkVJkD-Xu",<br/>        "_score" : 1.3755432,<br/>        "_source" : {<br/>          "name" : "Johann Christoph Bach"<br/>        }<br/>      },<br/>      {<br/>        "_index" : "composers",<br/>        "_type" : "_doc",<br/>        "_id" : "kWVWR2sBKYAfkVJkD-Xu",<br/>        "_score" : 1.3755432,<br/>        "_source" : {<br/>          "name" : "Johann Ambrosius Bach"<br/>        }<br/>      }<br/>    ]<br/>  }<br/>}</span></pre><h1 id="840e" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">结论</h1><p id="2bbf" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">所有的搜索都是在精确度和召回率之间的权衡。为了在这两者之间取得良好的平衡，你可以使用<code class="du ls lt lu li b">should</code>从句更加具体地描述你想要的结果。这首先给你最好的结果，同时保留较少但仍然相关的结果。</p></div></div>    
</body>
</html>