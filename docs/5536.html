<html>
<head>
<title>Post to walk to the Edge</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">帖子走到边上</h1>
<blockquote>原文：<a href="https://medium.com/swlh/easy-post-for-working-just-in-the-edge-6068b9b07db3#2019-06-11">https://medium.com/swlh/easy-post-for-working-just-in-the-edge-6068b9b07db3#2019-06-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/bc0a8fc1305dec368d34c6a161c968be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XBSQ17O3NDcXPf7QtTQZfw.png"/></div></div></figure><div class=""/><div class=""><h2 id="d9af" class="pw-subtitle-paragraph iq hs ht bd b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh dx translated">决定它是否可能，甚至是难以解决的</h2></div><p id="fe27" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">我们可以用计算机计算我们提出的任何东西，这是不正确的。这是100年前发现的东西。无论选择什么符号，都有一些问题，你不能确定一个机器可以得出一个答案。</p><p id="f544" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">无法用任何算法解决的问题是<strong class="jk ke">不可判定的</strong>问题。也许这就是<strong class="jk ke">邮报</strong>最有趣的遗产:通信的<a class="ae kf" href="https://en.wikipedia.org/wiki/Post_correspondence_problem" rel="noopener ugc nofollow" target="_blank">问题。不可判定的问题可能更容易公式化，也许正因为如此，更容易处理。</a></p><p id="d81d" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">这意味着，如果你有一个带有两个编码<strong class="jk ke"/><em class="kg"/>和<strong class="jk ke"> <em class="kg"> β </em> </strong>的序列<em class="kg"> K </em> naturals，并且如果你有两个来自同一序列的函数定义<em class="kg"> g </em>和<em class="kg"> f </em>，它们构成一个带有<strong class="jk ke"> <em class="kg"> α </em> </strong>和的<strong class="jk ke">字</strong></p><figure class="ki kj kk kl fd hk er es paragraph-image"><div class="er es kh"><img src="../Images/ea6b97d52fc2977198bd44ad27efacfa.png" data-original-src="https://miro.medium.com/v2/resize:fit:446/format:webp/1*01Ekyswypj4rSo2hW26m3w.jpeg"/></div></figure><p id="7616" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">你不能确保有一个<em class="kg">序列</em>，其中<em class="kg"> g(序列)</em> = <em class="kg"> f(序列)</em>。</p><p id="8e30" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">试想<em class="kg"> g </em>是西班牙语，<em class="kg"> h </em>是英语，<strong class="jk ke"> <em class="kg"> α </em> </strong> <em class="kg"> </em>和<strong class="jk ke"> <em class="kg"> β </em> </strong>可能是他们的字典，从同一个<em class="kg">心态</em>去理解一个<em class="kg">想法</em>，那么就没有办法知道两种语言是否能构造出同一个<em class="kg">想法</em>。考虑到这个概念，我们可以构造一个字典<strong class="jk ke"><em class="kg">α</em></strong><em class="kg">/</em><strong class="jk ke"><em class="kg">β</em></strong>来获取每个角色扮演的所有对应关系，比如:<strong class="jk ke"><em class="kg">α</em></strong><em class="kg">/</em><strong class="jk ke"><em class="kg">β</em></strong>= a/baa，ab/aa</p><p id="bab5" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">对于K = 4，如果我们取3，2，3，1 = bba ab bba a = bb aa bb baa为解</p><p id="ae25" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">如你所见，这是同一个字符串，但关联不同。</p><h1 id="6ac3" class="km kn ht bd ko kp kq kr ks kt ku kv kw iz kx ja ky jc kz jd la jf lb jg lc ld bi translated">输入代码</h1><p id="6111" class="pw-post-body-paragraph ji jj ht jk b jl le iu jn jo lf ix jq jr lg jt ju jv lh jx jy jz li kb kc kd hb bi translated">我们可以用这种方式编写任何代码来解决这个不可判定的问题，</p><pre class="ki kj kk kl fd lj lk ll lm aw ln bi"><span id="35d7" class="lo kn ht lk b fi lp lq l lr ls">def explodePost(dicc):<br/>    Q = set([])<br/>    newQ = clausure(('', ''), dicc)<br/>    while newQ:<br/>        query = newQ.pop()<br/>        if query in Q:<br/>            continue<br/>        newQ.update(clausure(query, dicc))<br/>        if ('', '') in newQ:<br/>            return True<br/>        Q.add(query)<br/>    return False</span><span id="89de" class="lo kn ht lk b fi lt lq l lr ls">def clausure(query, dicc):<br/>    R = set([])<br/>    q1, q2 = query<br/>    for x1 in dicc.keys():<br/>        qR = rest(q1+x1, q2+dicc[x1])<br/>        if qR is not None:<br/>            R.add(qR)<br/>    return R</span><span id="3474" class="lo kn ht lk b fi lt lq l lr ls">def rest(str1, str2, CAB = "$_$"):<br/>    if CAB + str1 in CAB + str2:<br/>        return ('', str2[len(str1):])<br/>    if CAB + str2 in CAB + str1:<br/>        return (str1[len(str2):], '')<br/>    return None</span></pre><p id="2f32" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">现在你可以想，如果没有可能的代码，你如何构造一个代码？显然，问题是我们不能确保这段代码会完成。但是你可以测试一些东西:</p><pre class="ki kj kk kl fd lj lk ll lm aw ln bi"><span id="64d8" class="lo kn ht lk b fi lp lq l lr ls">&gt;&gt;&gt; rest('my cat', 'my dog')<br/>&gt;&gt;&gt; rest('my ', 'my dog')<br/>('', 'dog')<br/>&gt;&gt;&gt; clausure(('', ''), {'a':'baa', 'ab':'aa', 'bba':'bb'})<br/>{('a', '')}<br/>&gt;&gt;&gt; explodePost({'a':'baa', 'ab':'aa', 'bba':'bb'})<br/>True<br/>&gt;&gt;&gt; explodePost({'a':'baa', 'ab':'aa', 'baa':'bb'})<br/>False</span></pre><p id="7762" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">因此，几乎对于某些条目，我们可以确保帖子对应是真还是假。</p><h2 id="5708" class="lo kn ht bd ko lu lv lw ks lx ly lz kw jr ma mb ky jv mc md la jz me mf lc mg bi translated">为什么它不能工作</h2><p id="726f" class="pw-post-body-paragraph ji jj ht jk b jl le iu jn jo lf ix jq jr lg jt ju jv lh jx jy jz li kb kc kd hb bi translated">假设我们构建类似于<em class="kg"> x[Q]y# </em>的字符串，其中<em class="kg"> x </em>和<em class="kg"> y </em>是字母表中的字符串，而<em class="kg"> Q </em>表示位于磁带中间的<a class="ae kf" href="https://en.wikipedia.org/wiki/Turing_machine" rel="noopener ugc nofollow" target="_blank">图灵机</a>中的一个可能的状态寄存器(位置可以是模式<em class="kg"> x[Q]y# </em>中的<em class="kg"> len(x) </em>)。</p><p id="b91d" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">所以，<strong class="jk ke"><em class="kg">α</em></strong><em class="kg">/</em><strong class="jk ke"><em class="kg">β</em></strong>中的每一个对应都能够代表我们<strong class="jk ke">图灵机</strong>模拟中的任何行为变化。举个例子，</p><ul class=""><li id="3350" class="mh mi ht jk b jl jm jo jp jr mj jv mk jz ml kd mm mn mo mp bi translated">如果我们在Q1读到字母“a ”,那么向右移动，放上“b ”,然后变成Q2 → [Q1]a / b[Q2]</li><li id="c163" class="mh mi ht jk b jl mq jo mr jr ms jv mt jz mu kd mm mn mo mp bi translated">用{'a '，' b'}字母，从Q1向左移动，换成Q2 → a[Q1]a/[Q2]aa，a[Q1]b/[Q2]ab，b[Q1]a/[Q2]ba，b[Q1]b/[Q2]bb</li></ul><p id="7fad" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">这意味着，如果我们能够解决<strong class="jk ke">帖子的对应</strong>(像<em class="kg"> explodePost </em>代码)，那么我们将能够猜测<a class="ae kf" href="https://en.wikipedia.org/wiki/Halting_problem" rel="noopener ugc nofollow" target="_blank">图灵机是否能够接受特定的条目</a>，考虑到下一步可能是构建一个能够猜测每个代码何时停止的代码，这是不可能的。</p><h1 id="7c7e" class="km kn ht bd ko kp kq kr ks kt ku kv kw iz kx ja ky jc kz jd la jf lb jg lc ld bi translated">我对NP和P的保证是什么</h1><p id="04d9" class="pw-post-body-paragraph ji jj ht jk b jl le iu jn jo lf ix jq jr lg jt ju jv lh jx jy jz li kb kc kd hb bi translated">想象你正在处理一系列的<em class="kg"> K </em>元素。该序列是我们将用来确保我们是否构造相同结果的索引<em class="kg">f</em>(seq)=<em class="kg">g</em>(seq)。</p><pre class="ki kj kk kl fd lj lk ll lm aw ln bi"><span id="1148" class="lo kn ht lk b fi lp lq l lr ls">def testPost(seq, items):<br/>    A = ''<br/>    B = ''<br/>    for i in seq:<br/>        A += items[i][0]<br/>        B += items[i][1]<br/>    return A == B</span><span id="8cea" class="lo kn ht lk b fi lt lq l lr ls">&gt;&gt;&gt; testPost((2, 1, 2, 0), <br/>       [('a', 'baa'), ('ab', 'aa'), ('bba', 'bb')])<br/>True</span></pre><p id="c153" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">在线性时间中，如果我们事先放入一个序列，我们可以测试配对条目是否有对应关系。所以，如果我们确定每个序列的最大长度，这个问题就容易验证了。这意味着存在一个<strong class="jk ke">图灵机</strong>线性有界，它将接受那个条目，我们可以用<em class="kg"> K </em>不确定的值来配置那个机器，以一种不确定的方式。</p><p id="b4f4" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">当我们可以在有限数量的<strong class="jk ke">图灵机</strong>下在多项式时间内接受一个条目时，我们考虑那个问题<strong class="jk ke"> NP </strong>。如果接受条目的代码在多项式时间内工作，问题将出现在<strong class="jk ke"> P </strong>中。</p><ul class=""><li id="d6a6" class="mh mi ht jk b jl jm jo jp jr mj jv mk jz ml kd mm mn mo mp bi translated">简易验证<em class="kg">和</em>可解问题= <strong class="jk ke"> NP </strong>问题</li><li id="e067" class="mh mi ht jk b jl mq jo mr jr ms jv mt jz mu kd mm mn mo mp bi translated">轻松解决= <strong class="jk ke"> P </strong>问题</li></ul><p id="92df" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">事实上，我们总是可以独立于输入建立一个最大值<em class="kg"> K </em>。所以在上面的代码中，<em class="kg"> testPost </em>，有最大数量的<em class="kg">seq</em>；其中<em class="kg"> seq </em>是<em class="kg">项</em>中定义的<strong class="jk ke">非确定性图灵机</strong>接受条目所需的证书。<em class="kg"> K </em>和接受输入所需的代码之间没有关系(反正不需要代码解码<em class="kg"> K </em>)。所以我们必然推断出<strong class="jk ke"> P </strong>不同于<strong class="jk ke"> NP </strong>。</p><h2 id="62fc" class="lo kn ht bd ko lu lv lw ks lx ly lz kw jr ma mb ky jv mc md la jz me mf lc mg bi translated">而且</h2><p id="9911" class="pw-post-body-paragraph ji jj ht jk b jl le iu jn jo lf ix jq jr lg jt ju jv lh jx jy jz li kb kc kd hb bi translated">想象我们在字母表中构造一个字符串<strong class="jk ke"> w </strong>。我们决定以两种不同的方式将字符串分成K个子字符串。所以现在我们有<em class="kg"> K </em>对子字符串作为<em class="kg"> validEntry </em>，它作为<strong class="jk ke"> Post的对应关系</strong>的一个条目。知道<code class="du mv mw mx lk b">explodePost(validEntry)</code>会在有限时间内返回<em class="kg">真</em>(<em class="kg">explode post(valid entry)</em>是一个可解的问题)，但如果不知道哪个值是<em class="kg"> K </em>，代码就不容易解。</p><p id="4c31" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">假设我们知道K，我们将得到一个容易解的代码，</p><ul class=""><li id="628b" class="mh mi ht jk b jl jm jo jp jr mj jv mk jz ml kd mm mn mo mp bi translated">代码(<em class="kg">K</em>)；<em class="kg"> validEntry </em>返回多项式时间内的有效序列。</li><li id="7286" class="mh mi ht jk b jl mq jo mr jr ms jv mt jz mu kd mm mn mo mp bi translated">代码(<em class="kg">K</em>)；<em class="kg"> anyEntry </em>)在多项式时间内返回结果。</li></ul><p id="5d52" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">如果<em class="kg"> anyEntry </em>有效，它将返回有效序列，您可以测试是否是有效条目。如果无效，它将返回任何内容，但是考虑到无效字符串，您会注意到这一点，因此您可以生成一个测试，其中:</p><ul class=""><li id="e8a6" class="mh mi ht jk b jl jm jo jp jr mj jv mk jz ml kd mm mn mo mp bi translated">testPost(代码(K；anyEntry)，anyEntry)在多项式时间内返回<strong class="jk ke">岗位对应</strong>。</li></ul><p id="c074" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">这意味着我们只需要从参数K创建一个代码，这个代码将接受任何输入来生成序列。但这是荒谬的:如果我们不能为每一个序列构造一个通用的代码，我们怎么能为每一个长度的序列配置所有的代码呢？</p><p id="d14a" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">所以我看到<strong class="jk ke"> NP </strong>类出了<strong class="jk ke"> P </strong>类也有问题。</p><h1 id="58e1" class="km kn ht bd ko kp kq kr ks kt ku kv kw iz kx ja ky jc kz jd la jf lb jg lc ld bi translated">结论</h1><p id="2f7b" class="pw-post-body-paragraph ji jj ht jk b jl le iu jn jo lf ix jq jr lg jt ju jv lh jx jy jz li kb kc kd hb bi translated">正如我们所见，许多被认为非常复杂的问题由于这种符号而得以简化。如果你想确定一个条目何时无解，你也可以发明一些技巧。</p><p id="5016" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">例如:对于条目{a/baa，ab/aa，bba/bb}，您可以将其转换为{$a$/$baa$，$ab$/$aa$，$bba$/$bb$}。因此，每一对都可以通过2-gram嵌入到向量中，其中$a$/$baa$可以是{'$a':1，' $b':-1，' ba': -1，' aa':-1}。之后，你用条目的大小来构造你的矩阵。我们能用那个矩阵找到一个像齐次方程组一样的解吗？如果响应不是，则该条目无解。</p><figure class="ki kj kk kl fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es my"><img src="../Images/81568a479ec7cc51508062ccc045cd35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7Ra0NOALkiUW-QVYOr08dw.jpeg"/></div></div></figure><p id="e1fb" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">如您所见，即使有办法处理Post的通信问题，</p><ul class=""><li id="65ac" class="mh mi ht jk b jl jm jo jp jr mj jv mk jz ml kd mm mn mo mp bi translated">如果齐次方程组失败，后一个方程组将无解。</li><li id="0885" class="mh mi ht jk b jl mq jo mr jr ms jv mt jz mu kd mm mn mo mp bi translated">如果被K包围的帖子产生了一个解，那么帖子一分享这个解。</li></ul><p id="db27" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">即使你认为一切都结束了，总有一个代码可以帮助你继续前行。</p></div></div>    
</body>
</html>