<html>
<head>
<title>What the heck is an event emitter?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么是事件发射器？</h1>
<blockquote>原文：<a href="https://medium.com/swlh/what-the-heck-is-an-event-emitter-84407fce6cd3#2019-06-06">https://medium.com/swlh/what-the-heck-is-an-event-emitter-84407fce6cd3#2019-06-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/e5acbd15e7a2fc2b37808769005a501f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K2wInnZsqHXY_N8n5YXpWA.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Photo by <a class="ae iu" href="https://unsplash.com/@tobiasc?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Tobias Cornille</a> on <a class="ae iu" href="https://unsplash.com/search/photos/signal?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="ba30" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">事件是许多不同编程语言的重要组成部分。不过，我在这里将重点关注JavaScript，特别是NodeJS事件。节点的架构主要是异步事件驱动的。</p><h1 id="5e2a" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">什么是事件？</h1><p id="5fc4" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">在事件发射器出现之前，如果我们想在代码中使用某些功能(比如在一个进程完成后发送一封电子邮件)，我们必须调用这个函数来直接发送电子邮件。</p><p id="4a3d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这带来了一些问题，例如在web服务器中，如果我们想要存储数据，然后向用户发送电子邮件，我们必须依赖电子邮件发送功能才能成功向客户端返回正确的HTTP响应。</p><p id="da7c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我喜欢用广播的方式来描述一个事件。它可能与您当地的广播电台非常相似。为了收听那个电台，你的汽车收音机被调到一个特定的频率。这意味着你车上的接收器正在过滤掉所有其他频率，以便收听你最喜欢的摇滚电台。摇滚电台正在播放他们正在播放的音乐。他们可以发送他们想要的任何东西，你车上的接收器正在你的扬声器上播放。</p><p id="f316" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">事件发射器以同样的方式工作。我们有监听器方法(汽车上的接收器)，我们有事件发射器(无线电台广播)。</p><h2 id="d407" class="kw ju hi bd jv kx ky kz jz la lb lc kd jg ld le kh jk lf lg kl jo lh li kp lj bi translated">监听器方法</h2><p id="6fb3" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">您的侦听器方法正在侦听某个事件(就像您的汽车收音机在某个频率上一样)。一旦该事件被发出，方法<em class="lk">对该事件做出反应</em>，从而调用该方法。如果从来没有一个事件符合监听器的标准，那么什么都不会发生，就像在你的汽车里听不到音乐一样。</p><h2 id="205a" class="kw ju hi bd jv kx ky kz jz la lb lc kd jg ld le kh jk lf lg kl jo lh li kp lj bi translated">事件发射器</h2><p id="6b83" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">您的事件发射器向任何等待响应的方法发送某个事件。就像在广播电台的广播中，没有人必须听才能实际广播事件，但是如果没有听众，那么什么也不会发生。</p><h1 id="10e0" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">我们如何利用这一点？</h1><p id="3b29" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">就像前面的电子邮件示例一样，事件发射器可以以多种不同的方式使用。</p><p id="4c6b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">NodeJS有一个名为…的内置事件模块。你猜对了…事件。你可以使用这个模块来创建你自己的事件，并进行游戏。这通常是最好的学习方法。</p><h1 id="9397" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">示例时间</h1><h2 id="9ecb" class="kw ju hi bd jv kx ky kz jz la lb lc kd jg ld le kh jk lf lg kl jo lh li kp lj bi translated">工作事件发射器</h2><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="b628" class="kw ju hi lq b fi lu lv l lw lx">const events = require(‘events’);</span><span id="ed95" class="kw ju hi lq b fi ly lv l lw lx">const emitter = new events.EventEmitter();</span><span id="e0d2" class="kw ju hi lq b fi ly lv l lw lx">emitter.on(‘fire’, () =&gt; {</span><span id="e6ba" class="kw ju hi lq b fi ly lv l lw lx">  console.log(‘Fire!’)</span><span id="224d" class="kw ju hi lq b fi ly lv l lw lx">});</span><span id="84d6" class="kw ju hi lq b fi ly lv l lw lx">console.log(‘Ready!’);</span><span id="90b1" class="kw ju hi lq b fi ly lv l lw lx">console.log(‘Aim!’);</span><span id="3dc5" class="kw ju hi lq b fi ly lv l lw lx">emitter.emit(‘fire’);</span></pre><p id="0d2e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这段代码:<br/> 1。导入事件模块<br/> 2。创建一个新的发射器对象<br/> 3。为“fire”事件<br/> 4创建监听器。日志<code class="du lz ma mb lq b">Ready!</code> <code class="du lz ma mb lq b">Aim!</code> <br/> 5。发出“火灾”事件<br/> 6。我们创建的监听日志<code class="du lz ma mb lq b">Fire!</code></p><p id="7556" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是预期的正确输出:</p><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="63ec" class="kw ju hi lq b fi lu lv l lw lx">Ready!<br/>Aim!<br/>Fire!</span></pre><h2 id="8ec5" class="kw ju hi bd jv kx ky kz jz la lb lc kd jg ld le kh jk lf lg kl jo lh li kp lj bi translated">非工作事件发射器</h2><p id="7026" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">您必须确保的一件事是，侦听器是在发出 事件之前<strong class="ix mc"> <em class="lk">创建的。如果不是，那么在事件发出时，没有任何东西在监听它。所以如果我们有下面的代码:</em></strong></p><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="fb2e" class="kw ju hi lq b fi lu lv l lw lx">const events = require(‘events’);</span><span id="ca69" class="kw ju hi lq b fi ly lv l lw lx">const emitter = new events.EventEmitter();</span><span id="c630" class="kw ju hi lq b fi ly lv l lw lx">console.log(‘Ready!’);</span><span id="92b4" class="kw ju hi lq b fi ly lv l lw lx">console.log(‘Aim!’);</span><span id="2d37" class="kw ju hi lq b fi ly lv l lw lx">emitter.emit(‘fire’);</span><span id="34f8" class="kw ju hi lq b fi ly lv l lw lx">emitter.on(‘fire’, () =&gt; {</span><span id="74b0" class="kw ju hi lq b fi ly lv l lw lx">  console.log(‘Fire!’)</span><span id="9d11" class="kw ju hi lq b fi ly lv l lw lx">});</span></pre><p id="5d72" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这段代码:<br/> 1。导入事件模块<br/> 2。创建新的发射器对象<br/> 3。日志<code class="du lz ma mb lq b">Ready!</code> <code class="du lz ma mb lq b">Aim!</code> <br/> 4。发出“fire”事件。<br/> 5。为“fire”事件创建侦听器</p><p id="cd2a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后我们得到以下输出:</p><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="7abb" class="kw ju hi lq b fi lu lv l lw lx">Ready!<br/>Aim!</span></pre><h1 id="3d48" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">将参数传递给事件侦听器</h1><p id="4a1e" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">另一个对事件发射器至关重要的令人惊叹的特性是将数据传递给监听器的能力。就像电台向我们的收音机发送音乐一样。</p><p id="0fd3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">要做到这一点，很简单:</p><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="ded0" class="kw ju hi lq b fi lu lv l lw lx">const events = require('events');</span><span id="7d0d" class="kw ju hi lq b fi ly lv l lw lx">const emitter = new events.EventEmitter();</span><span id="393c" class="kw ju hi lq b fi ly lv l lw lx">emitter.on('fire', (word) =&gt; {</span><span id="ebab" class="kw ju hi lq b fi ly lv l lw lx">  console.log(word)</span><span id="a94d" class="kw ju hi lq b fi ly lv l lw lx">});</span><span id="3ce5" class="kw ju hi lq b fi ly lv l lw lx">emitter.emit('fire', 'Ready!');</span><span id="93c2" class="kw ju hi lq b fi ly lv l lw lx">emitter.emit('fire', 'Aim!');</span><span id="30fc" class="kw ju hi lq b fi ly lv l lw lx">emitter.emit('fire', 'Fire!');</span></pre><p id="a63f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">此代码块:</p><ol class=""><li id="341c" class="md me hi ix b iy iz jc jd jg mf jk mg jo mh js mi mj mk ml bi translated">导入事件模块</li><li id="3e39" class="md me hi ix b iy mm jc mn jg mo jk mp jo mq js mi mj mk ml bi translated">创建新的发射器对象</li><li id="0aa1" class="md me hi ix b iy mm jc mn jg mo jk mp jo mq js mi mj mk ml bi translated">为接受一个参数的“fire”事件创建侦听器</li><li id="a9b2" class="md me hi ix b iy mm jc mn jg mo jk mp jo mq js mi mj mk ml bi translated">用参数<code class="du lz ma mb lq b">Ready!</code>发出“火灾”事件</li><li id="1687" class="md me hi ix b iy mm jc mn jg mo jk mp jo mq js mi mj mk ml bi translated">我们创建的发射器从发射器获取参数并记录下来。</li><li id="599f" class="md me hi ix b iy mm jc mn jg mo jk mp jo mq js mi mj mk ml bi translated">用<code class="du lz ma mb lq b">Aim!</code>和<code class="du lz ma mb lq b">Fire!</code>重复步骤4和5</li></ol><p id="707d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是预期的正确输出:</p><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="d6cc" class="kw ju hi lq b fi lu lv l lw lx">Ready!<br/>Aim!<br/>Fire!</span></pre><h1 id="12eb" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">其他类型的事件发射器</h1><p id="093d" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">有许多不同的模块、包、框架等..它们都以不同的方式利用事件发射器。</p><p id="c545" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Angular以我们上面使用的方式使用事件发射器，它们也使用事件发射器在父组件和子组件之间来回传递触发器。</p><p id="3353" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">节点的文件系统模块<code class="du lz ma mb lq b">fs</code>在创建流时使用它们。当这些流中发生某个动作时，它们会发出事件。像这样:</p><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="7527" class="kw ju hi lq b fi lu lv l lw lx">var fs = require(‘fs’);<br/>var rs = fs.createReadStream(‘./somefile.txt’);<br/>rs.on(‘open’, function () {<br/> console.log(‘File opened’);<br/>});</span></pre><p id="7f85" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在上面的代码块中，我们创建一个读取流，然后创建一个事件侦听器来读取流发出的事件。这样，当文件被打开时，我们就可以创建一个侦听器，在它被打开时被调用，而不是永远等待它被打开。</p><h1 id="9a15" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">结论</h1><p id="60dd" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">事件发射器和监听器对于NodeJS开发和许多其他编程语言的开发至关重要。当你有一些函数需要“每当其他事情发生时”执行时，它们非常有用，而不需要该函数完成或甚至为此工作。</p></div></div>    
</body>
</html>