# 实现 Web 客户端

> 原文：<https://medium.com/swlh/thundering-web-requests-part-1-309177dabe65>

## 雷鸣般的 Web 请求:第 1 部分

这是探索 web 服务相关技术系列文章的第一篇。它记录了我使用不同技术实现 web 客户端的观察结果。

![](img/7f891773bf173f59bc2504d0bea6bfc8.png)

# 语境

最近，我想探索 web 服务技术。我决定通过模拟和处理大量的 web 请求来进行这种探索。

作为这项工作的一部分，其中一项任务是

> 实现一个 web 客户端，它接受一个 URL 和一个正整数 N 作为命令行参数，并向该 URL 发出 N 个并发的 HTTP GET 请求。

客户机还报告每个 HTTP GET 请求到 URL U 所用的时间(延迟),以及 N 个请求中成功/失败的次数。

# 技术选择

我选择了四种技术来实现客户机的四种变体。

影响这些选择的两个常见原因是:

*   探索开发 web 服务相关解决方案的支持。
*   探索对程序并发的支持。

除此之外，这些选择还受到一些特定于技术的次要原因的影响。

1.  [Erlang](http://www.erlang.org/) :我没有用过 Erlang，我想尝试一下。
2.  [Elixir](https://elixir-lang.org/) + [HTTPoison](https://hexdocs.pm/httpoison/readme.html) :在我使用 Erlang 的内置库构建了客户端之后，我很想看看使用 Elixir 与使用 Erlang 在开发体验和执行性能方面是否会有所不同。对 HTTPoison 的选择相当随意。
3.  Go:我以前用过 Go，我想用它做更多的事情。
4.  [kot Lin](http://kotlinlang.org/)+[vert . x](https://vertx.io/):我过去使用过这两种技术，我想拥有一个基于常用技术的客户端，即 JVM。

# 实施选择

我想保持源工件和使用源工件的过程简单和容易，同时在使用技术时跳过必要的“障碍”。因此，考虑到客户端的简单性，我将开发变体作为黑客练习，尽量少地使用代码之外的软件工程实践。具体来说，只要不违反上述条件，

1.  变体被编码为单个文件，而不遵循社区惯例，例如包、文件夹布局。
    例如，Go 客户端被编码到一个*主*包中，该包存储在顶层文件夹中。类似地，Kotlin 客户端既没有嵌入到包中，也没有嵌入到文件夹中。
2.  如果一个变体可以被编码成一个脚本并在编译模式下执行，那么它就可以被编码成一个脚本而不需要使用构建脚本。
    例如，Erlang 客户端被编码成一个单独的脚本文件，可以使用 Erlang 的 [escript](http://erlang.org/doc/man/escript.html) 工具编译和执行。类似地，Kotlin 客户端被编码为一个单独的脚本文件，可以使用 [KScript](https://github.com/holgerbrandl/kscript) 进行编译和执行。
3.  如果一个变体需要依赖关系，那么就使用一个工具来获取依赖关系。
    例如，由于 Elixir 客户端依赖于 HTTPoison 库，所以使用了 [Mix](https://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html) 构建工具。依赖关系是通过 mix.exs (build)文件指定的，mix 用于在构建客户端之前下载和编译依赖关系。

# 观察

## 语言

第一次用 Erlang 编码很有趣。Erlang 中的函数声明无缝地包含了模式匹配，以进行基于值的大小写拆分(而不是依赖于基于标志/选项的条件)。它还支持使用模式匹配将复合值(如结构和列表)解构(投影)到它们的组件中，并能够只挑选感兴趣的组件。我觉得这样既优雅又直观。模式匹配也可以在 Elixir 的函数声明中起到类似的效果。

## 并发

因为 Erlang 和 Go 都有内置的核心特性，可以轻松地产生并发计算并使用消息传递通信，所以调度并发请求很容易。Elixir 也是如此，因为它的目标是 Erlang 的 VM。

至于基于 Vert.x 的 Kotlin 变体，这甚至更容易，因为它的 API 接受一个回调，当请求完成时将调用这个回调。

## 图书馆和文献

Erlang 的内置库对于这个练习来说已经足够了。我最终使用了核心的 httpc 库。因为这是我第一次使用 Erlang，所以我花了一些时间来理解 Erlang 的文档模式。虽然文档中使用的术语的额外超链接可以简化导航和搜索，但我真的很喜欢 Erlang 文档的结构，因为它模仿了 Erlang 中代码/API 和数据的结构。

虽然我可以将 Erlang 的 httpc 库与 Elixir 一起使用，但我决定不这样做，只是为了探索一个 Elixir 库。虽然 HTTPoison 的文档很好，但我觉得包含一个完整的示例会更有帮助。这个限制可能是因为我是一个新手。总的来说，我喜欢在一个中心位置(https://hexdocs.pm)存放 Elixir 库(十六进制包)文档的想法。

像 Erlang 一样，Go 的内置库对于这个练习来说是相当自给自足的。我最终使用了 core [http](https://golang.org/pkg/net/http/) 包。我非常喜欢文档的示例部分，因为它有助于快速了解软件包的功能以及如何组合这些功能。

虽然 Vert.x 在功能上是自给自足的，但我发现它的文档(像 JVM 生态系统中的其他库一样)有局限性。具体来说，虽然关于“如何使用 capability X”的文档很好，但它似乎与相关 API 的文档“脱节”。此外，考虑到不同 API 和模块的数量(例如，core vs web)，在 API 文档中根据名称搜索适当的 API 既不简单也不容易。我认为这与 javadoc 风格的文档有更大的关系。[如果你很好奇，比较一下`httpc`包和`httpc::request`方法是如何在 Erlang 中记录的，以及`Web`模块和`sendXXX`方法是如何在 Vert.x 中记录的]

独立于语言之外，我惊喜地发现可以轻松使用 web 服务的支持。在库方面有很多选择，而且大多数都很容易使用。我想这可能是微服务繁荣的一个原因:)

## 工具作业

虽然在 Go 中构建客户端的工具很简单(例如`go build`)，但我真的很喜欢 Kotlin(通过 KScript)和 Erlang(通过 escript)对编译模式下执行脚本的支持。KScript 支持通过使用注释来管理依赖关系。这在许多情况下消除了构建文件的负担，这些情况下使用的脚本以简单、快速和短暂等形容词为特征。我在 escript 中没有找到类似的支持。因此，如果我在 Erlang 客户机中使用了外部库，那么我对 Erlang 的体验会有所不同。

相比之下，由于 Elixir 客户机依赖于 HTTPoison，所以我使用了 Mix 工具和一个“构建”文件来捕获依赖关系。虽然文件本身不是问题，但是使用 Mix 需要像使用任何其他构建工具一样做更多的工作，例如，创建项目，了解各种构建相关文件的相关性，对这些文件进行适当的更改；在下一篇文章中会有更多的介绍。我认为在简单的情况下这是一个不必要的障碍。

[如果有一种方法可以使用 escript 来管理依赖项和执行脚本(比如 KScript)，那么请告诉我如何使用。]

## 电码长度

就 LOC 而言，Kotlin 是最短的实现，其次是 Erlang、Go 和 Elixir。虽然我预期 Go 客户端会很长，但令我惊讶的是，Elixir 客户端也几乎一样长。我不确定这是我如何实现 Elixir 客户端的产物，还是 Elixir 的设计和生态系统。

## 代码复杂性

由于任务本身的简单性和调度 HTTP 请求的丰富库支持，所有的客户机都相当简单。

# 源代码

所有客户端的代码都可以在 [GitHub](https://github.com/rvprasad/thundering-web-requests) 上获得。

# 接下来

我的下一篇文章将是关于使用不同技术实现 web 服务 的[观察。](/@rvprasad/thundering-web-requests-part-2-de040873c4da?source=friends_link&sk=c5a574b75d9c9b105d3b2c98185b1506)

# 笔记

## 2019 年 8 月 20 日:发现 Erlang 中的 http 客户端问题

在使用客户机评估服务器的过程中，erlang 客户机有时会挂起。虽然实现处理了 HTTP 请求的成功和失败，以及发出 HTTP 请求的衍生进程的异常失败，但似乎有一个条件没有被涵盖。感谢来自 Erlang 社区的输入(通过 Slack)，我用一个无所不包的处理程序扩展了客户端。有趣的是，这个处理程序在挂起运行期间没有被触发。

因此，在这一点上，我认为要么 Erlang 中的 httpc 库在一些罕见的情况下被破坏，要么该库需要进行适当的配置，以处理客户端可能发出大量并发请求的情况，例如 3200。不管怎样，我都不会使用 Erlang client 来评估服务器。