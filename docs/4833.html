<html>
<head>
<title>Universal CICD pipeline for K8S on AWS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">AWS上K8S的通用CICD管道</h1>
<blockquote>原文：<a href="https://medium.com/swlh/universal-cicd-pipeline-on-aws-and-k8s-7b4129fac5d4?source=collection_archive---------6-----------------------#2019-06-05">https://medium.com/swlh/universal-cicd-pipeline-on-aws-and-k8s-7b4129fac5d4?source=collection_archive---------6-----------------------#2019-06-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><blockquote class="if ig ih"><p id="bed1" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated">在抽象的层面上，部署管道是将软件从版本控制交付到用户手中的过程的自动化表现。</p></blockquote><p id="5c14" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">CI/CD这个术语现在在行业中被广泛使用。您可能听说过持续集成、持续交付或持续部署。这是一个有很多名字的概念，但是包含了一些基本的思想。简而言之，它概述了保持代码更易维护、更易测试以及更快到达用户手中的实践。最终，它为用户和消费者创造价值。</p><p id="1f4b" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">乍一看，它似乎最适合企业或一些风险投资。但是通过理解它的价值，你会发现CICD是有价值的，无论你是在构建可伸缩的企业应用程序，还是只是让你的个人项目开始运行。</p><h2 id="522d" class="jk jl hi bd jm jn jo jp jq jr js jt ju jh jv jw jx ji jy jz ka jj kb kc kd ke bi translated">去耦基础设施</h2><blockquote class="if ig ih"><p id="842e" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated">开发系统，而不是软件</p></blockquote><p id="c11e" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated"><em class="ik">微服务</em>在我们的行业中是一个广泛使用的术语。它有许多形状和定义，取决于你问谁或你想讨论的细节程度。但是我们都同意一件事:您的应用程序的智能解耦是我们要走的路。无论是基于有界的上下文还是应用程序类型，您都有在项目中分离服务的标准。</p><p id="f2a4" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">因此，尽早考虑这一点是个好主意。许多开发人员从一开始就设计了一定程度的解耦。这需要一些前瞻性的思考，因为您需要决定解耦标准和您将用于这个范围的工具。这些工具代表基础架构(AMQP、数据库、存储等)。</p><p id="b1d8" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">除了这篇关于解耦技术和工具的文章，我还可以继续写下去。但是在这里，我将提到我在这个例子中使用的工具，并回到CICD管道。</p><h2 id="a92e" class="jk jl hi bd jm jn jo jp jq jr js jt ju jh jv jw jx ji jy jz ka jj kb kc kd ke bi translated">输入AWS和K8S</h2><p id="954a" class="pw-post-body-paragraph ii ij hi il b im kf io ip iq kg is it jh kh iw ix ji ki ja jb jj kj je jf jg hb bi translated">维护基础设施的一种通用(快速)方法是通过云系统，因为它们提供了大量的抽象工具。我使用AWS的各种工具。具体来说:</p><ul class=""><li id="d656" class="kk kl hi il b im in iq ir jh km ji kn jj ko jg kp kq kr ks bi translated">CICD管道建设代码管道</li><li id="785a" class="kk kl hi il b im kt iq ku jh kv ji kw jj kx jg kp kq kr ks bi translated">用于在管道步骤中运行构建命令的代码构建</li><li id="05bc" class="kk kl hi il b im kt iq ku jh kv ji kw jj kx jg kp kq kr ks bi translated">ECR(弹性容器注册表)作为构建结果图像的存储库。</li><li id="7c29" class="kk kl hi il b im kt iq ku jh kv ji kw jj kx jg kp kq kr ks bi translated">用于存储的S3</li></ul><p id="7ad6" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">Kubernetes (K8S)是一个Docker容器编制器。它应用IaC(基础设施即代码)模式来提供进一步的抽象。通过将YAML格式文件应用到K8S，我们可以更新它的状态，部署容器或其他对象。</p><p id="2f02" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">我将使用托管在AWS上的K8S。这可以用<em class="ik"> kops来完成。</em> <a class="ae ky" rel="noopener" href="/containermind/how-to-create-a-kubernetes-cluster-on-aws-in-few-minutes-89dda10354f4">这里的</a>是一篇解释如何做的好文章。</p><h2 id="72a4" class="jk jl hi bd jm jn jo jp jq jr js jt ju jh jv jw jx ji jy jz ka jj kb kc kd ke bi translated">环球CICD</h2><p id="73df" class="pw-post-body-paragraph ii ij hi il b im kf io ip iq kg is it jh kh iw ix ji ki ja jb jj kj je jf jg hb bi translated">是的，很好。但是CICD在这一切中扮演什么角色呢？好吧，我从解释解耦开始，以奠定需要由上下文划分的几个服务的想法。我们开发的服务可能有不同的部署需求。运行环境可能因端点、依赖关系等而有所不同。</p><p id="ee77" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">出于这个原因，我们通常为每个项目准备一条CICD管道。</p><p id="7908" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">基础设施的抽象(由K8S提供)在这里非常有用，因为它允许我们在代码库的YAML文件中设置环境需求。</p><p id="816e" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">继续这个概念，我们可以抽象出CICD管道本身。使得它不知道项目类型、构建和部署需求。</p><p id="9ff3" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">通过在我们的解决方案中包含这3个组件:</p><ul class=""><li id="89ce" class="kk kl hi il b im in iq ir jh km ji kn jj ko jg kp kq kr ks bi translated">生成命令文件。(AWS代码构建的Buildspec.yml)</li><li id="265f" class="kk kl hi il b im kt iq ku jh kv ji kw jj kx jg kp kq kr ks bi translated">正在运行的应用程序的Dockerfile文件映像</li><li id="9a76" class="kk kl hi il b im kt iq ku jh kv ji kw jj kx jg kp kq kr ks bi translated">K8S对象YAML文件，用于部署需求。</li></ul><p id="0c7a" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">我们拥有关于如何构建、测试和部署任何服务的所有信息。</p><h2 id="2467" class="jk jl hi bd jm jn jo jp jq jr js jt ju jh jv jw jx ji jy jz ka jj kb kc kd ke bi translated">CICD模式演示</h2><blockquote class="if ig ih"><p id="d2b8" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated">作为开发人员，我们拥有的最强大的工具是自动化</p></blockquote><figure class="la lb lc ld fd le er es paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="er es kz"><img src="../Images/b88e19c055542283d1eb1fabb71ede2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v-kfm5jhb80QPxWIC1r1gA.png"/></div></div><figcaption class="ll lm et er es ln lo bd b be z dx">CICD Schema</figcaption></figure><p id="7177" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">每次提交时都必须触发管道。它应该提取源文件，而不使用任何存储库的特定信息。</p><p id="8399" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">为了实现这一点，管道将由GitHub webhook触发。这允许不同项目的多种用途。</p><p id="89a0" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">通过API Gateway，webhook将调用AWS Lambda函数。这个函数将提取git存储库并将其压缩到一个S3桶中。</p><p id="c4df" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">每当S3对象更新时，都可以触发AWS代码管道。它“监视”我们的zip文件，每当它被更新时就触发管道。</p><p id="6506" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">CodeBuild使用解决方案中的buildspec.yml文件来生成和运行测试。</p><p id="4df9" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">接下来，将构建一个Docker映像并将其推送到AWS ECR。</p><p id="ab59" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">最后，解决方案中的YML文件将应用于AWS上现有的K8S集群。通常，这会导致从ECR中提取Docker映像，并将其部署到K8S中的容器中。</p><p id="8ea0" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">概括地说，管道可以构建和部署任何项目，只要它提供</p><ul class=""><li id="ee43" class="kk kl hi il b im in iq ir jh km ji kn jj ko jg kp kq kr ks bi translated">包含构建环境必备条件和命令的Buildspec.yml文件</li><li id="7bd1" class="kk kl hi il b im kt iq ku jh kv ji kw jj kx jg kp kq kr ks bi translated">order文件图像，以便将其推送到ECR</li><li id="e5f7" class="kk kl hi il b im kt iq ku jh kv ji kw jj kx jg kp kq kr ks bi translated">“/k8s”文件夹下的Kubernetes部署文件</li></ul><p id="4d73" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">所以让我们一步一步来。我使用一个SCALA PLAY项目作为例子。你可以在这里找到项目所需的<a class="ae ky" href="https://github.com/hasael/hello-play" rel="noopener ugc nofollow" target="_blank">文件。</a></p><h2 id="fc08" class="jk jl hi bd jm jn jo jp jq jr js jt ju jh jv jw jx ji jy jz ka jj kb kc kd ke bi translated">AWS Lambda和API网关</h2><p id="2f3f" class="pw-post-body-paragraph ii ij hi il b im kf io ip iq kg is it jh kh iw ix ji ki ja jb jj kj je jf jg hb bi translated">我们可以使用API Gateway公开AWS Lambda函数的端点。在我们的GitHub项目中将这个端点设置为webhook。</p><p id="083c" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">Lambda函数在GitHub发送的json文件上找到GitHub URL，将解决方案拉到一个临时目录中，创建一个zip文件，并将其上传到S3 bucket。这将在每次提交时触发。</p><p id="9788" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">产生的zip将被更新到S3桶，这将触发管道。</p><figure class="la lb lc ld fd le er es paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="er es lp"><img src="../Images/ae179ca1398c8e34d8a649cd1695486e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*beQ-W8zesVhV1-TlAeMlAw.png"/></div></div></figure><p id="276e" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">在AWS Lambda上，我使用NodeJs版。</p><p id="4c60" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">你可以在这里找到Lambda函数<a class="ae ky" href="https://github.com/hasael/github-webhook-deploy" rel="noopener ugc nofollow" target="_blank"><em class="ik"/></a><em class="ik">，</em>写成NodeJs <em class="ik">。</em></p><p id="8139" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">非常感谢Enki使用lambda-git的这个<a class="ae ky" href="https://blog.enki.com/using-git-on-aws-lambda-f365a2db706b" rel="noopener ugc nofollow" target="_blank"> <em class="ik"> hack </em> </a>。</p><h2 id="1fbf" class="jk jl hi bd jm jn jo jp jq jr js jt ju jh jv jw jx ji jy jz ka jj kb kc kd ke bi translated">管道</h2><p id="8e24" class="pw-post-body-paragraph ii ij hi il b im kf io ip iq kg is it jh kh iw ix ji ki ja jb jj kj je jf jg hb bi translated">以下是AWS CodePipeline中的管道概述。</p><figure class="la lb lc ld fd le er es paragraph-image"><div class="er es lq"><img src="../Images/9dfa4a6440868b58d171a5756e9ca6d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:698/format:webp/1*DXrcvIX0P-29HLAcvbHdVA.png"/></div></figure><p id="ffcc" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">第一步由特定对象上传到S3触发。这个对象将由前面的lambda函数更新。这一步生成“源工件”，它是一个包含源文件的. zip文件。</p><p id="2ee4" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">“源工件”被发送到构建步骤。解决方案被编译、测试，并生成作为“构建工件”的构建结果文件。</p><p id="9595" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">这个工件被发送到Push-ECR步骤。docker文件是使用“构建工件”文件构建的，并被推送到ECR。</p><p id="145b" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">最后，Apply-KOPS步骤使用kubectl应用K8S上的“源工件”上的YAML文件。此外，它将K8S YML文件保存到S3存储桶中。这存储了关于当前基础设施的信息。</p><h2 id="ceba" class="jk jl hi bd jm jn jo jp jq jr js jt ju jh jv jw jx ji jy jz ka jj kb kc kd ke bi translated">连续累计</h2><p id="4804" class="pw-post-body-paragraph ii ij hi il b im kf io ip iq kg is it jh kh iw ix ji ki ja jb jj kj je jf jg hb bi translated">构建步骤是这里概述的AWS代码构建项目。为了配置CodeBuild项目，我们指定一个构建环境和构建命令。</p><figure class="la lb lc ld fd le er es paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="er es lr"><img src="../Images/67d9e0de1b56ea5c5864eb62bbb3b4fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2T9zuU7gjaoBcwByhg9mPw.png"/></div></div></figure><p id="83f0" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">构建环境是CodeBuild标准1.0 -1.8.0。</p><p id="5fa2" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">在幕后，AWS CodeBuld创建了这些Docker映像作为构建环境。更多信息，你可以查看这些图片<a class="ae ky" href="https://github.com/aws/aws-codebuild-docker-images" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><figure class="la lb lc ld fd le er es paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="er es ls"><img src="../Images/4c4b6acc90851e8f268b78fd8b5a6109.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Gu50ne5vYmBhuI8i9iargw.png"/></div></div></figure><p id="82dd" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">该项目将从源代码中获取Buildspec.yml文件。YAML文件包含要执行的构建命令。</p><p id="4425" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">下面是SCALA PLAY中一个项目的buildspec文件。</p><figure class="la lb lc ld fd le"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="09d1" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">项目将开始编译并运行测试。如果一切都是绿色的，将会创建一个zip文件作为构建工件。它将包含运行应用程序所需的所有文件。</p><h2 id="87c3" class="jk jl hi bd jm jn jo jp jq jr js jt ju jh jv jw jx ji jy jz ka jj kb kc kd ke bi translated">推送Docker图像</h2><p id="7b41" class="pw-post-body-paragraph ii ij hi il b im kf io ip iq kg is it jh kh iw ix ji ki ja jb jj kj je jf jg hb bi translated">在这个阶段，会创建一个Docker映像并将其推送到ECR。这也是由代码构建项目完成的。</p><figure class="la lb lc ld fd le er es paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="er es lv"><img src="../Images/937d386fc2c47eb71e536350c86db6dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IaebqhSKgYsBTQRrNWMQlQ.png"/></div></div></figure><p id="ba16" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">我们将buildspec命令直接插入到项目中。这些命令要求在源根目录上有一个Dockerfile。这需要构建工件文件来创建运行应用程序的映像。构建映像并将其推送到AWS ECR。</p><p id="21c6" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">Dockerfile映像运行应用程序，假设它是构建的。</p><p id="9ec6" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">下面是一个Dockerfile文件，用于在SCALA的PLAY框架中运行一个项目。它解压缩构建结果，并使用提供的密钥运行它。</p><figure class="la lb lc ld fd le"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="8452" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">构建环境是相同的标准1.0 -1.8.0。</p><h2 id="2bc7" class="jk jl hi bd jm jn jo jp jq jr js jt ju jh jv jw jx ji jy jz ka jj kb kc kd ke bi translated">部署到K8S</h2><p id="bba6" class="pw-post-body-paragraph ii ij hi il b im kf io ip iq kg is it jh kh iw ix ji ki ja jb jj kj je jf jg hb bi translated">假设“k8s”文件夹下的所有YML文件都是Kubernetes对象(通常是部署和服务)。这些文件被提取并应用到Kubernetes集群。为了做到这一点，我们需要kubectl。我使用这个Docker映像作为CodeBuild的定制构建环境。</p><figure class="la lb lc ld fd le"><div class="bz dy l di"><div class="lt lu l"/></div><figcaption class="ll lm et er es ln lo bd b be z dx">Docker image with kops and kubectl</figcaption></figure><p id="ff8b" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">将这个映像推送到ECR存储库中，并将其设置为构建环境。</p><figure class="la lb lc ld fd le er es paragraph-image"><div class="er es lw"><img src="../Images/686022cd228a6c7fa2f293ce616a0d2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1236/format:webp/1*XNrjiiypYue7D0ZMyrA2LQ.png"/></div></figure><p id="a307" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">这个项目的构建规范如下</p><figure class="la lb lc ld fd le"><div class="bz dy l di"><div class="lt lu l"/></div><figcaption class="ll lm et er es ln lo bd b be z dx">kops apply buildspec</figcaption></figure><p id="dec7" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">文件夹下的所有K8S对象”。/k8s/”被应用，然后被保存到S3桶，以存储当前集群状态供将来参考。Kubectl使用“export kubecfg”命令获取K8S集群配置。</p><p id="672a" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">例如，这些是SCALA PLAY中项目的K8S对象。</p><figure class="la lb lc ld fd le"><div class="bz dy l di"><div class="lt lu l"/></div><figcaption class="ll lm et er es ln lo bd b be z dx">Kubernetes yaml files to apply</figcaption></figure><p id="132a" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">通过K8S，这将导致部署Docker容器。此外，AWS将创建一个指向容器的负载平衡器。</p><h2 id="2e6f" class="jk jl hi bd jm jn jo jp jq jr js jt ju jh jv jw jx ji jy jz ka jj kb kc kd ke bi translated">结论</h2><p id="e297" class="pw-post-body-paragraph ii ij hi il b im kf io ip iq kg is it jh kh iw ix ji ki ja jb jj kj je jf jg hb bi translated">对于开发人员来说，能够仅通过代码来部署服务是一个强大的工具。通过这样做，您可以在几个服务上工作，并以一种分离的模式部署它们的基础设施。同时保持CICD的优势，而不必担心其具体实施。</p><p id="f33c" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">实现抽象的下一步可能是在解决方案中使用bash命令，而不是特定于CodeBuild的Buildspec。使其与Jenkins或其他构建工具兼容。</p></div></div>    
</body>
</html>