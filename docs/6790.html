<html>
<head>
<title/>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1/>
<blockquote>原文：<a href="https://medium.com/swlh/playing-with-pandas-logically-eda40bbfd4c6?source=collection_archive---------81-----------------------#2019-06-24">https://medium.com/swlh/playing-with-pandas-logically-eda40bbfd4c6?source=collection_archive---------81-----------------------#2019-06-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/8abbe0fff2ef3fc5707e532c26e7d9ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3GDZtig-cC9yaZCiJe2CHQ.png"/></div></div></figure><p id="22da" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated">一个数据科学家必须用熊猫来训练自己，以获得良好的数据框架。因此，在这篇文章中，我将向你展示我们如何实现一种结构，这种结构可以用来从另一个角度处理数据库。</p><p id="09e9" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated">为此，这里是Python中的类:<em class="iq"> Context </em>。而且，为了更好地训练我们的<em class="iq">熊猫</em>，我们将尝试这些特殊的…</p><pre class="ir is it iu fd iv iw ix iy aw iz bi"><span id="e1fc" class="ja jb ht iw b fi jc jd l je jf">&gt;&gt;&gt; A = Context(V1 = True, V2 = False, V3 = None)<br/>&gt;&gt;&gt; A<br/>Context: at least 2 cases. <br/>    0<br/>V1  1<br/>V2  2<br/>V3  3</span></pre><p id="78c2" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated">乍一看，它是一个数据帧的扩展，使用三个值的逻辑来表示一个状态。但是当在其他环境中操作时，我们会意识到我们可以在更大或更小的程度上使实现复杂化，这就是为什么我在这里为将来的使用或改变留下一个非常具体的建议。</p><pre class="ir is it iu fd iv iw ix iy aw iz bi"><span id="c4d0" class="ja jb ht iw b fi jc jd l je jf">&gt;&gt;&gt; B = Context(V1 = True)<br/>&gt;&gt;&gt; A*B<br/>Context: at least 2 cases. <br/>    0<br/>V1  1<br/>V2  2<br/>V3  3<br/>&gt;&gt;&gt; A+B<br/>Context: at least 4 cases. <br/>    -1   0   1<br/>V1   1   1   1<br/>V2   2   2   3<br/>V3   3   3   3</span></pre><p id="5b8f" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated">如您所见，乘积将表示一个AND运算符，您可以使用ADD运算符计算新的事例。这是很重要的一点:该建议将每个新的<em class="iq">系列</em>添加到<em class="iq">数据帧</em>中，并以负数计算重复次数；但是我们不在乎太多的负数。在这篇文章中，它将不会有趣。</p><p id="e907" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated">考虑到<a class="ae jg" href="https://en.wikipedia.org/wiki/Inclusion%E2%80%93exclusion_principle" rel="noopener ugc nofollow" target="_blank">包含-排除</a>原则，该实施将减少从条目中考虑的案例数…</p><figure class="ir is it iu fd hk er es paragraph-image"><div class="er es jh"><img src="../Images/8529c3b93f6c7846e434b0031c4e7c58.png" data-original-src="https://miro.medium.com/v2/resize:fit:440/format:webp/1*0JyK5cslkLIzmdNGXmdzwg.png"/></div><figcaption class="ji jj et er es jk jl bd b be z dx">|A U B| = |A| + |B| — |A ∩ B|</figcaption></figure><p id="d2f0" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated">如果结果似乎不重要，我将在最后展示几个使用示例来展示我们工作的威力。但是，目前，享受与熊猫玩耍的乐趣。</p><h1 id="e617" class="jm jb ht bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">实施</h1><p id="32e0" class="pw-post-body-paragraph hr hs ht hu b hv kj hx hy hz kk ib ic id kl if ig ih km ij ik il kn in io ip hb bi translated">首先，让我们看看如何创建构建器，以及两个数据帧是如何在外部表示的。</p><pre class="ir is it iu fd iv iw ix iy aw iz bi"><span id="eb71" class="ja jb ht iw b fi jc jd l je jf">from pandas import DataFrame</span><span id="9225" class="ja jb ht iw b fi ko jd l je jf">class Context:<br/>    def __init__(self, **argvs):<br/>        'feature = Boolean/None'<br/>        self.df = DataFrame({0:[2-int(X if X is not None else -1) \<br/>                                for X in argvs.values()]},<br/>                                   index=argvs.keys(),<br/>                                   dtype=int)<br/>        self.nf = DataFrame({}, index = argvs.keys(), dtype = int)<br/>    def clone(self):<br/>        R = Context()<br/>        R.df = self.df.copy(deep = True)<br/>        R.nf = self.nf.copy(deep = True)<br/>        return R<br/>    def __len__(self):<br/>        'counts the number of logical cases'<br/>        return (2**(self.df == 3).sum()).sum()\<br/>               - (2**(self.nf == 3).sum()).sum() <br/>    def __repr__(self):<br/>        if self.nf.empty:<br/>            return 'Context: at least ' + repr(len(self))\<br/>                   + ' cases. \n' + repr(self.df)<br/>        else:<br/>            return 'Context: at least ' + repr(len(self)) \<br/>                   + ' cases. \n' + repr(self.df.add(<br/>                    Context.shift(self.nf, -max(self.nf.columns)-1),<br/>                        fill_value=0).applymap(int))<br/>    @staticmethod<br/>    def shift(dataFrame, nc):<br/>        D = dataFrame.to_dict()       <br/>        return DataFrame({X + nc: value \<br/>                          for X, value in D.items()})</span></pre><p id="76c0" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated">在此代码中，您可以考虑的事情有:</p><ul class=""><li id="cf74" class="kp kq ht hu b hv hw hz ia id kr ih ks il kt ip ku kv kw kx bi translated">在3值逻辑中:1为<em class="iq">真</em>，2为<em class="iq">假</em>，3为<em class="iq">不定</em>。</li><li id="0ed3" class="kp kq ht hu b hv ky hz kz id la ih lb il lc ip ku kv kw kx bi translated">变量可以被解读为每个案例的特征。如<em class="iq">椅</em>定义:<em class="iq">可用于安装</em>的情况下的特征。特征是<em class="iq">索引</em>，定义或案例是<em class="iq">列</em>。</li><li id="5063" class="kp kq ht hu b hv ky hz kz id la ih lb il lc ip ku kv kw kx bi translated"><em class="iq">索引</em>是标识符<em class="iq">列</em>是整数。</li><li id="fc97" class="kp kq ht hu b hv ky hz kz id la ih lb il lc ip ku kv kw kx bi translated"><em class="iq"> df </em>用于进计数，<em class="iq"> nf </em>用于出计数。</li><li id="a1b5" class="kp kq ht hu b hv ky hz kz id la ih lb il lc ip ku kv kw kx bi translated"><em class="iq"> shift </em>用于重命名列，以便在<em class="iq"> add </em>操作中合并两个数据帧。</li></ul><p id="23eb" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated">让我们看一个使用<em class="iq">换档</em>的例子:</p><pre class="ir is it iu fd iv iw ix iy aw iz bi"><span id="803d" class="ja jb ht iw b fi jc jd l je jf">&gt;&gt;&gt; Context.shift((Context(V1 = True) + Context(V2 = False)).df, 12)<br/>    12  13<br/>V1   1   3<br/>V2   3   2</span></pre><p id="e52c" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated">现在让我们开始操作…</p><h2 id="3c4f" class="ja jb ht bd jn ld le lf jr lg lh li jv id lj lk jz ih ll lm kd il ln lo kh lp bi translated">功率方法</h2><p id="deb2" class="pw-post-body-paragraph hr hs ht hu b hv kj hx hy hz kk ib ic id kl if ig ih km ij ik il kn in io ip hb bi translated">我们遇到的第一个问题是，对于两个<em class="iq">数据帧</em>之间的操作，我们需要它们必须有相同的索引。这就是pow方法的原因:用他人的指标来调整自己的指标。</p><pre class="ir is it iu fd iv iw ix iy aw iz bi"><span id="02b0" class="ja jb ht iw b fi jc jd l je jf">&gt;&gt;&gt; A = Context(V1 = True)<br/>&gt;&gt;&gt; A ** Context(V2 = True)<br/>Context: at least 2 cases. <br/>    0<br/>V1  1<br/>V2  3</span></pre><p id="70ca" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated">因此，pow方法可以在新索引中添加<em class="iq">不确定的</em>值。</p><pre class="ir is it iu fd iv iw ix iy aw iz bi"><span id="2118" class="ja jb ht iw b fi jc jd l je jf">def __pow__(self, other):<br/>        'adjust self indexes by the indexes of other'<br/>        indexes = set(other.df.index) - set(self.df.index)<br/>        if not indexes:<br/>            return self<br/>        dfPattern = DataFrame({y: [3]*len(indexes) \<br/>                               for y in range(self.df.shape[1])},<br/>                                  index = indexes)<br/>        result = Context()<br/>        result.df = self.df.add(dfPattern, axis='rows',<br/>                                fill_value=0).applymap(int)<br/>        nfPattern = DataFrame({y: [3]*len(indexes) \<br/>                               for y in range(self.nf.shape[1])},<br/>                                  index = indexes)<br/>        if not self.nf.empty:<br/>            result.nf = self.nf.add(nfPattern, axis='rows',<br/>                                    fill_value=0).applymap(int)<br/>        else:<br/>            result.nf = DataFrame({},<br/>                index = set(self.df.index).union(other.df.index),<br/>                dtype = int)<br/>        return result</span></pre><p id="e0db" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated">关于上述代码的注意事项:</p><ul class=""><li id="9782" class="kp kq ht hu b hv hw hz ia id kr ih ks il kt ip ku kv kw kx bi translated">如果<em class="iq">数据帧</em>为空，你只需要更新union操作符设置的索引。但是这个操作符总是至少处理一种情况。</li><li id="0b9d" class="kp kq ht hu b hv ky hz kz id la ih lb il lc ip ku kv kw kx bi translated">通过添加<em class="iq">数据帧</em>来添加新的索引后(如果在有<strong class="hu lq"> NaN </strong>的地方放一个<strong class="hu lq"> 0 </strong>，结果是<strong class="hu lq"> float </strong>。所以你必须对每个元素应用一个函数来把它转换成int。</li></ul><p id="18ae" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated">add和mult将以这种方式使用pow方法:</p><pre class="ir is it iu fd iv iw ix iy aw iz bi"><span id="34f1" class="ja jb ht iw b fi jc jd l je jf">def __mul__(self, other):<br/>        return (self**other) &amp; (other**self)<br/>    <br/>def __add__(self, other):<br/>        return (self**other) | (other**self)</span></pre><p id="42d4" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated">所以现在我们必须研究如何制作<em class="iq">和</em>和<em class="iq">或</em>方法。</p><h2 id="0afa" class="ja jb ht bd jn ld le lf jr lg lh li jv id lj lk jz ih ll lm kd il ln lo kh lp bi translated">和方法</h2><p id="2899" class="pw-post-body-paragraph hr hs ht hu b hv kj hx hy hz kk ib ic id kl if ig ih km ij ik il kn in io ip hb bi translated"><em class="iq">和</em>方法是我们用来确保产生的<em class="iq">上下文</em>有两个集合的交集的操作符。考虑到:</p><ul class=""><li id="13b3" class="kp kq ht hu b hv hw hz ia id kr ih ks il kt ip ku kv kw kx bi">1 &amp; 3 = 3 &amp; 1=1</li><li id="4d99" class="kp kq ht hu b hv ky hz kz id la ih lb il lc ip ku kv kw kx bi">2 &amp; 3 = 3 &amp; 2 =2</li><li id="be24" class="kp kq ht hu b hv ky hz kz id la ih lb il lc ip ku kv kw kx bi">3 &amp; 3 = 3</li><li id="1a83" class="kp kq ht hu b hv ky hz kz id la ih lb il lc ip ku kv kw kx bi">1 &amp; 2 = 2 &amp; 1 = 0</li></ul><p id="df0c" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated">我们必须<em class="iq">清除</em>特征中所有值为<strong class="hu lq"> 0 </strong>的情况:因为这意味着<em class="iq">不可能</em>。</p><pre class="ir is it iu fd iv iw ix iy aw iz bi"><span id="ee29" class="ja jb ht iw b fi jc jd l je jf">@staticmethod<br/>    def clean(dataframe):<br/>        'POST: eliminates cases with 0 results'<br/>        return dataframe.transpose()[dataframe.prod()&gt;0].transpose()<br/>        <br/>    def __and__(self, other):<br/>        'combining cases.'<br/>        'PRE: self and other have the same indices'<br/>        R = Context()<br/>        dictDf= {}<br/>        for i in self.df.columns:<br/>            for j in other.df.columns:<br/>                dictDf[i * other.df.shape[1] + j] \<br/>                         = list(self.df[i] &amp; other.df[j])<br/>        for i in self.nf.columns:<br/>            for j in other.nf.columns:<br/>                dictDf[i * other.df.shape[1] + j] \<br/>                          = list(self.nf[i] &amp; other.nf[j])<br/>        R.df = DataFrame(dictDf,<br/>                         index = self.df.index,<br/>                         dtype = int)<br/>        dictDf= {}<br/>        for i in self.df.columns:<br/>            for j in other.nf.columns:<br/>                dictDf[i * other.df.shape[1] + j] \<br/>                         = list(self.df[i] &amp; other.nf[j])<br/>        for i in self.nf.columns:<br/>            for j in other.df.columns:<br/>                dictDf[i * other.df.shape[1] + j] \<br/>                          = list(self.nf[i] &amp; other.df[j])<br/>        R.nf = DataFrame(dictDf,<br/>                         index = self.df.index,<br/>                         dtype = int)<br/>        R.df = Context.clean(R.df)<br/>        R.nf = Context.clean(R.nf)<br/>        return R</span></pre><p id="4f21" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated">考虑因素:</p><ul class=""><li id="3d89" class="kp kq ht hu b hv hw hz ia id kr ih ks il kt ip ku kv kw kx bi translated">该方法生成一个新的数据帧，它组合了每一列(<em class="iq"> i </em>，<em class="iq"> j </em>)，因此结果必须编码一个新列，编码为<code class="du lr ls lt iw b">i * other.df.shape[1] + j</code></li><li id="5ccc" class="kp kq ht hu b hv ky hz kz id la ih lb il lc ip ku kv kw kx bi translated">(<em class="iq">A</em>\<em class="iq">B</em>)<strong class="hu lq">∩</strong>(<em class="iq">C</em>\<em class="iq">D</em>)=(<em class="iq">A</em>∩<em class="iq">C</em>)U(<em class="iq">B</em>∩<em class="iq">D</em>)\(<em class="iq">A</em>∩<em class="iq">D</em></li><li id="dc53" class="kp kq ht hu b hv ky hz kz id la ih lb il lc ip ku kv kw kx bi translated">生成案例后，其中一些案例将被<em class="iq"> clean </em>方法删除。</li></ul><h2 id="a0dc" class="ja jb ht bd jn ld le lf jr lg lh li jv id lj lk jz ih ll lm kd il ln lo kh lp bi translated">或方法</h2><p id="26ac" class="pw-post-body-paragraph hr hs ht hu b hv kj hx hy hz kk ib ic id kl if ig ih km ij ik il kn in io ip hb bi translated">要添加新案例，我们可以使用<em class="iq">和</em>方法，或者我们可以创建一个<em class="iq">过滤器</em>方法，以便在处理已知案例时进行确认。</p><p id="89ea" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated">因此，假设我们在一个<em class="iq">数据帧</em>和一个<em class="iq">系列</em>之间、一个表和一个列之间实现了一个and操作:</p><pre class="ir is it iu fd iv iw ix iy aw iz bi"><span id="5f4f" class="ja jb ht iw b fi jc jd l je jf">    @staticmethod<br/>    def filter(dataFrame, serie):<br/>        'PRE: dataFrame and serie must have same indexes'<br/>        'POST: returns mask'<br/>        R = dataFrame &amp; DataFrame(<br/>            {X: serie for X in range(dataFrame.shape[1])},<br/>             index = dataFrame.index)<br/>        return Context.clean(R)</span></pre><p id="a665" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated">使用该方法，<em class="iq">或</em>方法更容易:</p><pre class="ir is it iu fd iv iw ix iy aw iz bi"><span id="fcae" class="ja jb ht iw b fi jc jd l je jf">def __or__(self, other):<br/>        'PRE: self and other must have the same indexes'<br/>        'new cases'<br/>        R = Context()<br/>        if not self.df.empty:<br/>            R.df = self.df.add(<br/>                Context.shift(other.df, max(self.df.columns)+1),<br/>                fill_value = 0).applymap(int)<br/>        else:<br/>            R.df = other.df.copy()<br/>        if not self.nf.empty:<br/>            R.nf = self.nf.add(<br/>                Context.shift(other.nf, max(self.nf.columns)+1),<br/>                fill_value = 0).applymap(int)<br/>        else:<br/>            R.nf = other.nf.copy()<br/>        if not self.df.empty and not other.df.empty:<br/>            for i in other.df.columns:<br/>                X = Context.filter(self.df, other.df[i])<br/>                if not X.empty:<br/>                    if R.nf.empty:<br/>                        R.nf = X<br/>                    else:<br/>                        R.nf = self.nf.add(<br/>                           Context.shift(X, max(R.nf.columns)+1),<br/>                           fill_value = 0).applymap(int)<br/>        return R</span></pre><p id="b3da" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated">正如我们在这种情况下添加索引一样，我们使用<em class="iq"> add </em>方法by columns，实现该方法是为了识别比条目所放置的更少的<strong class="hu lq">案例。所以，如果你想识别更多的情况，你可以输入下一个，只增加<strong class="hu lq">一个循环</strong>:</strong></p><pre class="ir is it iu fd iv iw ix iy aw iz bi"><span id="51a6" class="ja jb ht iw b fi jc jd l je jf">def __or__(self, other):<br/>        'PRE: self and other must have the same indexes'<br/>        'new cases and some ghosts'<br/>        R = Context()<br/>        if not self.df.empty:<br/>            R.df = self.df.add(<br/>                Context.shift(other.df, max(self.df.columns)+1),<br/>                fill_value = 0).applymap(int)<br/>        else:<br/>            R.df = other.df.copy()<br/>        if not self.nf.empty:<br/>            R.nf = self.nf.add(<br/>                Context.shift(other.nf, max(self.nf.columns)+1),<br/>                fill_value = 0).applymap(int)<br/>        else:<br/>            R.nf = other.nf.copy()<br/>        if not self.df.empty and not other.df.empty:<br/>            for i in other.df.columns:<br/>                X = Context.filter(self.df, other.df[i])<br/>                if not X.empty:<br/>                    if R.nf.empty:<br/>                        R.nf = X<br/>                    else:<br/>                        #added loop<br/>                        for j in X.columns:<br/>                            Y = Context.filter(R.nf, X[j])<br/>                            if not Y.empty:<br/>                                R.df = R.df.add(<br/>                                    Context.shift(<br/>                                        Y,<br/>                                        max(R.df.columns)+1),<br/>                                    fill_value = 0).applymap(int)<br/>                        R.nf = self.nf.add(<br/>                            Context.shift(X, max(R.nf.columns)+1),<br/>                            fill_value = 0).applymap(int)<br/>        return R</span></pre><p id="633c" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated">在这种情况下，我们得到了<strong class="hu lq"> Include-Exclude原则</strong>的另一种近似，但是通过这种方式，我们认识到了更多情况下的精确。这意味着，如果你使用一个继承自<strong class="hu lq"> Context </strong>的新<strong class="hu lq">类ContextU </strong>，这个方法可以被重新实现以获得一个事例数的区间。</p><pre class="ir is it iu fd iv iw ix iy aw iz bi"><span id="99ff" class="ja jb ht iw b fi jc jd l je jf">&gt;&gt;&gt; X = ContextU(V1 = True, V2 = False, V3 = True)\<br/> + ContextU(V2 = False, V4 = True)<br/>&gt;&gt;&gt; X<br/>Context: at most 5 cases. <br/>    -1   0   1<br/>V1   1   1   3<br/>V2   2   2   2<br/>V3   1   1   3<br/>V4   1   3   1<br/>&gt;&gt;&gt; X + ContextU(V5=True)<br/>Context: at most 22 cases. <br/>    -3  -2  -1   0   1   2   3   4<br/>V1   1   1   3   1   3   3   1   1<br/>V2   2   2   2   2   2   3   2   2<br/>V3   1   1   3   1   3   3   1   1<br/>V4   1   3   1   3   1   3   1   1<br/>V5   3   1   1   3   3   1   1   1</span></pre><p id="0eb5" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated">当然，在本例中，确切的案例数是21，在区间(20，22)内。</p><h2 id="1a2b" class="ja jb ht bd jn ld le lf jr lg lh li jv id lj lk jz ih ll lm kd il ln lo kh lp bi translated">滴落法</h2><p id="0aa7" class="pw-post-body-paragraph hr hs ht hu b hv kj hx hy hz kk ib ic id kl if ig ih km ij ik il kn in io ip hb bi translated">考虑到有时这可能是有用的，您可以为那些必须重命名或删除的<em class="iq">索引</em>合并一个<em class="iq"> drop </em>方法:</p><pre class="ir is it iu fd iv iw ix iy aw iz bi"><span id="8d5e" class="ja jb ht iw b fi jc jd l je jf">def drop(self, *listVar):<br/>        L = [X for X in listVar if X in self.df.index]<br/>        self.df = self.df.drop(L)<br/>        self.nf = self.nf.drop(L)</span></pre><h1 id="1513" class="jm jb ht bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">一些用途</h1><p id="f5f7" class="pw-post-body-paragraph hr hs ht hu b hv kj hx hy hz kk ib ic id kl if ig ih km ij ik il kn in io ip hb bi translated">使用这个不完美的类需要一个非常智能的算法来克服大部分的弱点。这门课的一个弱点是当我们有重叠的案例时，所以如果我们想引入很多重叠的案例，案例的数量可能就没那么有趣了。</p><p id="1697" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated">这里我公开一些使用的例子。</p><h2 id="210e" class="ja jb ht bd jn ld le lf jr lg lh li jv id lj lk jz ih ll lm kd il ln lo kh lp bi translated">布尔公式的一种计数方法</h2><p id="d5ff" class="pw-post-body-paragraph hr hs ht hu b hv kj hx hy hz kk ib ic id kl if ig ih km ij ik il kn in io ip hb bi translated">我有一些不同的方法来计算布尔公式可以满足的情况，在这篇文章中，我将展示一个最简单的方法。但是考虑到我们必须避免重叠的情况，我们可以实现这个简单的代码:</p><pre class="ir is it iu fd iv iw ix iy aw iz bi"><span id="9cd1" class="ja jb ht iw b fi jc jd l je jf">def contextV(func, var1, var2, var3):<br/>    R = None<br/>    for V1 in True, False:<br/>        for V2 in True, False:<br/>            if R is None:<br/>                R = Context(**{<br/>                    var1: V1,<br/>                    var2 : V2,<br/>                    var3 : func(V1, V2)})<br/>            else:<br/>                R+=Context(**{<br/>                    var1: V1,<br/>                    var2 : V2,<br/>                    var3 : func(V1, V2)})<br/>    return R</span></pre><p id="0e24" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated">上面的代码生成了标有变量名的<em class="iq">函数</em>的<a class="ae jg" href="https://en.wikipedia.org/wiki/Truth_table" rel="noopener ugc nofollow" target="_blank">真值表</a>。</p><pre class="ir is it iu fd iv iw ix iy aw iz bi"><span id="ef58" class="ja jb ht iw b fi jc jd l je jf">&gt;&gt;&gt; contextV( int.__and__,  'A', 'B', '&amp;')<br/>Context: at least 4 cases. <br/>   0  1  2  3<br/>&amp;  1  2  2  2<br/>A  1  1  2  2<br/>B  1  2  1  2</span></pre><p id="8fab" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated">所以如果你在时间变量中捕获了一个<strong class="hu lq">布尔表达式</strong>…</p><figure class="ir is it iu fd hk er es paragraph-image"><div class="er es lu"><img src="../Images/270e3ea25d22032590d0a2597bbda1e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:950/format:webp/1*3t2vyUB6g51_wOlOKn7FYw.jpeg"/></div><figcaption class="ji jj et er es jk jl bd b be z dx">Can we demonstrate Modus Ponens is a Theorem with our new class?</figcaption></figure><p id="1c3f" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated">所以可以翻译成:</p><pre class="ir is it iu fd iv iw ix iy aw iz bi"><span id="f78e" class="ja jb ht iw b fi jc jd l je jf">&gt;&gt;&gt; P1 = contextV(lambda x, y: not(x and not y), 'B', 'q', 'C')<br/>&gt;&gt;&gt; P2 = contextV(lambda x, y: x and y, 'A', 'p', 'B')<br/>&gt;&gt;&gt; P3 = contextV(lambda x, y: not(x and not y), 'p', 'q', 'A')<br/>&gt;&gt;&gt; len(P1 * P2 * P3 * Context(C = True))<br/>4</span></pre><p id="bc26" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated">一个2变量的表达式中至少有4种情况意味着它是一个定理。</p><h2 id="b71a" class="ja jb ht bd jn ld le lf jr lg lh li jv id lj lk jz ih ll lm kd il ln lo kh lp bi translated">一种在自由上下文语言中放置上下文的方法</h2><p id="144d" class="pw-post-body-paragraph hr hs ht hu b hv kj hx hy hz kk ib ic id kl if ig ih km ij ik il kn in io ip hb bi translated">有很多算法可以用来识别语法。或许我们可以考虑一下<a class="ae jg" href="https://en.wikipedia.org/wiki/CYK_algorithm" rel="noopener ugc nofollow" target="_blank"> <strong class="hu lq"> CYK算法</strong> </a>来理解<strong class="hu lq">上下文类</strong>可以用在哪些方面。</p><p id="8a0d" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated">该算法适用于类型为<strong class="hu lq">A</strong>→<strong class="hu lq">B</strong><strong class="hu lq">C</strong>的生产和单位生产(<strong class="hu lq"> A </strong> → <strong class="hu lq"> B </strong>)。我们说该语法不识别上下文的一个原因是因为它不适用于产品<strong class="hu lq">A</strong>T24】B→<strong class="hu lq">A1</strong>T28】B1，就像将第一个符号与第二个符号连接在一起:</p><ul class=""><li id="ba4a" class="kp kq ht hu b hv hw hz ia id kr ih ks il kt ip ku kv kw kx bi translated"><strong class="hu lq">动物</strong> <strong class="hu lq">什么叫</strong> → <strong class="hu lq">狗</strong> <strong class="hu lq">叫</strong></li><li id="cdb9" class="kp kq ht hu b hv ky hz kz id la ih lb il lc ip ku kv kw kx bi translated"><strong class="hu lq">动物</strong> <strong class="hu lq">说什么</strong> → <strong class="hu lq">猫</strong> <strong class="hu lq">喵喵叫</strong></li><li id="345d" class="kp kq ht hu b hv ky hz kz id la ih lb il lc ip ku kv kw kx bi translated"><strong class="hu lq">动物</strong> <strong class="hu lq">什么叫</strong> → <strong class="hu lq">奶牛</strong> <strong class="hu lq">哞哞叫</strong></li></ul><p id="370c" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated">每个孩子都能理解的东西…</p><p id="39f1" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated">想象一下我们有一句名言:<em class="iq">我看见一个拿着望远镜的女孩</em>。这个短语在英语中(以及地球上大多数语言中)是模棱两可的，因为你无法知道你是在使用<em class="iq">望远镜</em>还是<em class="iq">望远镜</em>属于<em class="iq">女孩</em>。</p><p id="061d" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated">然而，当我们研究另一个短语时:</p><ul class=""><li id="fe33" class="kp kq ht hu b hv hw hz ia id kr ih ks il kt ip ku kv kw kx bi translated"><em class="iq">因为是她的，我看到了一个拿着望远镜的女孩</em>。</li></ul><p id="646b" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated">现在我们可以注意到，最初我们是在和女性中的某人(<em class="iq">她的</em> / <em class="iq">她</em>)一起加入不确定的东西(<em class="iq">它</em>)。在上下文中，这个短语不再模糊。</p><p id="1f2c" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated">因此，要识别一个短语，我们需要识别自由语法产生，就像在<strong class="hu lq"> CYK算法</strong>(或其他算法)中一样，并将该信息与熟悉度函数、关注度函数或<em class="iq">接受</em>函数(在一些作者中)相结合。</p><p id="f2a2" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated">想象一下单元生产(在<em class="iq">术语化</em>过程中)转换上下文对象中的每个标记，比如:</p><ul class=""><li id="a56e" class="kp kq ht hu b hv hw hz ia id kr ih ks il kt ip ku kv kw kx bi translated">因为→(解释Link = True)</li><li id="0478" class="kp kq ht hu b hv ky hz kz id la ih lb il lc ip ku kv kw kx bi translated">it →(事物=真，单数=真)+(概念=真，单数=真)</li><li id="b1b8" class="kp kq ht hu b hv ky hz kz id la ih lb il lc ip ku kv kw kx bi translated">was →(动词=真，系词=真，过去=真，单数=真)</li><li id="4561" class="kp kq ht hu b hv ky hz kz id la ih lb il lc ip ku kv kw kx bi translated">of → (prep = True)</li><li id="e99d" class="kp kq ht hu b hv ky hz kz id la ih lb il lc ip ku kv kw kx bi translated">her →(施事=真，阳性=假，单数=真)</li><li id="8976" class="kp kq ht hu b hv ky hz kz id la ih lb il lc ip ku kv kw kx bi translated">I →(施事=真，单数=真)</li><li id="3732" class="kp kq ht hu b hv ky hz kz id la ih lb il lc ip ku kv kw kx bi translated">saw →(动词=真，percep =真，系词=假，视觉=真，过去=真)</li><li id="8ce8" class="kp kq ht hu b hv ky hz kz id la ih lb il lc ip ku kv kw kx bi translated">the →( detem =真，undet =假)</li><li id="77ff" class="kp kq ht hu b hv ky hz kz id la ih lb il lc ip ku kv kw kx bi translated">女孩→(代理=真，单数=真，阳性=假)</li><li id="fd21" class="kp kq ht hu b hv ky hz kz id la ih lb il lc ip ku kv kw kx bi translated">with →(准备=真，工具=真)+(准备=真，相对=真)</li><li id="aa00" class="kp kq ht hu b hv ky hz kz id la ih lb il lc ip ku kv kw kx bi translated">a →( detem =真，undet =真)</li><li id="93e8" class="kp kq ht hu b hv ky hz kz id la ih lb il lc ip ku kv kw kx bi translated">望远镜→( thing =真，singular =真，rel =真)+(thing =真，singular =真，tool =真，visual =真)</li></ul><p id="00b0" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated">表格由单元格中的<strong class="hu lq">上下文对象</strong>更新。最初，我们放入一个由两个元素组成的元组列表:(0，每个令牌的上下文对象)。</p><p id="9cab" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated">如果算法中的每个结构都有一个索引，那么可以调用<em class="iq">项</em>来获得自由上下文语法的解释。因此，我们可以在全局字典<em class="iq"> D </em>中为每个<em class="iq">条目</em>存储一个<strong class="hu lq">上下文对象</strong>。</p><p id="f8df" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated">因此，当算法合并两个单元时，必须以这种方式进行:</p><ol class=""><li id="c513" class="kp kq ht hu b hv hw hz ia id kr ih ks il kt ip lv kv kw kx bi translated">对于规则k: [A → B C，**args]，</li><li id="da88" class="kp kq ht hu b hv ky hz kz id la ih lb il lc ip lv kv kw kx bi translated">对于元素l: <strong class="hu lq"> X </strong> = T[i，k][l][1] * T[k，j][l][1]</li><li id="5f18" class="kp kq ht hu b hv ky hz kz id la ih lb il lc ip lv kv kw kx bi translated">如果len( <strong class="hu lq"> X </strong> ) &gt;为0，则到达<em class="iq"> D </em> [ <em class="iq">项</em> ]距离最近的<em class="iq">箱<strong class="hu lq"> X </strong>。而我们把<strong class="hu lq"> C </strong>作为与最近的距离(整数)(<strong class="hu lq"> C </strong>是古怪或者<em class="iq">不熟悉</em>)。</em></li><li id="3132" class="kp kq ht hu b hv ky hz kz id la ih lb il lc ip lv kv kw kx bi translated">如果<strong class="hu lq">C</strong>T65】0，<strong class="hu lq"> X </strong>被添加到<em class="iq"> D </em> [ <em class="iq">项</em>。</li><li id="2e8a" class="kp kq ht hu b hv ky hz kz id la ih lb il lc ip lv kv kw kx bi translated">在<em class="iq"> args </em>中我们发现<em class="iq">特性</em>必须在<strong class="hu lq"> X </strong>中移除(<em class="iq"> drop </em>方法)，剩下的必须相乘:<strong class="hu lq"> X </strong> *= Context(**args)</li><li id="1178" class="kp kq ht hu b hv ky hz kz id la ih lb il lc ip lv kv kw kx bi translated">T[i，j]。追加((T[i，k][l][0] + T[k，j][l][0] + <strong class="hu lq"> C </strong> ) <strong class="hu lq">，X </strong>))</li></ol><p id="6e9d" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated">因此，如果条目有<strong class="hu lq"> n </strong>个记号，在T[0，<strong class="hu lq"> n </strong>中，我们有一个列表，按照第一个元素升序排序，我们可以得到最熟悉的解释。在<em class="iq"> D </em>中，我们会保留一些幽灵提醒，可以帮助我们在下一个短语中<strong class="hu lq">更好地保持注意力</strong>。</p><p id="e041" class="pw-post-body-paragraph hr hs ht hu b hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ip hb bi translated">最近的方法可以在<strong class="hu lq">上下文</strong>类中以这种方式实现:</p><pre class="ir is it iu fd iv iw ix iy aw iz bi"><span id="a7a4" class="ja jb ht iw b fi jc jd l je jf">def nearest(self, **argvs):<br/>        'Returns the nearest column and its distance'<br/>        result = (None, self.df.shape[0] + 1)<br/>        for i in self.df.columns:<br/>            S = 0<br/>            for feature in self.df.index:<br/>                S += int(argvs.get(feature, 3) \<br/>                         &amp; self.df[i][feature] == 0)<br/>            if S &lt; result[1]:<br/>                result = (i, S)<br/>        return result</span></pre><h1 id="638d" class="jm jb ht bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">结论</h1><p id="ae2a" class="pw-post-body-paragraph hr hs ht hu b hv kj hx hy hz kk ib ic id kl if ig ih km ij ik il kn in io ip hb bi translated">这篇文章一方面练习了数据框架，另一方面也让我意识到有时候构建不完美的类是很有趣的，因为这样会更有效率。这些类知道它们的不足和优势，可以用在算法中，让我们做一些到目前为止不可想象的事情。</p></div></div>    
</body>
</html>